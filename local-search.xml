<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux 0.11 内存管理-代码阅读记录 Linux 0.11 MMU Code Reading Record</title>
    <link href="/2024/01/02/Linux-0-11-MMU-Code-Reading-Record/"/>
    <url>/2024/01/02/Linux-0-11-MMU-Code-Reading-Record/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-0-11-内存管理代码阅读记录"><a href="#Linux-0-11-内存管理代码阅读记录" class="headerlink" title="Linux 0.11 内存管理代码阅读记录"></a>Linux 0.11 内存管理代码阅读记录</h1><p>MMU(Memory Management Unit) 代码主要是在mm&#x2F;memory.c中</p><p>此代码文件包含的函数有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_exit</span><span class="hljs-params">(<span class="hljs-type">long</span> code)</span>; <span class="hljs-comment">//非主要的函数</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">oom</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">//非主要的函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> invalidate()<span class="hljs-comment">//非主要的函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> copy_page(from,to)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_free_page</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">free_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to,<span class="hljs-type">long</span> size)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">put_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">un_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * table_entry)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_verify</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_empty_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">try_to_share</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-keyword">struct</span> task_struct * p)</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">share_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_no_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">long</span> start_mem, <span class="hljs-type">long</span> end_mem)</span> <span class="hljs-comment">// 内存初始化函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">calc_mem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">// 任何地方没有被调用过的函数</span><br></code></pre></td></tr></table></figure><h2 id="函数分类"><a href="#函数分类" class="headerlink" title="函数分类"></a>函数分类</h2><p>这么多函数，为了便于理解，先对以上的函数做一个分类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//主要操作物理内存地址的函数，与线性地址无关</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_free_page</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br><br><span class="hljs-comment">//和上面的相反，这里的两个函数是与线性地址相关的，释放和复制线性地址对应的物理地址范围</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">free_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to,<span class="hljs-type">long</span> size)</span><br><br><span class="hljs-comment">//与写时复制相关的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">un_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * table_entry)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_verify</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><br><span class="hljs-comment">//与pags.s:page_fault 相关的函数</span><br><span class="hljs-comment">//且他们的调用关系是: do_no_page -- share_page -- try_to_share</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">try_to_share</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-keyword">struct</span> task_struct * p)</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">share_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_no_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><br><span class="hljs-comment">//其他类：</span><br><span class="hljs-comment">/*内存初始化函数，在kernel_init的时候会调用*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">long</span> start_mem, <span class="hljs-type">long</span> end_mem)</span> <br><br><span class="hljs-comment">/*get_empty_page与get_free_page有什么区别？</span><br><span class="hljs-comment">get_empty_page：会将空闲的物理地址映射到线性地址</span><br><span class="hljs-comment">get_free_page: 不会映射到线性地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_empty_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><br><span class="hljs-comment">/*get_empty_page会调用put_page()*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">put_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span> <br></code></pre></td></tr></table></figure><h2 id="main函数与物理内存空间的规划"><a href="#main函数与物理内存空间的规划" class="headerlink" title="main函数与物理内存空间的规划"></a>main函数与物理内存空间的规划</h2><p>linux&#x2F;init&#x2F;main.c</p><p>main() 中关于物理内存空间的规划。</p><p><img src="/../img/Linux-0-11-MMU-Code-Reading-Record/2023-11-28-13-58-28-image.png" alt="内存初始化示意图"></p><p>内存初始化示意图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c 部分代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXT_MEM_K (*(unsigned short *)0x90002) <span class="hljs-comment">// 1MB以后的扩展内存大小（KB）</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> memory_end = <span class="hljs-number">0</span>; <span class="hljs-comment">// 机器具有的物理内存容量（B）</span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> buffer_memory_end = <span class="hljs-number">0</span>; <span class="hljs-comment">// 高速缓冲区末端地址</span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> main_memory_start = <span class="hljs-number">0</span>; <span class="hljs-comment">// 主内存开始的位置</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>        <span class="hljs-comment">/* This really IS void, no error here. */</span><br>&#123;            <span class="hljs-comment">/* The startup routine assumes (well, ...) this */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Interrupts are still disabled. Do necessary setups, then</span><br><span class="hljs-comment"> * enable them</span><br><span class="hljs-comment"> */</span><br>     ROOT_DEV = ORIG_ROOT_DEV;     <br>     drive_info = DRIVE_INFO;<br>    memory_end = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="hljs-number">10</span>);    <span class="hljs-comment">// 内存大小=1MB+扩展内存（K）*1024字节    </span><br>    memory_end &amp;= <span class="hljs-number">0xfffff000</span>; <span class="hljs-comment">// 忽略不到4KB的内存数，因为一个内存页4KB，小于4KB利用不上</span><br>    <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>) <span class="hljs-comment">// 如果内存超过16MB，则按照16MB计</span><br>        memory_end = <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">12</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>) <br>        buffer_memory_end = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;    <span class="hljs-comment">// 设置缓冲区末端地址</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">6</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)<br>        buffer_memory_end = <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">else</span><br>        buffer_memory_end = <span class="hljs-number">1</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    main_memory_start = buffer_memory_end;    <span class="hljs-comment">// 主内存起始位置=缓冲区末端</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RAMDISK_SIZE</span><br>    main_memory_start += rd_init(main_memory_start, RAMDISK_SIZE*<span class="hljs-number">1024</span>);    <span class="hljs-comment">// 占用主内存空间，定义内存虚拟盘</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    mem_init(main_memory_start,memory_end);<br>&#125;<br></code></pre></td></tr></table></figure><p>head.s 执行完毕后就会跳转到 main.c 继续执行，main.c 文件主要做了内核初始化的工作，包括了块设备、字符设备等，以及人工设置第一个任务的工作。上面的代码展现了 main() 中关于内存的规划部分。主要内容是规范内存大小、确定主存区起始位置、设置虚拟盘空间和调用 memory.c 中的主内存初始化函数。</p><p>物理内存空间的规划步骤：</p><ol><li><p>规范内存大小。代码第 14 行，求出内存大小，通过 1MB 内核区域+扩展内存区域方式求解。扩展内存（<strong>EXT_MEM_K</strong>，定义在代码第 2 行）大小为 0x90002，内存大小（<strong>memory_end</strong>，定义在代码第 3 行）计算结果为 0x241007ff。代码第 15 行，忽略不到 4K 的内存数，求解出结果 0x24100000。代码第 16~17 行，通过分支语句，判断出内存容量超过了16MB，将内存大小记为 16MB。</p></li><li><p>确定主存起始位置。代码第 18~23 行，通过内存大小，来设置高速缓冲区末端地址（<strong>buffer_memory_end</strong>，定义在代码第4行），具体分支判断过程可参考下方图片。代码第 24 行，将高速缓冲区末端地址赋值给主内存起始地址（<strong>main_memory_start</strong>，定义在代码第 5 行），至此，完成主内存区域始址的标记工作。</p></li><li><p>设置虚拟盘空间。代码第 25~27 行，通过 kernel&#x2F;blk_drv&#x2F;ramdisk.c 文件中的变量，来设置虚拟盘所占用的空间。</p></li><li><p>调用 memory.c 中的主内存初始化函数。代码第 28 行，调用 mm&#x2F;memory.c 程序中的函数 <strong>mem_init</strong>，进一步将主内存区初始化，调用形式为 mem_init(main_memory_start,memory_end);</p></li></ol><h2 id="mem-init对全局变量mem-map-的初始化"><a href="#mem-init对全局变量mem-map-的初始化" class="headerlink" title="mem_init对全局变量mem_map[] 的初始化"></a>mem_init对全局变量mem_map[] 的初始化</h2><p>mem_init() 函数主要针对主内存区域进行管理分配。mem_map[] 数据结构则表示了物理内存页面的占用状态，数组元素中的值表示被占用的次数，0 表示物理内存空闲，当申请一页物理内存时，就将对应的字节值变为1。</p><p>memory.c 部分代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// memory.c 部分代码</span><br><span class="hljs-comment">/*总结初始化流程</span><br><span class="hljs-comment"> S1：15M PAGING_MEMORY 主内存，每个页都设置为USED ，通过&gt;&gt;12 （4K）来计算页数量。4K 为每页的大小。 按照道理mem_map只是一个内存状态的映射</span><br><span class="hljs-comment"> S2：计算start_mem 所在的页数位置 ；</span><br><span class="hljs-comment"> S3：start_mem到end_mem之间的页都设置为零,表示为空闲; </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOW_MEM 0x100000  <span class="hljs-comment">//大小1MB</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGING_MEMORY (15*1024*1024)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGING_PAGES (PAGING_MEMORY&gt;&gt;12)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAP_NR(addr) (((addr)-LOW_MEM)&gt;&gt;12) <span class="hljs-comment">//LOW_MEM表示内存的低位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USED 100</span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mem_map [ PAGING_PAGES ] = &#123;<span class="hljs-number">0</span>,&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">long</span> start_mem, <span class="hljs-type">long</span> end_mem)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    HIGH_MEMORY = end_mem;  <span class="hljs-comment">//HIGH_MEMORY表示的高位</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;PAGING_PAGES ; i++)  <span class="hljs-comment">// PAGING_PAGES = 15x1024x1024 / 2^12 = (15x1024x1024) / 4096 (4K)=  3840 (PAGES)</span><br>        mem_map[i] = USED;   <span class="hljs-comment">//unsigned char 0 - 65535 </span><br>    <span class="hljs-comment">//#define 当作函数来使用。 </span><br>    i = MAP_NR(start_mem); <span class="hljs-comment">//计算start_mem在mem_map[]位置的索引i</span><br>    end_mem -= start_mem;<br>    end_mem &gt;&gt;= <span class="hljs-number">12</span>;  <span class="hljs-comment">// 计算end_mem在mem_map[]位置的索引</span><br>                     <span class="hljs-comment">// &gt;&gt;=  等价于  end_mem = end_mem &gt;&gt; 12 </span><br>    <span class="hljs-keyword">while</span> (end_mem--&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">//等价于  (end_mem --) &gt; 0 </span><br>        mem_map[i++]=<span class="hljs-number">0</span>; <span class="hljs-comment">// start_mem 到end_mem之间范围</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该变量的初始化过程为：</p><ol><li>计算非内核空间内存所需要的页面数（PAGING_PAGES，代码第 2 行）。</li><li>将高速缓冲区域以及虚拟盘区域（如果有）全部初始化为 100（代码 11~12 行）。</li><li>将主内存区域的项清零（代码 16~17 行）。</li></ol><p>以 16MB 内存大小为例。除去内核空间 1MB，mem_map 需要管理剩余 15MB 空间的页面，一共有（16MB-1MB）&#x2F;4KB&#x3D;3840 项，即 PAGING_PAGES 为 3840，主内存区域具有（16MB-4.5MB）&#x2F;4KB&#x3D;2944 项（此 4.5MB 空间还包括了高速缓冲区域及虚拟盘区域），故前 896 项在数组 mem_map 中均被置为 100，而剩余 2944 项均被置为 0，等待内存分页管理程序的分配，如图展示了 mem_map 初始化结果。</p><p><img src="/../img/Linux-0-11-MMU-Code-Reading-Record/2023-12-19-17-15-43-image.png" alt="mem_map 初始化 示意图"></p><p>mem_map 初始化</p><h2 id="free-page-amp-get-free-page"><a href="#free-page-amp-get-free-page" class="headerlink" title="free_page &amp; get_free_page"></a>free_page &amp; get_free_page</h2><p>这两个函数主要是操作物理内存地址的函数，与线性地址无关，与线性地址不产生映射。</p><h3 id="get-free-page"><a href="#get-free-page" class="headerlink" title="get_free_page"></a>get_free_page</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get physical address of first (actually last :-) free page, and mark it</span><br><span class="hljs-comment"> * used. If no free pages left, return 0.</span><br><span class="hljs-comment"> * process steps : (mainly meanings , Refrence: </span><br><span class="hljs-comment"> * https://topic.alibabacloud.com/tc/a/linux-011-kernel-memory-management-get_free_page--function-analysis_1_16_30220847.html)</span><br><span class="hljs-comment"> * 0. mem map = memory map </span><br><span class="hljs-comment"> * 1. find where are free pages</span><br><span class="hljs-comment"> * 2. set it&#x27;s mem map to 1 , and make it empty ,and return it .</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_free_page</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __res <span class="hljs-title function_">asm</span><span class="hljs-params">(<span class="hljs-string">&quot;ax&quot;</span>)</span>;<br><br>__asm__(<span class="hljs-string">&quot;std ; repne ; scasb\n\t&quot;</span><br>    <span class="hljs-string">&quot;jne 1f\n\t&quot;</span><br>    <span class="hljs-string">&quot;movb $1,1(%%edi)\n\t&quot;</span><br>    <span class="hljs-string">&quot;sall $12,%%ecx\n\t&quot;</span><br>    <span class="hljs-string">&quot;addl %2,%%ecx\n\t&quot;</span><br>    <span class="hljs-string">&quot;movl %%ecx,%%edx\n\t&quot;</span><br>    <span class="hljs-string">&quot;movl $1024,%%ecx\n\t&quot;</span><br>    <span class="hljs-string">&quot;leal 4092(%%edx),%%edi\n\t&quot;</span><br>    <span class="hljs-string">&quot;rep ; stosl\n\t&quot;</span><br>    <span class="hljs-string">&quot; movl %%edx,%%eax\n&quot;</span><br>    <span class="hljs-string">&quot;1: cld&quot;</span><br>    :<span class="hljs-string">&quot;=a&quot;</span> (__res)<br>    :<span class="hljs-string">&quot;0&quot;</span> (<span class="hljs-number">0</span>),<span class="hljs-string">&quot;i&quot;</span> (LOW_MEM),<span class="hljs-string">&quot;c&quot;</span> (PAGING_PAGES),<br>    <span class="hljs-string">&quot;D&quot;</span> (mem_map+PAGING_PAGES<span class="hljs-number">-1</span>)<br>    );<br><span class="hljs-keyword">return</span> __res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码主要由汇编构成，具体每个成分的意思可以参考<a href="https://topic.alibabacloud.com/tc/a/linux-011-kernel-memory-management-get_free_page--function-analysis_1_16_30220847.html">Linux-0.11核心記憶體管理get_free_page()函數分析</a>)</p><p>这里简述此函数主要的工作内容：</p><ol><li><p>从物理地址空间中寻址空闲页</p></li><li><p>如果找到空闲页，该页对应的mem map 为1（表示即将要使用该页） ，并设置清空对应的物理内存，并返回该地址。 如果没有空闲页，则返回0。</p></li></ol><ul><li>这里注意的是mem_map[page] &#x3D; 1 表示被占用； mem_map[page] &#x3D; 2 表示被共享。</li></ul><h3 id="free-page"><a href="#free-page" class="headerlink" title="free_page"></a>free_page</h3><p>此函数主要是根据给定的物理地址，去释放该地址的内存值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Free a page of memory at physical address &#x27;addr&#x27;. Used by</span><br><span class="hljs-comment"> * &#x27;free_page_tables()&#x27;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span> 、、 <br>&#123;<br>    <span class="hljs-keyword">if</span> (addr &lt; LOW_MEM) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (addr &gt;= HIGH_MEMORY)<br>        panic(<span class="hljs-string">&quot;trying to free nonexistent page&quot;</span>);<br>    addr -= LOW_MEM;<br>    addr &gt;&gt;= <span class="hljs-number">12</span>;  <span class="hljs-comment">// addr = addr &gt;&gt; 12 . means divide 2^12 = 4K for calculating </span><br>                  <span class="hljs-comment">// the number of page .</span><br>    <span class="hljs-keyword">if</span> (mem_map[addr]--) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// if (a--)  first condite a then  -- ; </span><br>                                  <span class="hljs-comment">// bug if the mem_map bigger than 1 (e.g == 3 ) ,is it meaningful ?</span><br>                                  <span class="hljs-comment">// mem_map[addr]&gt;=2 : page is shared </span><br>                                  <span class="hljs-comment">// mem_map[addr]&gt;=1 : page is used </span><br>    mem_map[addr]=<span class="hljs-number">0</span>;  <br>    panic(<span class="hljs-string">&quot;trying to free free page&quot;</span>); <span class="hljs-comment">//error </span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是if (mem_map[addr]–) 先判断mem_map[addr]是否大于等于1，如果条件为真，则– 并返回 ； 如果条件为假，则置零，并且报错。</p><p>但是，如果mem_map[addr]大于等于2 时，并不能完全free掉内存的占用，因为mem_map[addr]不同值代表不同的含义，应该是多次执行此函数，才可以完全free掉内存的占用。</p><h2 id="free-page-tables-amp-copy-page-tables"><a href="#free-page-tables-amp-copy-page-tables" class="headerlink" title="free_page_tables &amp; copy_page_tables"></a>free_page_tables &amp; copy_page_tables</h2><p>这里的两个是与线性地址相关的函数，释放和复制范围线性地址对应的物理地址内存</p><h3 id="free-page-tables"><a href="#free-page-tables" class="headerlink" title="free_page_tables"></a>free_page_tables</h3><p>函数作用： 释放连续的块页表，但是只处理与4M对齐的块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This function frees a continuos block of page tables, as needed</span><br><span class="hljs-comment"> * by &#x27;exit()&#x27;. As does copy_page_tables(), this handles only 4Mb blocks.</span><br><span class="hljs-comment"> * 函数功能: 释放一块连续的物理内存 </span><br><span class="hljs-comment"> * process: 工作过程</span><br><span class="hljs-comment"> * 1. begin addr + size (only aligned to 4M ,so begin address could be 0 4M 8M 12M )</span><br><span class="hljs-comment"> * 2. confirm dir : need dir location ; </span><br><span class="hljs-comment"> *    which page table : need page table location . </span><br><span class="hljs-comment"> *       if LINEAR ADDRESS , only need it&#x27;s DIR offset address.</span><br><span class="hljs-comment"> * 3. free each FRAME PAGE that relative to page table entries .</span><br><span class="hljs-comment"> * from : 线性地址</span><br><span class="hljs-comment"> * size : 长度(页表个数)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 总结: 从一个入参线性地址from 确定对应的页目录项, 页表 . 根据size大小确定要释放的范围.</span><br><span class="hljs-comment"> * 从页目录到页表 逐级遍历释放掉PAGE FRAME , 最后释放掉页表</span><br><span class="hljs-comment"> * 再刷新缓存区</span><br><span class="hljs-comment"> * 完毕.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">free_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *pg_table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * dir, nr;<br><br>    <span class="hljs-keyword">if</span> (from &amp; <span class="hljs-number">0x3fffff</span>) <span class="hljs-comment">/* 3fffff = 4M . 计算过程: 3fffff/ffffff = 1/4 ; 0xffffff = 2^24 = 16M  ; 0xffffff * 1/4 = 4M </span><br><span class="hljs-comment">                          &amp; 位与; &amp;&amp; 逻辑与</span><br><span class="hljs-comment">                         只有当from 是4M 或4M的倍数的时候,条件才为假 . 学习表达式. if (from &amp; 0xff)</span><br><span class="hljs-comment">                         表示判断某个数 from 是否在 (0xff+0x1)的边界上,如果条件为否,表示在边界上.是说明不在边界上.</span><br><span class="hljs-comment">                         linus 编程也太牛了.*/</span><br>                         <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         The expression from &amp; 0x3fffff checks if the least significant 22 bits of the from variable are non-zero. </span><br><span class="hljs-comment">                         If the result is non-zero, the if condition evaluates to true.</span><br><span class="hljs-comment">                         Therefore, the if statement will be false when from has a value that has all 22 least significant bits set to zero. </span><br><span class="hljs-comment">                         In other words, if from is a multiple of 4M (0x400000).</span><br><span class="hljs-comment">                         */</span><br>        panic(<span class="hljs-string">&quot;free_page_tables called with wrong alignment&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!from)  <span class="hljs-comment">// 判断是否为地址零,条件否,from非零；条件是,from为零,死机</span><br>        panic(<span class="hljs-string">&quot;Trying to free up swapper memory space&quot;</span>);<br>    size = (size + <span class="hljs-number">0x3fffff</span>) &gt;&gt; <span class="hljs-number">22</span>;<span class="hljs-comment">/* 计算size是有多少个页表，避免最后结果为零，+4M(0x3fffff)</span><br><span class="hljs-comment">                                    左移多少位代表什么含义?表示除2^22的大小 . 2^22 = 4M . 除4M . 计算得到多少页表个数. 一个页表能包含的额内存范围是4M </span><br><span class="hljs-comment">                                    所以在 linux 0.11 中 ,主物理内存大小是16M ,所以用4个页表表示足够了.</span><br><span class="hljs-comment">                                    */</span><br>    dir = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((from&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>); <span class="hljs-comment">/* _pg_ dir = 0 ; </span><br><span class="hljs-comment">                                 dir指的是目录项, 计算的应该是从哪个页目录项*/</span> <br>                                <span class="hljs-comment">/*  一个线性地址32bit；</span><br><span class="hljs-comment">                                    DIR(31-22)|PAGE(21-12)|OFFSET(11-0)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                    回忆一下页目录项的地址: 分别是0x0000 ; 0x0004 ; 0x0008 ;0x0012 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                    from 从上面的条件判断只能是4M或4M的倍数. </span><br><span class="hljs-comment">                                    所以得到的值会是4;8;12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                    0xffc:The purpose of this operation is to mask the lower bits </span><br><span class="hljs-comment">                                    and ensure that the resulting value is aligned to a 4KB boundary (the size of a page directory entry).</span><br><span class="hljs-comment">                                    注意这里的mask.  0xffc = 1111 1111 1100 . 所以这里是为了mask掉最后 2bits.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                    unsigned long * dir : dir是一个地址. *dir 就是该地址的值.</span><br><span class="hljs-comment">                                    例如 在调试debug的时候, 0x0004  -- 0x002027 --0x40a06700</span><br><span class="hljs-comment">                                    x 0x0004 : 0x002027 </span><br><span class="hljs-comment">                                    x 0x002027 : 0x40a06700</span><br><span class="hljs-comment">                                    x (*0x0004): 0x40a06700</span><br><span class="hljs-comment">                                    所以 *0x0004能够取到地址0x0004的内容.</span><br><span class="hljs-comment">                                    x 0x002027 与 x (*0x0004)是等价的.</span><br><span class="hljs-comment">                                */</span><br>    <span class="hljs-keyword">for</span> ( ; size--&gt;<span class="hljs-number">0</span> ; dir++) &#123;    <span class="hljs-comment">// 换个写法 : for( ; size&gt;0 ; size-- , dir ++ )</span><br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-number">1</span> &amp; *dir))          <span class="hljs-comment">// *dir 就是某一个page table的基地址, 如果*dir无效 continue   </span><br>            <span class="hljs-keyword">continue</span>;<br>        pg_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) (<span class="hljs-number">0xfffff000</span> &amp; *dir); <span class="hljs-comment">//取pa_table的基地址 mask掉最后三位无关地址的内容</span><br>        <span class="hljs-keyword">for</span> (nr=<span class="hljs-number">0</span> ; nr&lt;<span class="hljs-number">1024</span> ; nr++) &#123;  <span class="hljs-comment">//释放掉page table中的每一个entry </span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp; *pg_table)  <span class="hljs-comment">// *pa_table 指的是某一个FRAME_PAGE(4K)的地址. 如果这个地址有效call free_page ; </span><br>                                <span class="hljs-comment">//  如果无效(指已经是零,或者无法映射到物理内存FRAME PAGE), 令FRAME_PAGE =0 ()</span><br>                free_page(<span class="hljs-number">0xfffff000</span> &amp; *pg_table); <span class="hljs-comment">// 0xfffff000 &amp; *pg_table : 取地址</span><br>            *pg_table = <span class="hljs-number">0</span>;<br>            pg_table++;<br>        &#125;<br>        free_page(<span class="hljs-number">0xfffff000</span> &amp; *dir); <span class="hljs-comment">// page table 自己的mem map 置为空闲状态</span><br>        *dir = <span class="hljs-number">0</span>; <span class="hljs-comment">// page table 指向 PAGE FRAME 的地址 清零</span><br>    &#125;<br>    invalidate(); <span class="hljs-comment">//刷新缓存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="copy-page-tables"><a href="#copy-page-tables" class="headerlink" title="copy_page_tables"></a>copy_page_tables</h3><p>看懂free_page_tables函数之后，再看copy_page_tables就会简单很多，这两个函数有很多共通之处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  Well, here is one of the most complicated functions in mm. It</span><br><span class="hljs-comment"> * copies a range of linerar addresses by copying only the pages.</span><br><span class="hljs-comment"> * Let&#x27;s hope this is bug-free, &#x27;cause this one I don&#x27;t want to debug :-)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note! We don&#x27;t copy just any chunks of memory - addresses have to</span><br><span class="hljs-comment"> * be divisible by 4Mb (one page-directory entry), as this makes the</span><br><span class="hljs-comment"> * function easier. It&#x27;s used only by fork anyway.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * NOTE 2!! When from==0 we are copying kernel space for the first</span><br><span class="hljs-comment"> * fork(). Then we DONT want to copy a full page-directory entry, as</span><br><span class="hljs-comment"> * that would lead to some serious memory waste - we just copy the</span><br><span class="hljs-comment"> * first 160 pages - 640kB. Even that is more than we need, but it</span><br><span class="hljs-comment"> * doesn&#x27;t take any more memory - we don&#x27;t copy-on-write in the low</span><br><span class="hljs-comment"> * 1 Mb-range, so the pages can be shared with the kernel. Thus the</span><br><span class="hljs-comment"> * special case for nr=xxxx.</span><br><span class="hljs-comment"> * 这里注意: 最后是将from_page_table复制给to_page_table </span><br><span class="hljs-comment">    ,并且两者指向的是同一块pageframe,复制的不是page frame .</span><br><span class="hljs-comment">    函数名称也是copy_page_tables 不是copy_pages。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to,<span class="hljs-type">long</span> size)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * from_page_table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * to_page_table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> this_page;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * from_dir, * to_dir;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr;<br><br><br>    <span class="hljs-keyword">if</span> ((from&amp;<span class="hljs-number">0x3fffff</span>) || (to&amp;<span class="hljs-number">0x3fffff</span>))<br>        panic(<span class="hljs-string">&quot;copy_page_tables called with wrong alignment&quot;</span>);<br>    from_dir = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((from&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>); <span class="hljs-comment">/* _pg_dir = 0 */</span><br>    to_dir = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((to&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);<br>    size = ((<span class="hljs-type">unsigned</span>) (size+<span class="hljs-number">0x3fffff</span>)) &gt;&gt; <span class="hljs-number">22</span>;<br>    <span class="hljs-keyword">for</span>( ; size--&gt;<span class="hljs-number">0</span> ; from_dir++,to_dir++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp; *to_dir)  <span class="hljs-comment">//end page_tables </span><br>            panic(<span class="hljs-string">&quot;copy_page_tables: already exist&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-number">1</span> &amp; *from_dir))<br>            <span class="hljs-keyword">continue</span>;<br>        from_page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) (<span class="hljs-number">0xfffff000</span> &amp; *from_dir);<br>        <span class="hljs-keyword">if</span> (!(to_page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) get_free_page())) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">/* Out of memory, see freeing */</span><br>        *to_dir = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) to_page_table) | <span class="hljs-number">7</span>;<br>        nr = (from==<span class="hljs-number">0</span>)?<span class="hljs-number">0xA0</span>:<span class="hljs-number">1024</span>; <span class="hljs-comment">//0xA0=160(DEC) 只能允许复制一部分</span><br>        <span class="hljs-keyword">for</span> ( ; nr-- &gt; <span class="hljs-number">0</span> ; from_page_table++,to_page_table++) &#123;<br>            this_page = *from_page_table;<br>            <span class="hljs-keyword">if</span> (!(<span class="hljs-number">1</span> &amp; this_page))<br>                <span class="hljs-keyword">continue</span>;<br>            this_page &amp;= ~<span class="hljs-number">2</span>;   <span class="hljs-comment">//设置只读 ? // ~2　＝~10  = 01 　// this_page = this_page &amp; ~2 //为什么可以设置成只读?4K page frame的数据格式是如何定义的?</span><br>            *to_page_table = this_page;  <br>            <span class="hljs-keyword">if</span> (this_page &gt; LOW_MEM) &#123; <br>                *from_page_table = this_page; <span class="hljs-comment">//变更属性后重新赋予</span><br>                this_page -= LOW_MEM;<br>                this_page &gt;&gt;= <span class="hljs-number">12</span>;  <span class="hljs-comment">//this_page的物理地址，计算索引</span><br>                mem_map[this_page]++; <span class="hljs-comment">/*设置共享。mem_map[page] =1 表示被占用；</span><br><span class="hljs-comment">                                       mem_map[page] &gt;=2 表示被占用且共享 */</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    invalidate();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是示意图，帮助理解</p><p><img src="/../img/Linux-0-11-MMU-Code-Reading-Record/2023-12-26-14-57-26-image.png" alt="内存页复制示意图"></p><h2 id="与写时复制相关的函数"><a href="#与写时复制相关的函数" class="headerlink" title="与写时复制相关的函数"></a>与写时复制相关的函数</h2><h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>“当进程A使用系统调用fork创建一个子进程B时，由于子进程B实际上时父进程A的一个拷贝，因此会拥有与父进程相同的物理页面。为了达到节约内存和加快创建速度的目标，fork()函数会让子进程B以只读的方式共享父进程A的物理页面。同时，将父进程A对这些物理页面的访问权限也设置成只读。详见copy_page_tables()函数。这样一来，当父进程A或子进程B任何一方对这些以共享的物理页面执行写操作时，都会产生页面出错异常(page_fault int14)中断，此时CPU会执行系统提供的异常处理函数do_wp_page()来试图解决这个异常。” — 《Linux 0.11 内核完全剖析》</p><p>do_wp_page() 对写入异常中断的物理页面进行取消共享操作（调用un_wp_page()函数），为写进程复制一新的物理页面，让父进程A和子进程B各自拥有一块内容相同的物理页面。并且把将要执行写入操作的这块物理页面标记成可以写访问的。最后，从异常处理函数中返回时，CPU就会重新执行刚才导致异常的写入的操作指令，让其能够继续执行下去。</p><p>写时复制，通俗点来说，就是在存在写入时，内存才真正进行复制内存页，如果没有写入的操作，内存只是做映射共享而已。</p><p>另外，进程调用某个’系统调用‘时，会提前调用内存页面中是否有共享页面存在，如果存在，则进行写时复制。所以，这也解释了，我们日常电脑使用经验，当相同的程序再执行第二遍的时候，往往比第一遍时间要短。</p><h3 id="do-wp-page"><a href="#do-wp-page" class="headerlink" title="do_wp_page"></a>do_wp_page</h3><p>当父进程A或子进程B任何一方对这些以共享的物理页面执行写操作时，都会产生页面出错异常(page_fault int14)中断，此时CPU会执行系统提供的异常处理函数do_wp_page()来试图解决这个异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This routine handles present pages, when users try to write</span><br><span class="hljs-comment"> * to a shared page. It is done by copying the page to a new address</span><br><span class="hljs-comment"> * and decrementing the shared-page counter for the old page.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If it&#x27;s in code space we exit with a segment error.</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-comment">// The page_fault() call this function</span><br> <span class="hljs-comment">// 这个函数还是取消写保护. 因为page fault调用的时候,是因为程序想要写入共享页,但是共享页只读.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">/* we cannot do this yet: the estdio library writes to code space */</span><br><span class="hljs-comment">/* stupid, stupid. I really want the libc.a from GNU */</span><br>    <span class="hljs-keyword">if</span> (CODE_SPACE(address))<br>        do_exit(SIGSEGV);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    un_wp_page((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)<br>        (((address&gt;&gt;<span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffc</span>) + (<span class="hljs-number">0xfffff000</span> &amp;  <span class="hljs-comment">//((address&gt;&gt;10) &amp; 0xffc) 保留 DIR|PAGE . 表示某个页表项的偏移地址</span><br>        *((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((address&gt;&gt;<span class="hljs-number">20</span>) &amp;<span class="hljs-number">0xffc</span>)))));<span class="hljs-comment">/* S1: ((address&gt;&gt;20) &amp;0xffc) 保留 DIR .</span><br><span class="hljs-comment">                                                          S2:  *DIR 取地址以后 就是某个page table .</span><br><span class="hljs-comment">                                                          S3:  0xfffff000 &amp; page table获得page table所存的地址,这个地址指向某个PAGE FRAME</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                                         这两个为什么要加呢? 前者指的页表项的的偏移地址</span><br><span class="hljs-comment">                                                         后者指的是某个页表项的基地址</span><br><span class="hljs-comment">                                                         基地址+偏移地址 ,正好表示某个页表项</span><br><span class="hljs-comment">        整条命令等价于 ： up_wp_page(某个页表项具体地址)；</span><br><span class="hljs-comment">        */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="un-wp-page"><a href="#un-wp-page" class="headerlink" title="un_wp_page"></a>un_wp_page</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//un-write protect page  取消写保护，入参是某个页表项</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">un_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * table_entry)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> old_page,new_page;<br><br>    old_page = <span class="hljs-number">0xfffff000</span> &amp; *table_entry; <span class="hljs-comment">//去掉页表项属性</span><br>    <span class="hljs-comment">//页面不能写的状态有两种，占用or共享</span><br>    <span class="hljs-comment">//后者判断页面是否处于共享状态；== 1 则表示 未处于共享状态，但是处于占用状态</span><br>    <span class="hljs-keyword">if</span> (old_page &gt;= LOW_MEM &amp;&amp; mem_map[MAP_NR(old_page)]==<span class="hljs-number">1</span>) &#123;<br>        *table_entry |= <span class="hljs-number">2</span>;<span class="hljs-comment">// |2 取消写保护  r/w bit . 1 =w ; 0=r </span><br>        invalidate();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//处于共享状态，不能直接写入，如果写入会破坏原进程</span><br>    <span class="hljs-keyword">if</span> (!(new_page=get_free_page()))<span class="hljs-comment">//如果申请的新页面为空</span><br>        oom();<br>    <span class="hljs-keyword">if</span> (old_page &gt;= LOW_MEM)<span class="hljs-comment">//申请到new_page,判断old_page是否大于LOW_MEM</span><br>        mem_map[MAP_NR(old_page)]--;<span class="hljs-comment">//从2减1，取消共享标记</span><br>    *table_entry = new_page | <span class="hljs-number">7</span>; <span class="hljs-comment">// | 7 表示可读可写,让*table_entry指向new_page(物理页的地址)</span><br>    invalidate();<br>    copy_page(old_page,new_page);<span class="hljs-comment">// 将old_page复制给new_page</span><br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="write-verify"><a href="#write-verify" class="headerlink" title="write_verify"></a>write_verify</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">write_verify() : why need to verify .写页面之前做验证，目的是尝试是否可写</span><br><span class="hljs-comment">             in : linear address </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_verify</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page;<br><br>    <span class="hljs-keyword">if</span> (!( (page = *((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((address&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>)) )&amp;<span class="hljs-number">1</span>)) <span class="hljs-comment">// twice get value :  equal to ** (address &gt;&gt; 22)</span><br>        <span class="hljs-keyword">return</span>;<br>    page &amp;= <span class="hljs-number">0xfffff000</span>; <span class="hljs-comment">//去掉属性</span><br>    page += ((address&gt;&gt;<span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffc</span>);  <span class="hljs-comment">// page = page + address ( DIR | PAGE )</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-number">3</span> &amp; *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) page) == <span class="hljs-number">1</span>)  <span class="hljs-comment">/* non-writeable, present */</span>  <br>                                             <span class="hljs-comment">/* 3(dec) = 11(bin)   </span><br><span class="hljs-comment">                                                3 &amp; 1011 = 3;</span><br><span class="hljs-comment">                                                3 &amp; 1001 = 1;</span><br><span class="hljs-comment">                                                bit write/read , 0 non-writeable</span><br><span class="hljs-comment">                                            The Present bit indicates whether a page table</span><br><span class="hljs-comment">                                            entry can be used in address translation. </span><br><span class="hljs-comment">                                            P=1 indicates that the entry can be used.</span><br><span class="hljs-comment">                                             */</span><br>        un_wp_page((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) page);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="与pags-s-page-fault-相关的函数"><a href="#与pags-s-page-fault-相关的函数" class="headerlink" title="与pags.s:page_fault 相关的函数"></a>与pags.s:page_fault 相关的函数</h2><p>他们的调用关系是: do_no_page – share_page – try_to_share</p><h3 id="share-page"><a href="#share-page" class="headerlink" title="share_page"></a>share_page</h3><p>尝试寻找一个进程，可以与当前进程共享页面。address是期望共享页面的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * share_page() tries to find a process that could share a page with</span><br><span class="hljs-comment"> * the current one. Address is the address of the wanted page relative</span><br><span class="hljs-comment"> * to the current data space.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * We first check if it is at all feasible by checking executable-&gt;i_count.</span><br><span class="hljs-comment"> * It should be &gt;1 if there are other tasks sharing this inode.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">share_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> ** <span class="hljs-title">p</span>;</span>   <br><br>    <span class="hljs-keyword">if</span> (!current-&gt;executable)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (current-&gt;executable-&gt;i_count &lt; <span class="hljs-number">2</span>) <span class="hljs-comment">// ? </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) &#123;<br>        <span class="hljs-keyword">if</span> (!*p)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (current == *p)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> ((*p)-&gt;executable != current-&gt;executable)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (try_to_share(address,*p)) <span class="hljs-comment">// address 期望共享的页面地址；p某一个进程</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="try-to-share"><a href="#try-to-share" class="headerlink" title="try_to_share"></a>try_to_share</h3><p>将期望共享的页面共享给当前进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * try_to_share() checks the page at address &quot;address&quot; in the task &quot;p&quot;,</span><br><span class="hljs-comment"> * to see if it exists, and if it is clean. If so, share it with the current</span><br><span class="hljs-comment"> * task.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * NOTE! This assumes we have checked that p != current, and that they</span><br><span class="hljs-comment"> * share the same executable.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">try_to_share</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-keyword">struct</span> task_struct * p)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from_page;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to_page;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> phys_addr;<br><br>    from_page = to_page = ((address&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>); <span class="hljs-comment">// DIR</span><br>    from_page += ((p-&gt;start_code&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);  <span class="hljs-comment">// 加上相对p进程的DIR</span><br>    to_page += ((current-&gt;start_code&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);<span class="hljs-comment">// 加上相对current进程的DIR</span><br><span class="hljs-comment">/* is there a page-directory at from? */</span><br>    from = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) from_page;  <span class="hljs-comment">//from(page table entry)</span><br>    <span class="hljs-keyword">if</span> (!(from &amp; <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    from &amp;= <span class="hljs-number">0xfffff000</span>;  <span class="hljs-comment">// 去掉属性</span><br>    from_page = from + ((address&gt;&gt;<span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffc</span>); <span class="hljs-comment">//得到相对进程p的page_table_entry</span><br>    phys_addr = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) from_page; <br><span class="hljs-comment">/* is the page clean and present? */</span><br>    <span class="hljs-keyword">if</span> ((phys_addr &amp; <span class="hljs-number">0x41</span>) != <span class="hljs-number">0x01</span>) <span class="hljs-comment">//0x41 对应表项中的Dirty和Present标志</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    phys_addr &amp;= <span class="hljs-number">0xfffff000</span>;<br>    <span class="hljs-keyword">if</span> (phys_addr &gt;= HIGH_MEMORY || phys_addr &lt; LOW_MEM)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    to = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) to_page; <br>    <span class="hljs-keyword">if</span> (!(to &amp; <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">if</span> ((to = get_free_page()))<br>            *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) to_page = to | <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">else</span><br>            oom();<br>    &#125;<br>    to &amp;= <span class="hljs-number">0xfffff000</span>;<br>    to_page = to + ((address&gt;&gt;<span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffc</span>)；<span class="hljs-comment">//得到相对进程current的page_table_entry</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp; *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) to_page)<br>        panic(<span class="hljs-string">&quot;try_to_share: to_page already exists&quot;</span>);<br><span class="hljs-comment">/* share them: write-protect */</span><br>    *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) from_page &amp;= ~<span class="hljs-number">2</span>;  <span class="hljs-comment">// 设置写保护</span><br>    <span class="hljs-comment">// 共享，to_page 和from_page指向相同的物理页地址</span><br>    *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) to_page = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) from_page;<br>    invalidate();<br>    phys_addr -= LOW_MEM;<br>    phys_addr &gt;&gt;= <span class="hljs-number">12</span>;<br>    mem_map[phys_addr]++; <span class="hljs-comment">// 共享标记</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-no-page"><a href="#do-no-page" class="headerlink" title="do_no_page"></a>do_no_page</h3><p>此函数是在当进程运行时，内存分页不够用的时候，产生中断后调用此函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// @brief 这个是在当进程运行时,内存分页不够用的时候该做什么事情. </span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1. 进程动态申请内存页面 映射一页物理页</span><br><span class="hljs-comment">    2. 尝试与已加载的相同文件进行页面共享</span><br><span class="hljs-comment">    3. 从文件中读取所缺的数据页面到指定线性地址处</span><br><span class="hljs-comment">    当进程要使用内存页时,在线性地址空间寻找时,发现内存页不够了. 于是page_default调用do_no_page函数</span><br><span class="hljs-comment">    */</span><br><span class="hljs-comment">/// @param error_code </span><br><span class="hljs-comment">/// @param address  缺页的线性地址</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_no_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br>    <span class="hljs-type">int</span> nr[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tmp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page;<br>    <span class="hljs-type">int</span> block,i;<br><br>    address &amp;= <span class="hljs-number">0xfffff000</span>;<br>    tmp = address - current-&gt;start_code; <span class="hljs-comment">// 进程线性地址空间对应偏移地址  . 从进程的start_code开始计算</span><br>    <span class="hljs-keyword">if</span> (!current-&gt;executable || tmp &gt;= current-&gt;end_data) &#123;<br>        get_empty_page(address);  <span class="hljs-comment">// no_page的处理方式1 , 获取一个free page 并且与address 建立映射. </span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (share_page(tmp)) <span class="hljs-comment">// no_page 的处理方式2  </span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!(page = get_free_page()))<br>        oom();<br><span class="hljs-comment">/* remember that 1 block is used for header */</span><br>    block = <span class="hljs-number">1</span> + tmp/BLOCK_SIZE;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">4</span> ; block++,i++)<br>        nr[i] = bmap(current-&gt;executable,block);<br>    bread_page(page,current-&gt;executable-&gt;i_dev,nr);<br>    i = tmp + <span class="hljs-number">4096</span> - current-&gt;end_data;<br>    tmp = page + <span class="hljs-number">4096</span>;<br>    <span class="hljs-keyword">while</span> (i-- &gt; <span class="hljs-number">0</span>) &#123;<br>        tmp--;<br>        *(<span class="hljs-type">char</span> *)tmp = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (put_page(share_page,address))<br>        <span class="hljs-keyword">return</span>;<br>    free_page(page);<br>    oom();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="get-empty-page-amp-put-page"><a href="#get-empty-page-amp-put-page" class="headerlink" title="get_empty_page &amp; put_page"></a>get_empty_page &amp; put_page</h2><h3 id="get-empty-page"><a href="#get-empty-page" class="headerlink" title="get_empty_page"></a>get_empty_page</h3><p>此函数让一个线性地址与空闲页建立映射，这个线性地址存在一个空页面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// @brief get free page and map to address </span><br><span class="hljs-comment">//  the difference between get_empty_page and get_free_page ?</span><br><span class="hljs-comment">//  get_free_page : not relative to linear addres </span><br><span class="hljs-comment">//  get_empty_page : map free page and linear address. this page called empty page.</span><br><span class="hljs-comment">/// @param address : if successed , param address map to empty page .</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_empty_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tmp;<br><br>    <span class="hljs-keyword">if</span> (!(tmp=get_free_page()) || !put_page(tmp,address)) &#123;<br>        free_page(tmp);        <span class="hljs-comment">/* 0 is ok - ignored */</span><br>        oom();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="put-page"><a href="#put-page" class="headerlink" title="put_page"></a>put_page</h3><p>此函数是让内存页面和想要的线性地址进行映射，建立关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This function puts a page in memory at the wanted address.</span><br><span class="hljs-comment"> * It returns the physical address of the page gotten, 0 if</span><br><span class="hljs-comment"> * out of memory (either when trying to access page-table or</span><br><span class="hljs-comment"> * page.)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 入参: page(4K)-- &gt; PAGE FRAME</span><br><span class="hljs-comment"> * 入参: address  linear address</span><br><span class="hljs-comment"> * put page to  linear address </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 总结:实际上这个函数表达的意思是, 用入参address得到的page基地址 映射到 入参page基地址</span><br><span class="hljs-comment"> *         也就是变更了线性地址中的某个页表所指向的PAGEFRAME </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 有几个问题 1. page_table 是数组吗？ 如果不是 怎么可以page_table[] 进行操作 ，如果是，unsigned long page_tables 不是定义数组 </span><br><span class="hljs-comment"> *             答 : 数组的本质是指针 , 所以指针可以用数组表示,他们可以互相表示.</span><br><span class="hljs-comment"> * 2. page_table是局部变量 ,这样的映射是否有效,在函数之外?</span><br><span class="hljs-comment"> *             答 : 其实实际上操作的是内存中的值, 所以在函数之外是有效的. 对dir;page_table;pageframe操作,这些都是在内存中.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">put_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span> <br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tmp, *page_table;<br><br><span class="hljs-comment">/* NOTE !!! This uses the fact that _pg_dir=0 */</span><br><br>    <span class="hljs-keyword">if</span> (page &lt; LOW_MEM || page &gt;= HIGH_MEMORY)  <span class="hljs-comment">// page variable is page table or page entry ? page pointer ? page </span><br>        printk(<span class="hljs-string">&quot;Trying to put page %p at %p\n&quot;</span>,page,address);<br>    <span class="hljs-keyword">if</span> (mem_map[(page-LOW_MEM)&gt;&gt;<span class="hljs-number">12</span>] != <span class="hljs-number">1</span>) <br>        printk(<span class="hljs-string">&quot;mem_map disagrees with %p at %p\n&quot;</span>,page,address);<br>    page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((address&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);  <span class="hljs-comment">// 目录项偏移地址, 前面变量名应该为dir才对</span><br>    <span class="hljs-comment">// (address&gt;&gt;20) &amp; 0xffc: extract DIR(10bits) of LINER ADDRESS </span><br>    <span class="hljs-comment">//  0xffc = 1111 1111 1100 . 所以这里是为了mask掉最后 2bits.</span><br>    <span class="hljs-keyword">if</span> ((*page_table)&amp;<span class="hljs-number">1</span>) <span class="hljs-comment">//指向pagetable的DIR 是否有效</span><br>        page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) (<span class="hljs-number">0xfffff000</span> &amp; *page_table); <span class="hljs-comment">// 接上面  (unsigned long *) (0xfffff000 &amp; *dir) </span><br>                                                                   <span class="hljs-comment">//  *dir 等价于page_table </span><br>                                                                   <span class="hljs-comment">//  0xfffff000 &amp; page_table  只保留page table 中的frame page address,也就是指向某个page frame</span><br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果无效</span><br>        <span class="hljs-keyword">if</span> (!(tmp=get_free_page()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        *page_table = tmp|<span class="hljs-number">7</span>;<br>        page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) tmp;<br>    &#125;<br>    page_table[(address&gt;&gt;<span class="hljs-number">12</span>) &amp; <span class="hljs-number">0x3ff</span>] = page | <span class="hljs-number">7</span>;   <span class="hljs-comment">/* </span><br><span class="hljs-comment">                                                    address &gt;&gt; 12  保留DIR|PAGE| ; OFFSET 被移出</span><br><span class="hljs-comment">                                                    0x3ff = 0011 1111 1111   </span><br><span class="hljs-comment">                                                    (address&gt;&gt;12) &amp; 0x3ff : 保留10bits , 其他mask , get PAGE(10bits) </span><br><span class="hljs-comment">                                                    page_table[(address&gt;&gt;12) &amp; 0x3ff] 等价于 page_table[PAGE] ,</span><br><span class="hljs-comment">                                                    等价于page_table的基地址+偏移地址PAGE 可以计算得到一个page frame的起始地址</span><br><span class="hljs-comment">                                                    总结:实际上这个函数表达的意思是, 用入参address得到的page基地址 映射到 入参page基地址</span><br><span class="hljs-comment">                                                    也就是变更了线性地址中的某个页表所指向的PAGEFRAME </span><br><span class="hljs-comment">                                                    */</span>                        <br><span class="hljs-comment">/* no need for invalidate */</span><br>    <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="附：内存寻址全局图"><a href="#附：内存寻址全局图" class="headerlink" title="附：内存寻址全局图"></a>附：内存寻址全局图</h1><p><img src="/../img/Linux-0-11-MMU-Code-Reading-Record/Linux0.11-mm%2080306%20Addressing%20Machanism-Page-1.jpg"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.oldlinux.org/download/clk011c-3.0.pdf">Linux 内核完全注释</a></p><p><a href="https://weread.qq.com/web/bookReview/list?bookId=eb432a1059346feb43178b3">Linux 内核设计的艺术</a></p><p><a href="https://zhuanlan.zhihu.com/p/67714693?utm_id=0">segmentation和保护模式（二）</a></p><p><a href="https://juejin.cn/post/7084117128508342302">深入理解Linux内核虚拟内存原理与实现 - 掘金</a></p><p><a href="https://juejin.cn/post/6976168717142982693">【Linux 0.11】第十三章 内存管理 - 掘金</a></p><p><a href="https://datasheetspdf.com/datasheet/I386.html">I386 Datasheet | Intel - Datasheetspdf.com</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>MMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 0.11 内存管理-寻址 Linux 0.11 MMU Addressing Machanism</title>
    <link href="/2023/11/23/Linux-0-11-MMU-Addressing-Machanism/"/>
    <url>/2023/11/23/Linux-0-11-MMU-Addressing-Machanism/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-0-11-内存管理-寻址-Linux-0-11-MMU-Addressing-Machanism"><a href="#Linux-0-11-内存管理-寻址-Linux-0-11-MMU-Addressing-Machanism" class="headerlink" title="Linux 0.11 内存管理-寻址 Linux 0.11 MMU Addressing Machanism"></a>Linux 0.11 内存管理-寻址 Linux 0.11 MMU Addressing Machanism</h1><p>什么是内存管理? <strong>内存管理</strong>，是指<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6" title="软件">软件</a>运行时对计算机<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" title="内存">内存</a>资源的分配和使用的技术。其最主要的目的是如何高效、快速的分配，并且在适当的时候释放和回收内存资源。</p><p>在此之下还有一个关键基础内容需要了解，也就是<strong>寻址</strong></p><p><del>寻址, 是指计算机处理器通过某种特定的规则访问内存或存储器中的数据.</del></p><p>在操作系统中，”寻址”通常指的是处理器或CPU（中央处理器）计算有效地址的过程。以便内存管理或其他程序从内存中读取或写入数据。</p><p>在Linux0.11中, 内存做了分段和分页处理, 由此形成了两种不同的寻址方式.</p><p>下面我会花大量篇幅先把这两种的寻址原理介绍清楚。</p><p>下一期再介绍MMU(Memory Management Unit)。</p><h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>当程序需要访问内存时，操作系统负责将虚拟地址转换为物理地址，这个过程称为地址寻址。通过地址寻址，操作系统能够确保不同程序或进程的内存空间相互隔离，并为每个程序提供独立的虚拟地址空间。这有助于提高系统的安全性和稳定性，同时允许程序使用比实际物理内存更大的虚拟内存空间。</p><p>寻址相当于是程序的访问内存的遵循的规则，程序遵循这个规律，才能正确访问内存。</p><p>用函数表示逻辑地址到物理地址的关系, 见下方</p><p>                                            内存的物理地址&#x3D;f(逻辑地址)</p><p>f(x)在这里是一个寻址规则, 这个规则也称作变换.</p><p>操作系统中一次完整的寻址, 经过段变换(Segment Translation)和页变换(Page Translation). 两种变换的示意图如下 </p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-23-21-24-05-image.png"></p><p>段变换(Segment Translation): 将逻辑地址（虚拟地址）变换为线性地址，如果没有开启分页机制，则变换为物理地址。</p><p>页变换(Page Translation) : 将线性地址变换为物理地址</p><p>一个逻辑地址(LOGICAL ADDRESS)通过一次完整的寻址经过两次变换段变换和页变换. 如果页变换没有开启, 则线性地址(LINEAR ADDRESS)经过段变换的地址直接映射到物理地址(PHYSICAL ADDRESS).</p><p>所以可以总结, 寻址情况有两种</p><ol><li><p>经过一次段变换后实现寻址</p></li><li><p>经过段变换和页变换后实现寻址</p></li></ol><h2 id="段变换寻址"><a href="#段变换寻址" class="headerlink" title="段变换寻址"></a>段变换寻址</h2><p>段变换寻址也称在保护模式下寻址。</p><p>内存是分段的，通过一种机制如何寻址到某一个内存段。</p><h3 id="理论模型呈现"><a href="#理论模型呈现" class="headerlink" title="理论模型呈现"></a>理论模型呈现</h3><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-26-11-56-07-image.png"></p><p>在段变换中, 逻辑地址中选择子(Selector)会指向描述符表(Descriptor Table)的段描述符(Segment Descriptor), 再根据段描述符中记录的基地址与逻辑地址的偏移值(OFFSET)来得到新的地址. </p><p>如果分页机制没有开启, 那么新的地址就是得到物理地址. 否则, 得到的新地址是一个线性地址, 需经过页变换才能得到物理地址. 所述如下图</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-14-16-01-08-image.png"></p><p>这里有几个概念需要澄清一下</p><p>描述符表(Descriptor Table), 是一个数据结构里面设置了多个描述符组成的表单,通常是GDT或者LDT. </p><p>选择子(Selector), 是用于指向描述符表中某一个描述符，其实也是一个偏移值， 所以称作选择子. GDTR 确定了基地址, Selector 确定了偏移值。确定GDT中的某一个描述符。</p><p>段描述符(Segment Descriptor), 用于指向一段已经划分好的内存基地址, 并且还描述了这个内存段的限长等其他信息. </p><p>总之，这里的Selector是GDT的一个偏移值，OFFSET线性地址段的偏移值。所以逻辑地址（Logical address)的构成是两个偏移地址的组合（selector, offset)。</p><p>最终还是符合一个寻址原则：基地址+偏移地址，并且由前一个地址推导出后面一个地址。</p><h3 id="代码呈现"><a href="#代码呈现" class="headerlink" title="代码呈现"></a>代码呈现</h3><p>根据上面的一段论述, 现在已经确认好了模型</p><p>再来看看代码中是如何实现的?</p><p>代码在<strong>Setup.s</strong>中体现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">end_move:<br>    mov    $SETUPSEG, %ax    <span class="hljs-meta"># right, forgot this at first. didn<span class="hljs-string">&#x27;t work :-)</span></span><br><span class="hljs-string"><span class="hljs-meta">    mov    %ax, %ds</span></span><br><span class="hljs-string"><span class="hljs-meta">    lidt    idt_48        # load idt with 0,0</span></span><br><span class="hljs-string"><span class="hljs-meta">    lgdt    gdt_48        # load gdt with whatever appropriate</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">gdt_48:<br>    .word    <span class="hljs-number">0x800</span>            <span class="hljs-meta"># gdt limit=2048, 256 GDT entries</span><br>    .word   <span class="hljs-number">512</span>+gdt, <span class="hljs-number">0x9</span>      <span class="hljs-meta"># gdt base = 0X9xxxx, </span><br>    # <span class="hljs-number">512</span>+gdt is the real gdt after setup is moved to <span class="hljs-number">0x9020</span> * <span class="hljs-number">0x10</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">gdt:<br>    .word    <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>        <span class="hljs-meta"># dummy</span><br><br>    .word    <span class="hljs-number">0x07FF</span>        # <span class="hljs-number">8</span>Mb - limit=<span class="hljs-number">2047</span> (<span class="hljs-number">2048</span>*<span class="hljs-number">4096</span>=<span class="hljs-number">8</span>Mb)<br>    .word    <span class="hljs-number">0x0000</span>        <span class="hljs-meta"># base address=0</span><br>    .word    <span class="hljs-number">0x9A00</span>        <span class="hljs-meta"># code read/exec</span><br>    .word    <span class="hljs-number">0x00C0</span>        <span class="hljs-meta"># granularity=4096, 386</span><br><br>    .word    <span class="hljs-number">0x07FF</span>        # <span class="hljs-number">8</span>Mb - limit=<span class="hljs-number">2047</span> (<span class="hljs-number">2048</span>*<span class="hljs-number">4096</span>=<span class="hljs-number">8</span>Mb)<br>    .word    <span class="hljs-number">0x0000</span>        <span class="hljs-meta"># base address=0</span><br>    .word    <span class="hljs-number">0x9200</span>        <span class="hljs-meta"># data read/write</span><br>    .word    <span class="hljs-number">0x00C0</span>        <span class="hljs-meta"># granularity=4096, 386</span><br></code></pre></td></tr></table></figure><p>上方的几段代码执行后, 完成了工作如下图所示</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-24-13-26-46-image.png"></p><p>lgdt命令将gdt_48 的数据结构加载到GDTR中, GDTR是一个位于CPU内的寄存器。 48bit 和 数据结构是取决于GDTR的大小和结构. ( 数据结构为 32bit 基地址 | 16bit 段限长。)  限长设置0x800 . </p><p>GDT中包含 256 GDT entries, 但是只是用了3个entries .  第一项 为 空 ； 第二项为 code ; 第三项为data。</p><p>gdt 变量是一个地址。512+gdt 是移动后的gdt基地址. </p><p>在完成上述的初始化配置后, CPU的寻址过程就是 通过读取GDTR的高32bit找到GDT, 根据GDT中的描述符GD entry 的基地址找到对应的内存段, 在结合offset偏移值, 最后获取到数据. 如下图所示.</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-12-19-08-image.png"></p><p>Segment Descriptor 段描述符是一个64bit数据结构的描述符，数据结构定义如下</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-14-16-24-19-image.png"></p><h3 id="为什么需要段机制-保护模式"><a href="#为什么需要段机制-保护模式" class="headerlink" title="为什么需要段机制(保护模式)?"></a>为什么需要段机制(保护模式)?</h3><p><strong>实模式寻址VS保护模式寻址</strong></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-05-30-11-09-43-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-05-30-11-09-56-image.png"></p><p>从上方描述，“索引值”包含 内存段的基地址 ，段的最大长度值和段的访问级别。因为有这几个参数，内存访问都遵循着这个规律，所以保护了其他的内存段，程序访问时不会超过其他内存边界，不会影响到其他的内存。另外还有访问时的权限，说明只有特定的程序访问特定的内存段，所以也起到了保护作用。</p><p>保护模式寻址 需要通过一个段描述符(设置了寻址的属性)，作为映射到物理地址的一个中间手续。</p><p>举一个不恰当的例子。就像用户作为CPU，要想存钱和取钱需要经过银行柜台的认证和许可才可以取钱。这里的银行柜台就是中间手续.</p><p>银行柜台能够对银行中的钱起到保护作用；相当于描述符能够对内存起到保护作用。</p><p>银行柜台会告诉你不同身份的用户可以存取多少钱，也就是描述符会告诉你内存段的限长。银行柜台再你取钱时会确定你的身份信息, 如果另外一个人来取钱，肯定是不允许的。对于不同身份不同级别的程序，对内存的操作权限也是不同的。</p><p>相对于实模式，连银行柜台都没有，可以直接获取金库的钱。所以这很不安全。</p><h2 id="页变换寻址"><a href="#页变换寻址" class="headerlink" title="页变换寻址"></a>页变换寻址</h2><h3 id="为什么需要分页机制"><a href="#为什么需要分页机制" class="headerlink" title="为什么需要分页机制?"></a>为什么需要分页机制?</h3><p>我们看到，分段管理机制已经提供了很好的保护机制，那为什么还要加上分页管理机制呢？其实它的主要目的在于实现虚拟存储器（虚拟内存）。线性地址中任意一个页都能映射到物理地址中的任何一个页，这无疑使得内存管理变得相当灵活。</p><p>虚拟内存允许程序使用比实际物理内存更大的内存空间，同时具有以下特点：</p><ol><li>虚拟内存空间的大小可以超出物理内存空间大小。</li><li>通过操作系统的管理和调用，虚拟内存和物理内存之间的映射关系可以变化。</li></ol><p>因此，虚拟内存提供了一种灵活的内存管理方式，使得不同的进程之间彼此独立，使得某一个进程在执行时看起来拥有独立的地址空间，避免了不同进程的地址冲突问题。而线性地址空间则是实现虚拟内存机制的方式，它为程序提供了一种连续的地址空间，使得程序看起来具有独立的地址空间，与其他的程序和操作系统本身隔离开来。</p><h3 id="理论模型呈现-1"><a href="#理论模型呈现-1" class="headerlink" title="理论模型呈现"></a>理论模型呈现</h3><p>页变换是将线性地址转化为物理地址，将线性地址空间转化为物理地址空间</p><p> 线性地址来源是由逻辑地址经过段变换后得到的</p><p>一个线性地址组成 如下 </p><p>DIR | PAGE | OFFSET </p><p>DIR 包含页目录表项(PDT entry)的地址，也就是页目录表的偏移地址</p><p>PAGE 包含页表项(PT entry)的地址，也就是页表的偏移地址</p><p>OFFSET 包含内存页(4K)的偏移地址</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-23-22-04-45-image.png"></p><p>这张图表示如何通过线性地址寻址到物理地址的. 首先将线性地址拆分成三块分别是DIR, PAGE, OFFSET. </p><p>CR3是属于CPU中的寄存器包含着某个页目录表(PDT)的基地址, 而DIR则可以进一步地确认PDT中具体使用到哪个页目录项(PD entry)</p><p>页目录项(PD entry)包含着某个页表的基地址, 而线性地址中的PAGE则可以进一步地确定具体是哪个页表项</p><p>页表项中包含着某个内存分页（PAGE FRAME或者称为页帧）的基地址, 而OFFSET偏移值则可以进一步地确定内存分页中具体的内存地址.</p><p>总的来看, 不管是段变换还是页变换，寻址依旧是遵守一个原则就是, 基地址+ 偏移值，并且由前面一个推导出后面一个。</p><h3 id="代码呈现-1"><a href="#代码呈现-1" class="headerlink" title="代码呈现"></a>代码呈现</h3><p>说完了分页机制寻址模型, 接下来看看代码是如何实现的</p><p>关于分页的工作主要在代码文件head.s中, 整个代码文件主要完成的工作有:</p><p><strong>head.s</strong>做了什么工作</p><ol><li><p>从这里开始,内核完全都是在保护模式下运行了</p></li><li><p>加载各个数据段寄存器,重新设置中断描述符表 idt</p></li><li><p>然后重新设置全局描述符表 gdt</p></li><li><p>设置管理内存的分页处理机制</p></li><li><p>紧随后面放置共可寻址 16MB 内存的 4 个页表,并分别设置它们的表项</p></li></ol><p>从以上来看, 与分页机制相关的工作是3,4,5几个步骤. 工作内容3其实已经在分段机制阶段说明了, 不再赘述. 4和5工作内容详细展开来讲讲. 下面关于页变换实现的步骤陈述如下</p><p>第一步: 页目录表和页表初始化</p><p>为1个页目录表和 4 个页表（为了能够索引 16MB 内存空间）在内核中申请空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nasm">....<br>pg_dir:<br>....<br>/*<br> * I put the kernel page tables right after the page directory,<br> * using 4 of them to span 16 Mb of physical memory. People with<br> * more than 16MB will have to expand this.<br> */<br>.org 0x1000<br>pg0:<br><br>.org 0x2000<br>pg1:<br><br>.org 0x3000<br>pg2:<br><br>.org 0x4000<br>pg3:<br><br>.org 0x5000<br></code></pre></td></tr></table></figure><p>第二步: 清空页目录表和 4 个页表的内容。如代码 201~204 行所示</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-15-41-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-16-17-image.png"></p><p>第三步: 设置页目录表项映射4个页表</p><p>内核中我们设置了4个页表, 所以我们需要在页目录表中设置4个页目录项来索引它们. 如代码205 ~ 208 行所示. 第一个页表所在的线性地址为0x1000, 赋予第一个页表的属性为0x7, 表示该页存在, 可读可写. 由于每个页目录项大小为4B, 故pg_dir+4可以跳转到下一个页目录项.</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-20-38-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-51-08-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-52-44-image.png"></p><p>第四步: 对页表中的每项映射内存分页地址</p><p>设置每个页表中的页表项。每个页表大小为 4*1024B（标识物理页号范围：0-0xfff），如代码 209~214 行所示。<code>pg3+4092</code> 表示从最后一页的最后一个页表项开始填起，填写的内容为<strong>该页表项所映射的物理内存页号以及该页的属性0x7</strong>，将循环判断变量 eax 减去 4K，继续设置下一页表项，直至零，表示已将 4096 个页表项填写完毕，即 16M 内存分页完毕。<img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-56-14-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-59-32-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-59-52-image.png"></p><p>第五步: 设置CR3映射到页目录表和设置CR0开启分页机制</p><p>设置页目录表的起始地址. 将页目录表起始地址赋予CR3寄存器, 如代码216-217行所示. 开启分页机制. 如代码218 - 221 行所示, 将CR0寄存器的最高位设置为1来开启分页机制.</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-18-01-29-image.png"></p><p>总结：经过以上几个步骤之后，配置好了以下几个方面：<br>1.CR3指向页目录表<br>2.页目录表中的页目录项指向4个页表<br>3.页表中的页表项指向内存寻址空间（以4K分隔）  </p><h1 id="运行和调试"><a href="#运行和调试" class="headerlink" title="运行和调试"></a>运行和调试</h1><h2 id="线性地址到物理地址"><a href="#线性地址到物理地址" class="headerlink" title="线性地址到物理地址"></a>线性地址到物理地址</h2><p>在分页模式下，线性地址到物理地址的过程会涉及：</p><p>CR3 – Page DIR – Page DIR Entry – Page Table – Page Table Entry – Frame Page (physical address)</p><p>主要是想查看相关变量和寄存器，看下是否符合理论并且能够加深理解</p><p>通过Bochs 虚拟机，并输入相关指令可以查看寄存器和变量</p><ol><li><p>查看CR3寄存器</p><p>CR3寄存器中设置了页目录的基地址</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-16-19-38-11-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-16-19-37-44-image.png"></p><ol start="2"><li><p>查看Page DIR</p><p>按照理论，CR3的寄存器地址就是Page DIR</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-16-19-47-42-image.png"></p><p>通过上图的指令，可以查看几个页目录表的地址内容。从代码里面可以看到主要设置了4个页目录表。基本上与上方的显示结果对应。</p><p>第一个Page DIR ： 0x1027   &#x3D; 0x1000 + 0x27 </p><p>0x1000是Page Table的地址， 0x27 是关于设置页的属性。</p></li><li><p>查看Page Table</p><p>通过相同的方法查看内存地址0x1000得到的值是0x800000.这正好是一个FRAME PAGE的地址。内存寻址空间的最大在0xFFFFFF</p></li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>通过调试查看线性地址到物理地址寻址过程相关的地址。对代码有了 更深的理解。回顾一下线性地址组成</p><p>                                            DIR | PAGE | OFFSET</p><p>LINEAR ADDRESS: 0x0(+DIR) – 0x1000(+PAGE) – 0x800000(+offset)<br>假设线性地址的偏移地址都是零，用（0，0，0）来表示。所以这个线性地址得到的最终物理地址是0x800000。</p><p>如果线性地址LINEAR ADDRESS: (1,14,25)，那么最终计算结果也就前一个地址加上该位置的偏移地址后，最终推导出物理地址。而线性地址中的每一位其实是与之相对应容器的偏移值。DIR是PAGE DIR的偏移值；PAGE是PAGE TABLE的偏移值; OFFSET是FRAME PAGE的偏移值。</p></li></ol><h2 id="逻辑地址（虚拟地址）到线性地址"><a href="#逻辑地址（虚拟地址）到线性地址" class="headerlink" title="逻辑地址（虚拟地址）到线性地址"></a>逻辑地址（虚拟地址）到线性地址</h2><p>在分段模式下，逻辑地址到线性地址的过程会涉及：</p><p>GDTR – Descriptor Table – Segment Descriptor – 线性地址</p><ol><li><p>查看GDTR </p><p>在bochs中输入sreg可以查看到gdtr保存的地址, 这个0x5cb8就是指向Descriptor Table的地址</p></li></ol><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-17-22-05-03-image.png"></p><ol start="2"><li><p>查看Descriptor Table与Segment Descriptor</p><p>通过x查看某内存地址的值. 0x5cb8是gdt的基地址, +8 可以查看下一个Descriptor , 一次查看几个Descriptors, 验证一下是否与书上, 代码上的是否一致. </p><p>移动后的GDT,如下图所示：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-20-21-10-23-image.png"></p></li></ol><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-21-22-19-06-info%20gdt.png"></p><p>查看相同地址，在bochs下的显示结果：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-20-21-31-14-image.png"></p><p>查看相同地址，在qemu下的显示结果：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-17-22-22-12-image.png"></p><p>查看理论上移动后的GDT基地址：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-17-22-16-17-image.png"></p><p>分段寻址参考：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/segment-ma.jpg"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><p>因为Segment descriptor的数据结构是64bit(8B), 所以base+8可以找到下一个descriptor</p></li><li><p>通过qemu和bochs打印的descriptor会不一样，但是和理论的大差不差。</p></li><li><p>descriptor最后寻址到的是线性地址。如果没有开启分页模式那实际上就是物理地址。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.oldlinux.org/download/clk011c-3.0.pdf">Linux  内核完全注释</a></p><p><a href="https://weread.qq.com/web/bookReview/list?bookId=eb432a1059346feb43178b3">Linux 内核设计的艺术</a></p><p><a href="https://zhuanlan.zhihu.com/p/67714693?utm_id=0">segmentation和保护模式（二）</a></p><p><a href="https://juejin.cn/post/7084117128508342302">深入理解Linux内核虚拟内存原理与实现 - 掘金</a></p><p><a href="https://juejin.cn/post/6976168717142982693">【Linux 0.11】第十三章 内存管理 - 掘金</a></p><p><a href="https://datasheetspdf.com/datasheet/I386.html">I386 Datasheet | Intel - Datasheetspdf.com</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>MMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC: openharmony与android有多相似/IPC: how similar between openharmony and android</title>
    <link href="/2022/07/09/IPC-how-similar-between-openharmony-and-android/"/>
    <url>/2022/07/09/IPC-how-similar-between-openharmony-and-android/</url>
    
    <content type="html"><![CDATA[<h1 id="IPC-openharmony与android有多相似-x2F-IPC-how-similar-between-openharmony-and-android"><a href="#IPC-openharmony与android有多相似-x2F-IPC-how-similar-between-openharmony-and-android" class="headerlink" title="IPC: openharmony与android有多相似&#x2F;IPC: how similar between openharmony and android"></a>IPC: openharmony与android有多相似&#x2F;IPC: how similar between openharmony and android</h1><p>通过本篇文章 你会发现 在IPC这块的代码和架构设计 . openharmony（以下简称oh）与android 有相当大程度的相似性</p><p>可能有人会认为oh是在抄袭android, 所以给予oh负面的评价.</p><p>本篇的主要目的 不是为了贬低oh或者国人os, 只是从技术角度展示oh的真实情况. 至于什么样的评价,取决于其他人加入了什么样的想法.</p><p>科学技术代表智慧, 智慧没有国界 更没有界限 , 都是人类智慧的结晶</p><p>好了开始正文</p><h2 id="IPC-介绍"><a href="#IPC-介绍" class="headerlink" title="IPC 介绍"></a>IPC 介绍</h2><p>Binder-IPC 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。<br>从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。</p><h2 id="工作逻辑"><a href="#工作逻辑" class="headerlink" title="工作逻辑"></a>工作逻辑</h2><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/workcircle.png" alt="IPC-binder工作流程"></p><ol><li>以上这种工作逻辑来源于android的分析资料, 通过阅读oh的代码后,发现这张图也同样适用.</li></ol><h2 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a>架构方面</h2><p><strong>android</strong></p><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/arch-android.png" alt="android-binder 架构"></p><p><strong>openharmony</strong></p><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/arch-oh.png" alt="oh-binder 架构"></p><ol><li>以oh3.1为例,整理了oh-IPC的类关系图,再经过整理、删减，可以发现类的关系架构图能够和android的相对应.</li></ol><h2 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面"></a>代码方面</h2><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/stack.jpg" alt="层级关系"></p><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/code.jpg" alt="代码对比"></p><ol><li>android-IPC中的IPCThreadState与oh-IPC的BinderInvoker存在对应关系</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>以上对比了openharmony与android的架构,层级,工作逻辑还有代码. 他们基本上是差不多的. 可以说在以上展示的代码片段中, 基本一样，只是换掉了不同的名称</li><li>要说为什么要这样. 这个取决于他们都选用了同一个IPC-binder的通信框架. 技术框架一旦确定，整体方面一般不会发生变化。最多修改的是一些枝叶</li><li>在项目和产品开发中，技术选型至关重要。一旦确定后，后面的开发工作都是会围绕和基于这个选型展开</li><li>对于openharmony的评价，虽然上面有很多android 的影子，但是oh自身具备了一些android不具备的功能和特点. 例如HDF驱动框架</li><li>binder原本是一个开源项目, 不能将binder与某种操作系统绑定起来。只是这两种操作系统都采用了binder-IPC方式</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>书名：深入解析Android 5.0系统 作者：刘超 </li><li>书名：Android的设计与实现：卷Ⅰ 作者：杨云君</li><li><a href="https://gitee.com/openharmony/communication_ipc?_from=gitee_search">openharmony ipc</a></li><li><a href="http://gityuan.com/2015/10/31/binder-prepare/">Binder系列—开篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>团队周例会开展心得 comprehension of team weekly report</title>
    <link href="/2022/07/03/comprehension-of-team-weekly-report/"/>
    <url>/2022/07/03/comprehension-of-team-weekly-report/</url>
    
    <content type="html"><![CDATA[<h1 id="团队周例会开展心得-comprehension-of-team-weekly-report"><a href="#团队周例会开展心得-comprehension-of-team-weekly-report" class="headerlink" title="团队周例会开展心得 comprehension of team weekly report"></a>团队周例会开展心得 comprehension of team weekly report</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>亲身经历,目前所在公司,几千人下的一个十几人的团队中<br>每次周例会将要长达1个小时多<br>每个人对自己做的事情做一些描述,基本这样就结束了<br>大多数人多是在做流水账<br>团队leader给出一些点评和建议这样就结束了<br>而且每周都是这样<br>周例会开得不痛不痒<br>团队的效率和协作潜力根本没有激发出来<br>这样的团队怎么能够帮助公司保质保量的完成项目?</p><h2 id="这种周例会方式是有问题的"><a href="#这种周例会方式是有问题的" class="headerlink" title="这种周例会方式是有问题的"></a>这种周例会方式是有问题的</h2><p>目前的周例会方式,存在一些问题：</p><ol><li>没有将团队目标和团队计划传达到团队中的每一个人. 有的团队管理方式,可能只有团队leader自己知道目标和计划,但是没有传达到其他成员上去。导致每周开始行动之前,每位团队成员没有各自的每周目标,而且没有计划。我们团队leader也不会有要求。先说如果团队目标没有传达到每一个团队成员上并且和大家达成共识,如何凝聚团队的心呢?团队的力量一定是分散的.</li><li>在以上这种情况下,团队leader委派任务也没有时间要求,只是说这块由谁来做,给出了单单从leader角度一个任务分配责任人表就完事了. 没有和团队成员确认,是否适合做这件事情.有些团队成员脾气好一点可能直接就答应了, 不敢有其他意见. 但是内心还是有想要去做他感兴趣的事情. 在工作中和一位同事交流后才知道, 他更想做偏图像方面的开发.但是他目前在做的是系统的其他模块, 但是却没有敢和团队leader提.</li><li>团队成员大多在周报上写下的内容, 都是本周做了什么的一个描述, 流水账式的. 没有体现本周是否达成了目标, 或者获得了什么进展.或者遇到了哪些困难, 哪些风险(没有目标和计划的话,风险就无从谈起)。</li><li>没有人提建议。没有对团队中所做的事情,对达到目标偏差所造成的原因进行分析,从而做改进.</li></ol><p>周例会只是冰山一角。从周例会的一些问题来看,团队的效率不高,没有发挥团队协作的潜力.<br>从而带来的就是团队成员经常性的加班,而且那些效率高的人还要陪着效率低的人一起加班.<br>因为效率不高,公司还觉得一些员工在混加班费的…</p><h2 id="对于这些团队协作上的苦涩-整理了一些自己的看法-心得和建议"><a href="#对于这些团队协作上的苦涩-整理了一些自己的看法-心得和建议" class="headerlink" title="对于这些团队协作上的苦涩,整理了一些自己的看法,心得和建议"></a>对于这些团队协作上的苦涩,整理了一些自己的看法,心得和建议</h2><ol><li>在团队开始行动之前，需要和团队成员们对团队目标达成共识（认识到目标的意义）。需要组织一个团队会议去陈述这个目标。在会议开始之前，团队leader应该有一个自己的初步规划。任务的划分，每个子任务的责任人，时间计划等等。</li><li>团队leader委派任务和团队成员需要相互确认。确认是否有什么大的问题，如果没有特别严重的问题，团队成员接收任务之后，对任务做工作量评估，将评估结果反馈给团队leader。团队leader来看这件事情是否在团队计划内.</li><li>团队成员对任务规划自己的每周目标。下次在周例会上便可反馈是否达到了本周目标，如果没有困难，就可以反馈出来，然后就可以知道，在执行过程中，需要什么支持，依赖什么资源，需要谁的帮助。这样团队才能相互协作起来，发挥团队的协作效率，1+1&gt;2。</li><li>通过协作工具，发挥团队协作潜力。团队成员中每个人的擅长点、模块学习的累积和团队成员的每周目标应该体现在团队协作表格上，大家都能够看到的。这样团队成员就可以知道其他人在做哪些事情，擅长什么，团队下运行的过程中，成员们自己可以找相应的人寻求帮助，不用等着团队leader来协调资源。否则，没有协作的团队，一件事情每个人都要重新学习一边，一个问题对于新入手的人来说可能需要一天，对于擅长的人来说，只用10分钟就可以搞定。</li><li>一个成熟的团队不是一天两天，也不是一周两周建设起来的，需要不断的修正和打磨。团队需要在周例会上对本周的工作进行回顾和总结。对于达成目标的进行鼓励。对于，未达成目标的，分析原因，做出调整。团队或团队成员为什么没有达到目标，原因是什么，我们应该做什么调整。团队成员首先可以从自己着手的事情来提出可以调整的行动方针。<br>举个例子，我本周没有达到目标的原因是因为，处理一个系统上的问题，这个问题一直跟踪到了内核上，内核这块虽然不是我擅长的，但是我想自己搞定，结果花费了太多时间，没想到搞定这个问题之后，还会有其他内核问题。如果我能够求助其他队友，他应该就能很快能够搞定。所以，可以总结，我的下次行动建议是，如果遇到我一个不熟悉的领域，并且已经花费了少部分时间也没有搞定，这个时候应该求助于其他人。<br>这样的团队总结不是一个批斗会，而是帮助团队优化，促使每位团队成员一起成长的方法。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>team</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Lifetime</title>
    <link href="/2022/06/26/OS-Lifetime/"/>
    <url>/2022/06/26/OS-Lifetime/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-Lifetime-x2F-OS-生命周期"><a href="#OS-Lifetime-x2F-OS-生命周期" class="headerlink" title="OS Lifetime &#x2F; OS 生命周期"></a>OS Lifetime &#x2F; OS 生命周期</h1><p><img src="/../img/OS-Lifetime/OS-lifetime-Page-1.jpg" alt="OS Lifetime"></p><p><strong>操作系统生命周期 主要包含几个阶段</strong></p><p>简单描述</p><ul><li><p>重生&#x2F;Reborn :  描述一个操作系统是如何诞生的.通过用户的反馈,功能增加,性能优化,BUG修复等,不断迭代出更加完善的操作系统.</p></li><li><p>部署&#x2F;Deployment : 描述操作系统软件是如何被部署安装在不同的硬件机器上.</p></li><li><p>维护&#x2F;Maintenance : 描述OS操作系统在使用的过程中,后端工程师是如何维护和持续提升操作系统的.</p></li><li><p>优化&#x2F;Optimize : 描述OS操作系统如何通过维护方法得到优化的.</p></li></ul><p>他们是一个周期循环,是一个整体</p><h2 id="重生-x2F-Reborn"><a href="#重生-x2F-Reborn" class="headerlink" title="重生&#x2F;Reborn"></a>重生&#x2F;Reborn</h2><ol><li>一个OS镜像的组成.通常是bootloader,kernel,rootfs,oem(apps,license,repo等)组成</li><li>通过镜像制作工具(例如mkiso)可生成.img或者.iso等镜像文件</li><li>bootloader对于X86来说的是bios+grub;对于arm等嵌入式架构来说通常是fastboot等</li><li>kernel 直接获取上游开源的即可.kernel 也有针对不同平台的版本,有专门针对arm架构的,比x86架构的kernel要小的许多</li><li>rootfs的制作可以使用debootstrap,buildroot,yocto等工具直接可以构建出一个rootfs.img. debootstap 通常是使用上游debian构建好最小rootfs,方便oem定制</li><li>oem 或者不同的Linux发行版通常对桌面环境(desktop environment),仓库源,认证和证书方式做了定制. 但是底层还是借用上游的.</li><li>由于工程师手动去构建OS比较麻烦,是过程自动化,借用CI&#x2F;CD工具–jenkins实现.</li></ol><h2 id="部署-x2F-Deployment"><a href="#部署-x2F-Deployment" class="headerlink" title="部署&#x2F;Deployment"></a>部署&#x2F;Deployment</h2><ol><li>构建好系统镜像之后,就可以部署到不同的机器上了,主流x86和ARM.</li><li>对于X86来说, 通常刻在CD光碟上或者使用Udisk制作镜像盘,制作镜像盘后就可以给机器安装系统了. 在批量生产上,为了提高效率,通常使用PXE链接网络文件系统(NFS)的方式,进行批量部署安装机器</li><li>对于ARM来说,通常烧录的方式将镜像烧录到ROM中,并且前提已经做好了分区.(在X86中,通常是在安装的时候,才做的分区)</li></ol><h2 id="维护-x2F-Maintenance"><a href="#维护-x2F-Maintenance" class="headerlink" title="维护&#x2F;Maintenance"></a>维护&#x2F;Maintenance</h2><ol><li>操作系统架构设计时,已经考虑到了系统的后续维护,为了应对各种紧急情况.例如数据丢失与保护,或者系统变砖无法开机等等</li><li>对于数据丢失,系统有备份功能,将数据拷贝到备用的分区建立还原点,但下次不小心把数据搞丢时,可以通过恢复功能还原到原来的时间点.</li><li>对于系统变砖或者开不了机,系统背后存在另外一个备份系统,这个备份系统可以覆盖正在使用的系统使系统恢复正常. 这里的机制称为SLOT AB.可以用于系统升级,恢复还原等.</li><li>系统将来需要升级,也可以静默升级,因为存在另外一个备用系统,可以升级这个备用系统,而不影响目前系统的使用,下次重启之后,就可以直接使用升级后的系统.</li><li>升级也具备多种模式.例如全量升级(full update) , 差分升级(diff update) .差分升级更加适合在arm嵌入式操作系统的场合,因为磁盘资源有限. OTA升级方式包含以上两种方式.</li><li>对于后端工程师来说,系统出现了bug需要借助一系列维护工具分析问题的原因所在,从现象层面,定位到模块原因,再定位到代码原因,最后修正代码,重新提交到gitlab或者gerrit.</li></ol><h2 id="优化-x2F-Optimize"><a href="#优化-x2F-Optimize" class="headerlink" title="优化&#x2F;Optimize"></a>优化&#x2F;Optimize</h2><ol><li>通过用户的反馈,功能增加,性能优化,BUG修复等,不断迭代出版本的操作系统.</li><li>操作系统也是代码,修正代码后,提交到gitlab和gerrit进行审核.</li><li>审核通过后Code Merge到代码分支中(片段代码融入了整体)</li><li>最后还是由jenkins自动化工具构建生成新一轮的操作系统.</li></ol><p>周而复始…</p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ANN vs Hash Table</title>
    <link href="/2020/07/08/ANNvsHashTable/"/>
    <url>/2020/07/08/ANNvsHashTable/</url>
    
    <content type="html"><![CDATA[<h1 id="ANN-artificial-neural-network-VS-Hash-Table"><a href="#ANN-artificial-neural-network-VS-Hash-Table" class="headerlink" title="ANN( artificial neural network ) VS Hash Table"></a>ANN( artificial neural network ) VS Hash Table</h1><p>The story began that when I reviewed Hash table in Data Structure lesson and I saw the figure of Hash table principle ,suddenly , a idea comes to my mind that there’s somehow relationship between ANN(artificial neural network ) and  Hash Table .</p><h2 id="What’s-the-relationship"><a href="#What’s-the-relationship" class="headerlink" title="What’s the  relationship ?"></a>What’s the  relationship ?</h2><p><img src="/../img/ANNvsHashTable/ann.png" alt="figure of ANN"></p><p><img src="/../img/ANNvsHashTable/hash.png" alt="figure of Hash table"></p><p>We could notice that both two figures have three part : the left ,the middle ,the right ; Actually , each part of the middle is function part . The only difference between these is that the function of ANN is trained by tons of data and the function of Hash table ,called hash function ,is designed by manual actions usually .</p><p>The former funciton is unknown ,black box .But the later function is known ,white box .</p><h3 id="About-the-history"><a href="#About-the-history" class="headerlink" title="About the history"></a>About the history</h3><h4 id="Hash-function"><a href="#Hash-function" class="headerlink" title="Hash function"></a>Hash function</h4><blockquote><p>The term “hash” offers a natural analogy with its non-technical meaning (to “chop” or “make a mess” out of something), given how hash functions scramble their input data to derive their output.[20] In his research for the precise origin of the term, Donald Knuth notes that, while Hans Peter Luhn of IBM appears to have been the first to use the concept of a hash function in a memo dated January 1953, the term itself would only appear in published literature in the late 1960s, on Herbert Hellerman’s Digital Computer System Principles, even though it was already widespread jargon by then.[21]</p></blockquote><h4 id="ANN"><a href="#ANN" class="headerlink" title="ANN"></a>ANN</h4><blockquote><p>Warren McCulloch and Walter Pitts[4] (1943) opened the subject by creating a computational model for neural networks.[5] In the late 1940s, D. O. Hebb[6] created a learning hypothesis based on the mechanism of neural plasticity that became known as Hebbian learning. Farley and Wesley A. Clark[7] (1954) first used computational machines, then called “calculators”, to simulate a Hebbian network. Rosenblatt[8] (1958) created the perceptron.[9] The first functional networks with many layers were published by Ivakhnenko and Lapa in 1965, as the Group Method of Data Handling.[10][11][12] The basics of continuous backpropagation[10][13][14][15] were derived in the context of control theory by Kelley[16] in 1960 and by Bryson in 1961,[17] using principles of dynamic programming.</p></blockquote><p>According to these history , the first ANN came out at 1943 and the first concept of hash function came out at 1953 . The time between these are so close , it can’t be wasn’t somehow relationship in there !!</p><h2 id="What’s-role-of-Hash-table-played-in-Data-Structure"><a href="#What’s-role-of-Hash-table-played-in-Data-Structure" class="headerlink" title="What’s role of Hash table played in Data Structure ?"></a>What’s role of Hash table played in Data Structure ?</h2><blockquote><p>In computing, a hash table (hash map) is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index, also called a hash code, into an array of buckets or slots, from which the desired value can be found. During lookup, the key is hashed and the resulting hash indicates where the corresponding value is stored.</p></blockquote><h3 id="Why-Hash-table-called-“Hash-table-“"><a href="#Why-Hash-table-called-“Hash-table-“" class="headerlink" title="Why Hash table called “Hash table “?"></a>Why Hash table called “Hash table “?</h3><p>I supposed Hash is people’s name who invented Hash function and Hash table . But actually , it wasn’t . </p><p><a href="https://softwareengineering.stackexchange.com/questions/108124/why-it-is-called-hash-table-or-hash-function-hash-doesnt-make-any-sense-t">Why it is called “hash table”, or “hash function”? </a></p><h2 id="What’s-role-of-ANN-played-in-Machine-Learning"><a href="#What’s-role-of-ANN-played-in-Machine-Learning" class="headerlink" title="What’s role of ANN played in Machine Learning ?"></a>What’s role of ANN played in Machine Learning ?</h2><blockquote><p>Artificial neural networks (ANN) or connectionist systems are computing systems vaguely inspired by the biological neural networks that constitute animal brains.</p></blockquote><blockquote><p>The data structures and functionality of neural nets are designed to simulate associative memory. Neural nets learn by processing examples, each of which contains a known “input” and “result,” forming probability-weighted asociations between the two, which are stored within the data structure of the net itself. (The “input” here is more accurately called an input set, since it generally consists of multiple independent variables, rather than a single value.) Thus, the “learning” of a neural net from a given example is the difference in the state of the net before and after processing the example. After being given a sufficient number of examples, the net becomes capable of predicting results from inputs, using the associations built from the example set. If a feedback loop is provided to the neural net about the accuracy of its predictions, it continues to refine its associations, resulting in an ever-increasing level of accuracy. In short, there is a direct relationship between the number and diversity of examples processed by a neural net and the accuracy of its predictions. This is why a neural net gets “better” with use. What is interesting about neural nets is that because they are indiscriminate in the way they form associations, they can form unexpected associations, and reveal relationships and dependencies that were not previously known.</p></blockquote><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We discussed the similarity and differences of ANN and Hash table in aspects of principle and history , which hopefully we could discover the new idea that are able to optimize algorithms of both or apply to the some specific issues  . One of the applications ,in my opinion , is that the Hash function could be replace by method of DeepLearning whose function trained by data . The advantages of this method is save algorithms development time of handled design .</p><p>On the other hand , because of the same structure form –input, functions, output – it’s unfortunately that , in some way ,there is no prograss about AI field during computer science development .</p><p>If we want to make some application using ideas we discovered ,we have to research in it more .</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Artificial_neural_network">wiki&#x2F;Artificial_neural_network</a></p><p><a href="https://en.wikipedia.org/wiki/Hash_table">wiki&#x2F;Hash_table</a></p><p><a href="https://en.wikipedia.org/wiki/Hash_function">wiki&#x2F;Hash_function</a></p><p><a href="https://softwareengineering.stackexchange.com/questions/108124/why-it-is-called-hash-table-or-hash-function-hash-doesnt-make-any-sense-t">Why it is called “hash table”, or “hash function”? </a></p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Robomaster Evolution</title>
    <link href="/2020/05/09/RobomasterRovo/"/>
    <url>/2020/05/09/RobomasterRovo/</url>
    
    <content type="html"><![CDATA[<h1 id="Robomaster-Evolution"><a href="#Robomaster-Evolution" class="headerlink" title="Robomaster Evolution"></a>Robomaster Evolution</h1><p><img src="/../img/RobomasterRovo/00.jpg"><br><img src="/../img/RobomasterRovo/01.jpg"><br><img src="/../img/RobomasterRovo/02.jpg"><br><img src="/../img/RobomasterRovo/03.jpg"><br><img src="/../img/RobomasterRovo/04.jpg"><br><img src="/../img/RobomasterRovo/05.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
      <tag>Robot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Structure From Multi-Views</title>
    <link href="/2020/05/06/StructureFromMultiViews/"/>
    <url>/2020/05/06/StructureFromMultiViews/</url>
    
    <content type="html"><![CDATA[<h1 id="Structure-From-Multi-Views"><a href="#Structure-From-Multi-Views" class="headerlink" title="Structure From Multi-Views"></a>Structure From Multi-Views</h1><h2 id="DEMO-at-first"><a href="#DEMO-at-first" class="headerlink" title="DEMO at first"></a>DEMO at first</h2><p><img src="/../img/StructureFromMultiViews/demo.gif" alt="DEMO"></p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ol start="0"><li><p>this project is modified from Chapter4_StructureFromMotion</p></li><li><p>non gpu version is better for beginner of learning CV . i.e. compile the project would be easy .</p></li><li><p>structure from multiple views</p></li><li><p>use AKAZE FeatureDetector and DescriptorExtractor instead of ORB </p></li><li><p>non opencv3_contrib verison</p></li></ol><h2 id="AKAZE-VS-ORB"><a href="#AKAZE-VS-ORB" class="headerlink" title="AKAZE VS ORB"></a>AKAZE VS ORB</h2><blockquote><p>We have concluded that, although ORB is faster to compute, AKAZE shows a better compromise between speed and performance than ORB for images with low resolution. Keywords: ORB, AKAZE, UAV, visual odometry, feature matching.</p></blockquote><p><a href="http://www.epacis.net/ccis2016/papers/paper_121.pdf">For more details – &gt; paper </a></p><h2 id="Matcher-FLANN-BASED-MATCHER-VS-BFMATCHER"><a href="#Matcher-FLANN-BASED-MATCHER-VS-BFMATCHER" class="headerlink" title="Matcher : FLANN-BASED MATCHER VS BFMATCHER"></a>Matcher : FLANN-BASED MATCHER VS BFMATCHER</h2><blockquote><p>BFMatcher is going to try all the possibilities (which is the meaning of “Brute Force” and hence it will find the best matches.</p></blockquote><blockquote><p>FLANN, meaning “Fast Library for Approximate Nearest Neighbors”, will be much faster but will find an approximate nearest neighbors. It will find a good matching, but not necessarily the best possible one. You can play with FLANN’s parameters in order to increase the precision (i.e. the “quality” of the matchings), but it will be at the cost of slowing the algorithm.</p></blockquote><blockquote><p>In other words: FLANN is much faster than BFMatcher but it only finds an approximate nearest neighbor, which is a good matching but not necessarily the best. You can play with the parameters of FLANN in order to increase its speed or its precision.</p></blockquote><p><a href="https://stackoverflow.com/questions/10610966/difference-between-bfmatcher-and-flannbasedmatcher">For more details – &gt; Q&amp;A </a></p><h2 id="Parse-SFM-project"><a href="#Parse-SFM-project" class="headerlink" title="Parse SFM project"></a>Parse SFM project</h2><h3 id="Files-Function"><a href="#Files-Function" class="headerlink" title="Files Function"></a>Files Function</h3><p><img src="/../img/StructureFromMultiViews/filesfunction.jpg"></p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="/../img/StructureFromMultiViews/UML.jpg"></p><h3 id="process-diagram"><a href="#process-diagram" class="headerlink" title="process diagram"></a>process diagram</h3><p><img src="/../img/StructureFromMultiViews/process.jpg"></p><h2 id="Project-repository"><a href="#Project-repository" class="headerlink" title="Project repository"></a>Project repository</h2><p><a href="https://github.com/MasteringOpenCV/code/tree/master/Chapter4_StructureFromMotion">original–Chapter4_StructureFromMotion</a></p><p><a href="https://github.com/pans0ul/StructureFromMultiViews">this project</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>SFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Structure From two views</title>
    <link href="/2020/04/28/StructureFrom2views/"/>
    <url>/2020/04/28/StructureFrom2views/</url>
    
    <content type="html"><![CDATA[<h1 id="Structure-From-two-views"><a href="#Structure-From-two-views" class="headerlink" title="Structure From two views"></a>Structure From two views</h1><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ol start="0"><li><p>this project is modified from Chapter4_StructureFromMotion</p></li><li><p>non gpu version is better for beginner of learning CV . i.e. compile the project would be easy .</p></li><li><p>structure from two views</p></li><li><p>non opencv3_contrib verison</p></li></ol><h2 id="Fix-bug-in-the-project"><a href="#Fix-bug-in-the-project" class="headerlink" title="Fix bug in the project"></a>Fix bug in the project</h2><h3 id="original-in-Distance-h"><a href="#original-in-Distance-h" class="headerlink" title="original in Distance.h"></a>original in Distance.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnlyMatchFeatures</span><span class="hljs-params">(<span class="hljs-type">int</span> strategy = STRATEGY_USE_OPTICAL_FLOW + STRATEGY_USE_DENSE_OF + STRATEGY_USE_FEATURE_MATCH)</span> </span>&#123;<br>imgpts1.<span class="hljs-built_in">clear</span>(); imgpts2.<span class="hljs-built_in">clear</span>(); fullpts1.<span class="hljs-built_in">clear</span>(); fullpts2.<span class="hljs-built_in">clear</span>();<br><br>std::vector&lt;cv::Mat&gt; imgs; imgs.<span class="hljs-built_in">push_back</span>(left_im); imgs.<span class="hljs-built_in">push_back</span>(right_im);<br>std::vector&lt;std::vector&lt;cv::KeyPoint&gt; &gt; imgpts; imgpts.<span class="hljs-built_in">push_back</span>(imgpts1); imgpts.<span class="hljs-built_in">push_back</span>(imgpts2);<br><br><span class="hljs-function">RichFeatureMatcher <span class="hljs-title">rfm</span><span class="hljs-params">(imgs,imgpts)</span></span>;<br>rfm.<span class="hljs-built_in">MatchFeatures</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>imgpts1 = rfm.<span class="hljs-built_in">GetImagePoints</span>(<span class="hljs-number">0</span>);<br>imgpts2 = rfm.<span class="hljs-built_in">GetImagePoints</span>(<span class="hljs-number">1</span>);<br><br>features_matched = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RecoverDepthFromImages</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(!features_matched) <br><span class="hljs-built_in">OnlyMatchFeatures</span>();<br><br>std::vector&lt;cv::DMatch&gt; matches;<br><span class="hljs-built_in">FindCameraMatrices</span>(K, Kinv, distortion_coeff, imgpts1, imgpts2, imgpts1_good, imgpts2_good, P, P1, matches, pointcloud<br><br></code></pre></td></tr></table></figure><h3 id="modified-in-Distance-h"><a href="#modified-in-Distance-h" class="headerlink" title="modified in Distance.h"></a>modified in Distance.h</h3><ol><li>the variable matches is set as global in class Distance </li><li>rfm.MatchFeatures(0, 1,&amp;matches);</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">OnlyMatchFeatures(<span class="hljs-params">int</span> <span class="hljs-params">strategy</span> = STRATEGY_USE_OPTICAL_FLOW + STRATEGY_USE_DENSE_OF + STRATEGY_USE_FEATURE_MATCH)</span> &#123;<span class="hljs-comment">//Q</span><br>imgpts1.clear<span class="hljs-literal">()</span>; imgpts2.clear<span class="hljs-literal">()</span>; fullpts1.clear<span class="hljs-literal">()</span>; fullpts2.clear<span class="hljs-literal">()</span>;<br><br>std::vector&lt;cv::Mat&gt; imgs; imgs.push<span class="hljs-constructor">_back(<span class="hljs-params">left_im</span>)</span>; imgs.push<span class="hljs-constructor">_back(<span class="hljs-params">right_im</span>)</span>;<br>std::vector&lt;std::vector&lt;cv::KeyPoint&gt; &gt; imgpts; imgpts.push<span class="hljs-constructor">_back(<span class="hljs-params">imgpts1</span>)</span>; imgpts.push<span class="hljs-constructor">_back(<span class="hljs-params">imgpts2</span>)</span>;<br><br>RichFeatureMatcher rfm(imgs,imgpts); <span class="hljs-comment">//detect feature &amp; compute descriptors as globle of class RichFeatureMatcher</span><br><br><br><span class="hljs-comment">//pans0ul fix</span><br>rfm.<span class="hljs-constructor">MatchFeatures(0, 1,&amp;<span class="hljs-params">matches</span>)</span>;<br><br>imgpts1 = rfm.<span class="hljs-constructor">GetImagePoints(0)</span>; <span class="hljs-comment">//imgpts1 is globle of Distance</span><br>imgpts2 = rfm.<span class="hljs-constructor">GetImagePoints(1)</span>;<br><br>features_matched = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Reasons"><a href="#Reasons" class="headerlink" title="Reasons"></a>Reasons</h3><ol><li>function MatchFeatures() will update variable matches </li><li>the correct algorithm order is function FindCameraMatrices() after get matches </li><li>if the variable matches is empty ,there is no necessary to compute camera matrix</li></ol><h2 id="Parse-SFM-project"><a href="#Parse-SFM-project" class="headerlink" title="Parse SFM project"></a>Parse SFM project</h2><h3 id="Files-Function"><a href="#Files-Function" class="headerlink" title="Files Function"></a>Files Function</h3><p><img src="/../img/StructureFrom2views/filesfunction.jpg"></p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="/../img/StructureFrom2views/UML.jpg"></p><h3 id="process-diagram"><a href="#process-diagram" class="headerlink" title="process diagram"></a>process diagram</h3><p><img src="/../img/StructureFrom2views/process.jpg"></p><h2 id="Project-repository"><a href="#Project-repository" class="headerlink" title="Project repository"></a>Project repository</h2><p><a href="https://github.com/MasteringOpenCV/code/tree/master/Chapter4_StructureFromMotion">original–Chapter4_StructureFromMotion</a></p><p><a href="https://github.com/pans0ul/StructureFrom2views_of_Chapter4_StructureFromMotion">this project</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>SFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>National Undergraduate Electronic Design Contest</title>
    <link href="/2020/04/21/nationalUndergraduateElectronicDesignContest/"/>
    <url>/2020/04/21/nationalUndergraduateElectronicDesignContest/</url>
    
    <content type="html"><![CDATA[<h1 id="National-Undergraduate-Electronic-Design-Contest"><a href="#National-Undergraduate-Electronic-Design-Contest" class="headerlink" title="National Undergraduate Electronic Design Contest"></a>National Undergraduate Electronic Design Contest</h1><p><strong>National Undergraduate Electronic Design Contest consists of two parts .One is analog electronic design ,another is theme design.</strong> </p><p><img src="/../img/NationalUndergraduateElectronicDesignContest/Nation%20ELEC%20Match-A.jpg" alt="analog practise"></p><p><img src="/../img/NationalUndergraduateElectronicDesignContest/Nation%20ELEC%20Match-xian.jpg" alt="Contest memories"></p><p><img src="/../img/NationalUndergraduateElectronicDesignContest/li-poem.jpg" alt="poem from Mr.Li"></p><p><strong>致谢</strong><br><strong>温州大学</strong><br><strong>我的导师–陈老师</strong><br><strong>我的导师和诗人–李老师</strong><br><strong>我的两位队友</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reading SFM in book Mastering OpenCV</title>
    <link href="/2020/04/03/Reading-SFM%20in%20book%20-Mastering%20OpenCV/"/>
    <url>/2020/04/03/Reading-SFM%20in%20book%20-Mastering%20OpenCV/</url>
    
    <content type="html"><![CDATA[<h1 id="Reading-SFM-in-book-Mastering-OpenCV"><a href="#Reading-SFM-in-book-Mastering-OpenCV" class="headerlink" title="Reading SFM in book: Mastering OpenCV"></a>Reading SFM in book: Mastering OpenCV</h1><blockquote><p>Mastering OpenCV with Practical Computer Vision Projects</p></blockquote><h3 id="chartper-4-Exploring-Structure-from-Motion-Using-OpenCV"><a href="#chartper-4-Exploring-Structure-from-Motion-Using-OpenCV" class="headerlink" title="chartper 4 : Exploring Structure from Motion Using OpenCV"></a>chartper 4 : Exploring Structure from Motion Using OpenCV</h3><p><strong>This book is a good tutorial to explain SFM ( structure from motion ) implementation . I give brief about in this charpter : SFM covered</strong></p><p><img src="/../img/Reading-SFM%20in%20book%20-Mastering%20OpenCV/2020-04-18-15-41-49.png"></p><h3 id="Section-1-Structure-from-Motion-concepts"><a href="#Section-1-Structure-from-Motion-concepts" class="headerlink" title="Section 1 : Structure from Motion concepts"></a>Section 1 : Structure from Motion concepts</h3><p>Every knowledge was built by concepts at first .Structure from Motion concepts in Section 1  to tell us that what is SFM ,about concepts related to SFM ,such as camera calibration ,triangulation of 3d points ,camera motion ,the brief of principle that how to reconstruction 3D object , etc..</p><h3 id="Section-2-Estimating-the-camera-motion-from-a-pair-of-images"><a href="#Section-2-Estimating-the-camera-motion-from-a-pair-of-images" class="headerlink" title="Section 2: Estimating the camera motion from a pair of images"></a>Section 2: Estimating the camera motion from a pair of images</h3><p>Estimating the camera motion from a pair of images talk about that how to get Essential Matrix and decompose it to obtain the R, t  from two key images which are taken from monocular with sequence time , where R is rotation matrix of camera motion ,and the t  is translation matrix of camera motion . Briefly ,R , t is two key matrix to consist of camera motion .</p><h3 id="Section-3-Reconstructing-the-scene"><a href="#Section-3-Reconstructing-the-scene" class="headerlink" title="Section 3 : Reconstructing the scene"></a>Section 3 : Reconstructing the scene</h3><p>Reconstructing the scene to tell us that after extract camera motion matrix , we use triangulation method and motion matrix to reconstruct 3d points into the scene ,but only to use two camera views . Then this book give the mothed how to extract high quality 3d points by using contrasting two 2d points . one of the point is original in the photo and another is reimaged point from 3d points . </p><h3 id="Section-4-Reconstruction-from-many-views"><a href="#Section-4-Reconstruction-from-many-views" class="headerlink" title="Section 4 : Reconstruction from many views"></a>Section 4 : Reconstruction from many views</h3><p>According the method from Section3 , the principle of Reconstruction from many views would be same . So it just does more procedures to be done .</p><h3 id="Section-5-Refinement-of-the-reconstruction"><a href="#Section-5-Refinement-of-the-reconstruction" class="headerlink" title="Section 5 : Refinement of the reconstruction"></a>Section 5 : Refinement of the reconstruction</h3><p>Refinement of the reconstruction .This process is helpful for get precise and high quality 3d points . The known as the process of Bundle Adjustment(BA) ,helping for refining and optimizing the reconstructed scene . One implementation of a bundle adjustment algorithm is Simple Sparse Bundle Adjustment (SSBA) . You will see the illustration of construction between algorithm applied and doesn’t .</p><h3 id="Section-6-Visualizing-3D-point-clouds"><a href="#Section-6-Visualizing-3D-point-clouds" class="headerlink" title="Section 6: Visualizing 3D point clouds"></a>Section 6: Visualizing 3D point clouds</h3><p>Visualizing 3D point clouds ,this section give a introduction about visualization tool, PCL (point cloud library) , The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D&#x2F;3D image and point cloud processing. Also could be use in this case—SFM.</p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>SFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D-printer</title>
    <link href="/2019/08/18/3d-printer/"/>
    <url>/2019/08/18/3d-printer/</url>
    
    <content type="html"><![CDATA[<h1 id="DIY-for-3D-printer-during-two-weeks"><a href="#DIY-for-3D-printer-during-two-weeks" class="headerlink" title="DIY for 3D-printer during two weeks"></a>DIY for 3D-printer during two weeks</h1><p><img src="/../img/3d-printer/3D-PRINTER-comp.jpg" alt="some components"><br><img src="/../img/3d-printer/3D-PRINTER-assem.jpg" alt="building"><br><img src="/../img/3d-printer/3D-PRINTER-run.jpg" alt="try to print"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
