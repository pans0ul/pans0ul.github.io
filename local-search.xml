<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux 0.11 内存管理-代码阅读记录 Linux 0.11 MMU Code Reading Record</title>
    <link href="/2024/01/02/Linux-0-11-MMU-Code-Reading-Record/"/>
    <url>/2024/01/02/Linux-0-11-MMU-Code-Reading-Record/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-0-11-内存管理代码阅读记录"><a href="#Linux-0-11-内存管理代码阅读记录" class="headerlink" title="Linux 0.11 内存管理代码阅读记录"></a>Linux 0.11 内存管理代码阅读记录</h1><p>MMU(Memory Management Unit) 代码主要是在mm&#x2F;memory.c中</p><p>此代码文件包含的函数有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">do_exit</span><span class="hljs-params">(<span class="hljs-type">long</span> code)</span>; <span class="hljs-comment">//非主要的函数</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">oom</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">//非主要的函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> invalidate()<span class="hljs-comment">//非主要的函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> copy_page(from,to)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_free_page</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">free_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to,<span class="hljs-type">long</span> size)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">put_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">un_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * table_entry)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_verify</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_empty_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">try_to_share</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-keyword">struct</span> task_struct * p)</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">share_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_no_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">long</span> start_mem, <span class="hljs-type">long</span> end_mem)</span> <span class="hljs-comment">// 内存初始化函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">calc_mem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">// 任何地方没有被调用过的函数</span><br></code></pre></td></tr></table></figure><h2 id="函数分类"><a href="#函数分类" class="headerlink" title="函数分类"></a>函数分类</h2><p>这么多函数，为了便于理解，先对以上的函数做一个分类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//主要操作物理内存地址的函数，与线性地址无关</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_free_page</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span><br><br><span class="hljs-comment">//和上面的相反，这里的两个函数是与线性地址相关的，释放和复制线性地址对应的物理地址范围</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">free_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to,<span class="hljs-type">long</span> size)</span><br><br><span class="hljs-comment">//与写时复制相关的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">un_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * table_entry)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_verify</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><br><span class="hljs-comment">//与pags.s:page_fault 相关的函数</span><br><span class="hljs-comment">//且他们的调用关系是: do_no_page -- share_page -- try_to_share</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">try_to_share</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-keyword">struct</span> task_struct * p)</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">share_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_no_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><br><span class="hljs-comment">//其他类：</span><br><span class="hljs-comment">/*内存初始化函数，在kernel_init的时候会调用*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">long</span> start_mem, <span class="hljs-type">long</span> end_mem)</span> <br><br><span class="hljs-comment">/*get_empty_page与get_free_page有什么区别？</span><br><span class="hljs-comment">get_empty_page：会将空闲的物理地址映射到线性地址</span><br><span class="hljs-comment">get_free_page: 不会映射到线性地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_empty_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br><br><span class="hljs-comment">/*get_empty_page会调用put_page()*/</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">put_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span> <br></code></pre></td></tr></table></figure><h2 id="main函数与物理内存空间的规划"><a href="#main函数与物理内存空间的规划" class="headerlink" title="main函数与物理内存空间的规划"></a>main函数与物理内存空间的规划</h2><p>linux&#x2F;init&#x2F;main.c</p><p>main() 中关于物理内存空间的规划。</p><p><img src="/../img/Linux-0-11-MMU-Code-Reading-Record/2023-11-28-13-58-28-image.png" alt="内存初始化示意图"></p><p>内存初始化示意图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c 部分代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXT_MEM_K (*(unsigned short *)0x90002) <span class="hljs-comment">// 1MB以后的扩展内存大小（KB）</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> memory_end = <span class="hljs-number">0</span>; <span class="hljs-comment">// 机器具有的物理内存容量（B）</span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> buffer_memory_end = <span class="hljs-number">0</span>; <span class="hljs-comment">// 高速缓冲区末端地址</span><br><span class="hljs-type">static</span> <span class="hljs-type">long</span> main_memory_start = <span class="hljs-number">0</span>; <span class="hljs-comment">// 主内存开始的位置</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>        <span class="hljs-comment">/* This really IS void, no error here. */</span><br>&#123;            <span class="hljs-comment">/* The startup routine assumes (well, ...) this */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Interrupts are still disabled. Do necessary setups, then</span><br><span class="hljs-comment"> * enable them</span><br><span class="hljs-comment"> */</span><br>     ROOT_DEV = ORIG_ROOT_DEV;     <br>     drive_info = DRIVE_INFO;<br>    memory_end = (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="hljs-number">10</span>);    <span class="hljs-comment">// 内存大小=1MB+扩展内存（K）*1024字节    </span><br>    memory_end &amp;= <span class="hljs-number">0xfffff000</span>; <span class="hljs-comment">// 忽略不到4KB的内存数，因为一个内存页4KB，小于4KB利用不上</span><br>    <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>) <span class="hljs-comment">// 如果内存超过16MB，则按照16MB计</span><br>        memory_end = <span class="hljs-number">16</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">12</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>) <br>        buffer_memory_end = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;    <span class="hljs-comment">// 设置缓冲区末端地址</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (memory_end &gt; <span class="hljs-number">6</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)<br>        buffer_memory_end = <span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    <span class="hljs-keyword">else</span><br>        buffer_memory_end = <span class="hljs-number">1</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br>    main_memory_start = buffer_memory_end;    <span class="hljs-comment">// 主内存起始位置=缓冲区末端</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RAMDISK_SIZE</span><br>    main_memory_start += rd_init(main_memory_start, RAMDISK_SIZE*<span class="hljs-number">1024</span>);    <span class="hljs-comment">// 占用主内存空间，定义内存虚拟盘</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    mem_init(main_memory_start,memory_end);<br>&#125;<br></code></pre></td></tr></table></figure><p>head.s 执行完毕后就会跳转到 main.c 继续执行，main.c 文件主要做了内核初始化的工作，包括了块设备、字符设备等，以及人工设置第一个任务的工作。上面的代码展现了 main() 中关于内存的规划部分。主要内容是规范内存大小、确定主存区起始位置、设置虚拟盘空间和调用 memory.c 中的主内存初始化函数。</p><p>物理内存空间的规划步骤：</p><ol><li><p>规范内存大小。代码第 14 行，求出内存大小，通过 1MB 内核区域+扩展内存区域方式求解。扩展内存（<strong>EXT_MEM_K</strong>，定义在代码第 2 行）大小为 0x90002，内存大小（<strong>memory_end</strong>，定义在代码第 3 行）计算结果为 0x241007ff。代码第 15 行，忽略不到 4K 的内存数，求解出结果 0x24100000。代码第 16~17 行，通过分支语句，判断出内存容量超过了16MB，将内存大小记为 16MB。</p></li><li><p>确定主存起始位置。代码第 18~23 行，通过内存大小，来设置高速缓冲区末端地址（<strong>buffer_memory_end</strong>，定义在代码第4行），具体分支判断过程可参考下方图片。代码第 24 行，将高速缓冲区末端地址赋值给主内存起始地址（<strong>main_memory_start</strong>，定义在代码第 5 行），至此，完成主内存区域始址的标记工作。</p></li><li><p>设置虚拟盘空间。代码第 25~27 行，通过 kernel&#x2F;blk_drv&#x2F;ramdisk.c 文件中的变量，来设置虚拟盘所占用的空间。</p></li><li><p>调用 memory.c 中的主内存初始化函数。代码第 28 行，调用 mm&#x2F;memory.c 程序中的函数 <strong>mem_init</strong>，进一步将主内存区初始化，调用形式为 mem_init(main_memory_start,memory_end);</p></li></ol><h2 id="mem-init对全局变量mem-map-的初始化"><a href="#mem-init对全局变量mem-map-的初始化" class="headerlink" title="mem_init对全局变量mem_map[] 的初始化"></a>mem_init对全局变量mem_map[] 的初始化</h2><p>mem_init() 函数主要针对主内存区域进行管理分配。mem_map[] 数据结构则表示了物理内存页面的占用状态，数组元素中的值表示被占用的次数，0 表示物理内存空闲，当申请一页物理内存时，就将对应的字节值变为1。</p><p>memory.c 部分代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// memory.c 部分代码</span><br><span class="hljs-comment">/*总结初始化流程</span><br><span class="hljs-comment"> S1：15M PAGING_MEMORY 主内存，每个页都设置为USED ，通过&gt;&gt;12 （4K）来计算页数量。4K 为每页的大小。 按照道理mem_map只是一个内存状态的映射</span><br><span class="hljs-comment"> S2：计算start_mem 所在的页数位置 ；</span><br><span class="hljs-comment"> S3：start_mem到end_mem之间的页都设置为零,表示为空闲; </span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOW_MEM 0x100000  <span class="hljs-comment">//大小1MB</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGING_MEMORY (15*1024*1024)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGING_PAGES (PAGING_MEMORY&gt;&gt;12)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAP_NR(addr) (((addr)-LOW_MEM)&gt;&gt;12) <span class="hljs-comment">//LOW_MEM表示内存的低位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USED 100</span><br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mem_map [ PAGING_PAGES ] = &#123;<span class="hljs-number">0</span>,&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">mem_init</span><span class="hljs-params">(<span class="hljs-type">long</span> start_mem, <span class="hljs-type">long</span> end_mem)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    HIGH_MEMORY = end_mem;  <span class="hljs-comment">//HIGH_MEMORY表示的高位</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;PAGING_PAGES ; i++)  <span class="hljs-comment">// PAGING_PAGES = 15x1024x1024 / 2^12 = (15x1024x1024) / 4096 (4K)=  3840 (PAGES)</span><br>        mem_map[i] = USED;   <span class="hljs-comment">//unsigned char 0 - 65535 </span><br>    <span class="hljs-comment">//#define 当作函数来使用。 </span><br>    i = MAP_NR(start_mem); <span class="hljs-comment">//计算start_mem在mem_map[]位置的索引i</span><br>    end_mem -= start_mem;<br>    end_mem &gt;&gt;= <span class="hljs-number">12</span>;  <span class="hljs-comment">// 计算end_mem在mem_map[]位置的索引</span><br>                     <span class="hljs-comment">// &gt;&gt;=  等价于  end_mem = end_mem &gt;&gt; 12 </span><br>    <span class="hljs-keyword">while</span> (end_mem--&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">//等价于  (end_mem --) &gt; 0 </span><br>        mem_map[i++]=<span class="hljs-number">0</span>; <span class="hljs-comment">// start_mem 到end_mem之间范围</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该变量的初始化过程为：</p><ol><li>计算非内核空间内存所需要的页面数（PAGING_PAGES，代码第 2 行）。</li><li>将高速缓冲区域以及虚拟盘区域（如果有）全部初始化为 100（代码 11~12 行）。</li><li>将主内存区域的项清零（代码 16~17 行）。</li></ol><p>以 16MB 内存大小为例。除去内核空间 1MB，mem_map 需要管理剩余 15MB 空间的页面，一共有（16MB-1MB）&#x2F;4KB&#x3D;3840 项，即 PAGING_PAGES 为 3840，主内存区域具有（16MB-4.5MB）&#x2F;4KB&#x3D;2944 项（此 4.5MB 空间还包括了高速缓冲区域及虚拟盘区域），故前 896 项在数组 mem_map 中均被置为 100，而剩余 2944 项均被置为 0，等待内存分页管理程序的分配，如图展示了 mem_map 初始化结果。</p><p><img src="/../img/Linux-0-11-MMU-Code-Reading-Record/2023-12-19-17-15-43-image.png" alt="mem_map 初始化 示意图"></p><p>mem_map 初始化</p><h2 id="free-page-amp-get-free-page"><a href="#free-page-amp-get-free-page" class="headerlink" title="free_page &amp; get_free_page"></a>free_page &amp; get_free_page</h2><p>这两个函数主要是操作物理内存地址的函数，与线性地址无关，与线性地址不产生映射。</p><h3 id="get-free-page"><a href="#get-free-page" class="headerlink" title="get_free_page"></a>get_free_page</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Get physical address of first (actually last :-) free page, and mark it</span><br><span class="hljs-comment"> * used. If no free pages left, return 0.</span><br><span class="hljs-comment"> * process steps : (mainly meanings , Refrence: </span><br><span class="hljs-comment"> * https://topic.alibabacloud.com/tc/a/linux-011-kernel-memory-management-get_free_page--function-analysis_1_16_30220847.html)</span><br><span class="hljs-comment"> * 0. mem map = memory map </span><br><span class="hljs-comment"> * 1. find where are free pages</span><br><span class="hljs-comment"> * 2. set it&#x27;s mem map to 1 , and make it empty ,and return it .</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_free_page</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">register</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __res <span class="hljs-title function_">asm</span><span class="hljs-params">(<span class="hljs-string">&quot;ax&quot;</span>)</span>;<br><br>__asm__(<span class="hljs-string">&quot;std ; repne ; scasb\n\t&quot;</span><br>    <span class="hljs-string">&quot;jne 1f\n\t&quot;</span><br>    <span class="hljs-string">&quot;movb $1,1(%%edi)\n\t&quot;</span><br>    <span class="hljs-string">&quot;sall $12,%%ecx\n\t&quot;</span><br>    <span class="hljs-string">&quot;addl %2,%%ecx\n\t&quot;</span><br>    <span class="hljs-string">&quot;movl %%ecx,%%edx\n\t&quot;</span><br>    <span class="hljs-string">&quot;movl $1024,%%ecx\n\t&quot;</span><br>    <span class="hljs-string">&quot;leal 4092(%%edx),%%edi\n\t&quot;</span><br>    <span class="hljs-string">&quot;rep ; stosl\n\t&quot;</span><br>    <span class="hljs-string">&quot; movl %%edx,%%eax\n&quot;</span><br>    <span class="hljs-string">&quot;1: cld&quot;</span><br>    :<span class="hljs-string">&quot;=a&quot;</span> (__res)<br>    :<span class="hljs-string">&quot;0&quot;</span> (<span class="hljs-number">0</span>),<span class="hljs-string">&quot;i&quot;</span> (LOW_MEM),<span class="hljs-string">&quot;c&quot;</span> (PAGING_PAGES),<br>    <span class="hljs-string">&quot;D&quot;</span> (mem_map+PAGING_PAGES<span class="hljs-number">-1</span>)<br>    );<br><span class="hljs-keyword">return</span> __res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码主要由汇编构成，具体每个成分的意思可以参考<a href="https://topic.alibabacloud.com/tc/a/linux-011-kernel-memory-management-get_free_page--function-analysis_1_16_30220847.html">Linux-0.11核心記憶體管理get_free_page()函數分析</a>)</p><p>这里简述此函数主要的工作内容：</p><ol><li><p>从物理地址空间中寻址空闲页</p></li><li><p>如果找到空闲页，该页对应的mem map 为1（表示即将要使用该页） ，并设置清空对应的物理内存，并返回该地址。 如果没有空闲页，则返回0。</p></li></ol><ul><li>这里注意的是mem_map[page] &#x3D; 1 表示被占用； mem_map[page] &#x3D; 2 表示被共享。</li></ul><h3 id="free-page"><a href="#free-page" class="headerlink" title="free_page"></a>free_page</h3><p>此函数主要是根据给定的物理地址，去释放该地址的内存值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Free a page of memory at physical address &#x27;addr&#x27;. Used by</span><br><span class="hljs-comment"> * &#x27;free_page_tables()&#x27;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">free_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr)</span> 、、 <br>&#123;<br>    <span class="hljs-keyword">if</span> (addr &lt; LOW_MEM) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (addr &gt;= HIGH_MEMORY)<br>        panic(<span class="hljs-string">&quot;trying to free nonexistent page&quot;</span>);<br>    addr -= LOW_MEM;<br>    addr &gt;&gt;= <span class="hljs-number">12</span>;  <span class="hljs-comment">// addr = addr &gt;&gt; 12 . means divide 2^12 = 4K for calculating </span><br>                  <span class="hljs-comment">// the number of page .</span><br>    <span class="hljs-keyword">if</span> (mem_map[addr]--) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// if (a--)  first condite a then  -- ; </span><br>                                  <span class="hljs-comment">// bug if the mem_map bigger than 1 (e.g == 3 ) ,is it meaningful ?</span><br>                                  <span class="hljs-comment">// mem_map[addr]&gt;=2 : page is shared </span><br>                                  <span class="hljs-comment">// mem_map[addr]&gt;=1 : page is used </span><br>    mem_map[addr]=<span class="hljs-number">0</span>;  <br>    panic(<span class="hljs-string">&quot;trying to free free page&quot;</span>); <span class="hljs-comment">//error </span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是if (mem_map[addr]–) 先判断mem_map[addr]是否大于等于1，如果条件为真，则– 并返回 ； 如果条件为假，则置零，并且报错。</p><p>但是，如果mem_map[addr]大于等于2 时，并不能完全free掉内存的占用，因为mem_map[addr]不同值代表不同的含义，应该是多次执行此函数，才可以完全free掉内存的占用。</p><h2 id="free-page-tables-amp-copy-page-tables"><a href="#free-page-tables-amp-copy-page-tables" class="headerlink" title="free_page_tables &amp; copy_page_tables"></a>free_page_tables &amp; copy_page_tables</h2><p>这里的两个是与线性地址相关的函数，释放和复制范围线性地址对应的物理地址内存</p><h3 id="free-page-tables"><a href="#free-page-tables" class="headerlink" title="free_page_tables"></a>free_page_tables</h3><p>函数作用： 释放连续的块页表，但是只处理与4M对齐的块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This function frees a continuos block of page tables, as needed</span><br><span class="hljs-comment"> * by &#x27;exit()&#x27;. As does copy_page_tables(), this handles only 4Mb blocks.</span><br><span class="hljs-comment"> * 函数功能: 释放一块连续的物理内存 </span><br><span class="hljs-comment"> * process: 工作过程</span><br><span class="hljs-comment"> * 1. begin addr + size (only aligned to 4M ,so begin address could be 0 4M 8M 12M )</span><br><span class="hljs-comment"> * 2. confirm dir : need dir location ; </span><br><span class="hljs-comment"> *    which page table : need page table location . </span><br><span class="hljs-comment"> *       if LINEAR ADDRESS , only need it&#x27;s DIR offset address.</span><br><span class="hljs-comment"> * 3. free each FRAME PAGE that relative to page table entries .</span><br><span class="hljs-comment"> * from : 线性地址</span><br><span class="hljs-comment"> * size : 长度(页表个数)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 总结: 从一个入参线性地址from 确定对应的页目录项, 页表 . 根据size大小确定要释放的范围.</span><br><span class="hljs-comment"> * 从页目录到页表 逐级遍历释放掉PAGE FRAME , 最后释放掉页表</span><br><span class="hljs-comment"> * 再刷新缓存区</span><br><span class="hljs-comment"> * 完毕.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">free_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *pg_table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * dir, nr;<br><br>    <span class="hljs-keyword">if</span> (from &amp; <span class="hljs-number">0x3fffff</span>) <span class="hljs-comment">/* 3fffff = 4M . 计算过程: 3fffff/ffffff = 1/4 ; 0xffffff = 2^24 = 16M  ; 0xffffff * 1/4 = 4M </span><br><span class="hljs-comment">                          &amp; 位与; &amp;&amp; 逻辑与</span><br><span class="hljs-comment">                         只有当from 是4M 或4M的倍数的时候,条件才为假 . 学习表达式. if (from &amp; 0xff)</span><br><span class="hljs-comment">                         表示判断某个数 from 是否在 (0xff+0x1)的边界上,如果条件为否,表示在边界上.是说明不在边界上.</span><br><span class="hljs-comment">                         linus 编程也太牛了.*/</span><br>                         <span class="hljs-comment">/*</span><br><span class="hljs-comment">                         The expression from &amp; 0x3fffff checks if the least significant 22 bits of the from variable are non-zero. </span><br><span class="hljs-comment">                         If the result is non-zero, the if condition evaluates to true.</span><br><span class="hljs-comment">                         Therefore, the if statement will be false when from has a value that has all 22 least significant bits set to zero. </span><br><span class="hljs-comment">                         In other words, if from is a multiple of 4M (0x400000).</span><br><span class="hljs-comment">                         */</span><br>        panic(<span class="hljs-string">&quot;free_page_tables called with wrong alignment&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!from)  <span class="hljs-comment">// 判断是否为地址零,条件否,from非零；条件是,from为零,死机</span><br>        panic(<span class="hljs-string">&quot;Trying to free up swapper memory space&quot;</span>);<br>    size = (size + <span class="hljs-number">0x3fffff</span>) &gt;&gt; <span class="hljs-number">22</span>;<span class="hljs-comment">/* 计算size是有多少个页表，避免最后结果为零，+4M(0x3fffff)</span><br><span class="hljs-comment">                                    左移多少位代表什么含义?表示除2^22的大小 . 2^22 = 4M . 除4M . 计算得到多少页表个数. 一个页表能包含的额内存范围是4M </span><br><span class="hljs-comment">                                    所以在 linux 0.11 中 ,主物理内存大小是16M ,所以用4个页表表示足够了.</span><br><span class="hljs-comment">                                    */</span><br>    dir = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((from&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>); <span class="hljs-comment">/* _pg_ dir = 0 ; </span><br><span class="hljs-comment">                                 dir指的是目录项, 计算的应该是从哪个页目录项*/</span> <br>                                <span class="hljs-comment">/*  一个线性地址32bit；</span><br><span class="hljs-comment">                                    DIR(31-22)|PAGE(21-12)|OFFSET(11-0)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                    回忆一下页目录项的地址: 分别是0x0000 ; 0x0004 ; 0x0008 ;0x0012 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                    from 从上面的条件判断只能是4M或4M的倍数. </span><br><span class="hljs-comment">                                    所以得到的值会是4;8;12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                    0xffc:The purpose of this operation is to mask the lower bits </span><br><span class="hljs-comment">                                    and ensure that the resulting value is aligned to a 4KB boundary (the size of a page directory entry).</span><br><span class="hljs-comment">                                    注意这里的mask.  0xffc = 1111 1111 1100 . 所以这里是为了mask掉最后 2bits.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                    unsigned long * dir : dir是一个地址. *dir 就是该地址的值.</span><br><span class="hljs-comment">                                    例如 在调试debug的时候, 0x0004  -- 0x002027 --0x40a06700</span><br><span class="hljs-comment">                                    x 0x0004 : 0x002027 </span><br><span class="hljs-comment">                                    x 0x002027 : 0x40a06700</span><br><span class="hljs-comment">                                    x (*0x0004): 0x40a06700</span><br><span class="hljs-comment">                                    所以 *0x0004能够取到地址0x0004的内容.</span><br><span class="hljs-comment">                                    x 0x002027 与 x (*0x0004)是等价的.</span><br><span class="hljs-comment">                                */</span><br>    <span class="hljs-keyword">for</span> ( ; size--&gt;<span class="hljs-number">0</span> ; dir++) &#123;    <span class="hljs-comment">// 换个写法 : for( ; size&gt;0 ; size-- , dir ++ )</span><br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-number">1</span> &amp; *dir))          <span class="hljs-comment">// *dir 就是某一个page table的基地址, 如果*dir无效 continue   </span><br>            <span class="hljs-keyword">continue</span>;<br>        pg_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) (<span class="hljs-number">0xfffff000</span> &amp; *dir); <span class="hljs-comment">//取pa_table的基地址 mask掉最后三位无关地址的内容</span><br>        <span class="hljs-keyword">for</span> (nr=<span class="hljs-number">0</span> ; nr&lt;<span class="hljs-number">1024</span> ; nr++) &#123;  <span class="hljs-comment">//释放掉page table中的每一个entry </span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp; *pg_table)  <span class="hljs-comment">// *pa_table 指的是某一个FRAME_PAGE(4K)的地址. 如果这个地址有效call free_page ; </span><br>                                <span class="hljs-comment">//  如果无效(指已经是零,或者无法映射到物理内存FRAME PAGE), 令FRAME_PAGE =0 ()</span><br>                free_page(<span class="hljs-number">0xfffff000</span> &amp; *pg_table); <span class="hljs-comment">// 0xfffff000 &amp; *pg_table : 取地址</span><br>            *pg_table = <span class="hljs-number">0</span>;<br>            pg_table++;<br>        &#125;<br>        free_page(<span class="hljs-number">0xfffff000</span> &amp; *dir); <span class="hljs-comment">// page table 自己的mem map 置为空闲状态</span><br>        *dir = <span class="hljs-number">0</span>; <span class="hljs-comment">// page table 指向 PAGE FRAME 的地址 清零</span><br>    &#125;<br>    invalidate(); <span class="hljs-comment">//刷新缓存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="copy-page-tables"><a href="#copy-page-tables" class="headerlink" title="copy_page_tables"></a>copy_page_tables</h3><p>看懂free_page_tables函数之后，再看copy_page_tables就会简单很多，这两个函数有很多共通之处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  Well, here is one of the most complicated functions in mm. It</span><br><span class="hljs-comment"> * copies a range of linerar addresses by copying only the pages.</span><br><span class="hljs-comment"> * Let&#x27;s hope this is bug-free, &#x27;cause this one I don&#x27;t want to debug :-)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note! We don&#x27;t copy just any chunks of memory - addresses have to</span><br><span class="hljs-comment"> * be divisible by 4Mb (one page-directory entry), as this makes the</span><br><span class="hljs-comment"> * function easier. It&#x27;s used only by fork anyway.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * NOTE 2!! When from==0 we are copying kernel space for the first</span><br><span class="hljs-comment"> * fork(). Then we DONT want to copy a full page-directory entry, as</span><br><span class="hljs-comment"> * that would lead to some serious memory waste - we just copy the</span><br><span class="hljs-comment"> * first 160 pages - 640kB. Even that is more than we need, but it</span><br><span class="hljs-comment"> * doesn&#x27;t take any more memory - we don&#x27;t copy-on-write in the low</span><br><span class="hljs-comment"> * 1 Mb-range, so the pages can be shared with the kernel. Thus the</span><br><span class="hljs-comment"> * special case for nr=xxxx.</span><br><span class="hljs-comment"> * 这里注意: 最后是将from_page_table复制给to_page_table </span><br><span class="hljs-comment">    ,并且两者指向的是同一块pageframe,复制的不是page frame .</span><br><span class="hljs-comment">    函数名称也是copy_page_tables 不是copy_pages。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy_page_tables</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to,<span class="hljs-type">long</span> size)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * from_page_table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * to_page_table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> this_page;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * from_dir, * to_dir;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> nr;<br><br><br>    <span class="hljs-keyword">if</span> ((from&amp;<span class="hljs-number">0x3fffff</span>) || (to&amp;<span class="hljs-number">0x3fffff</span>))<br>        panic(<span class="hljs-string">&quot;copy_page_tables called with wrong alignment&quot;</span>);<br>    from_dir = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((from&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>); <span class="hljs-comment">/* _pg_dir = 0 */</span><br>    to_dir = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((to&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);<br>    size = ((<span class="hljs-type">unsigned</span>) (size+<span class="hljs-number">0x3fffff</span>)) &gt;&gt; <span class="hljs-number">22</span>;<br>    <span class="hljs-keyword">for</span>( ; size--&gt;<span class="hljs-number">0</span> ; from_dir++,to_dir++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp; *to_dir)  <span class="hljs-comment">//end page_tables </span><br>            panic(<span class="hljs-string">&quot;copy_page_tables: already exist&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!(<span class="hljs-number">1</span> &amp; *from_dir))<br>            <span class="hljs-keyword">continue</span>;<br>        from_page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) (<span class="hljs-number">0xfffff000</span> &amp; *from_dir);<br>        <span class="hljs-keyword">if</span> (!(to_page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) get_free_page())) <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">/* Out of memory, see freeing */</span><br>        *to_dir = ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) to_page_table) | <span class="hljs-number">7</span>;<br>        nr = (from==<span class="hljs-number">0</span>)?<span class="hljs-number">0xA0</span>:<span class="hljs-number">1024</span>; <span class="hljs-comment">//0xA0=160(DEC) 只能允许复制一部分</span><br>        <span class="hljs-keyword">for</span> ( ; nr-- &gt; <span class="hljs-number">0</span> ; from_page_table++,to_page_table++) &#123;<br>            this_page = *from_page_table;<br>            <span class="hljs-keyword">if</span> (!(<span class="hljs-number">1</span> &amp; this_page))<br>                <span class="hljs-keyword">continue</span>;<br>            this_page &amp;= ~<span class="hljs-number">2</span>;   <span class="hljs-comment">//设置只读 ? // ~2　＝~10  = 01 　// this_page = this_page &amp; ~2 //为什么可以设置成只读?4K page frame的数据格式是如何定义的?</span><br>            *to_page_table = this_page;  <br>            <span class="hljs-keyword">if</span> (this_page &gt; LOW_MEM) &#123; <br>                *from_page_table = this_page; <span class="hljs-comment">//变更属性后重新赋予</span><br>                this_page -= LOW_MEM;<br>                this_page &gt;&gt;= <span class="hljs-number">12</span>;  <span class="hljs-comment">//this_page的物理地址，计算索引</span><br>                mem_map[this_page]++; <span class="hljs-comment">/*设置共享。mem_map[page] =1 表示被占用；</span><br><span class="hljs-comment">                                       mem_map[page] &gt;=2 表示被占用且共享 */</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    invalidate();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是示意图，帮助理解</p><p><img src="/../img/Linux-0-11-MMU-Code-Reading-Record/2023-12-26-14-57-26-image.png" alt="内存页复制示意图"></p><h2 id="与写时复制相关的函数"><a href="#与写时复制相关的函数" class="headerlink" title="与写时复制相关的函数"></a>与写时复制相关的函数</h2><h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>“当进程A使用系统调用fork创建一个子进程B时，由于子进程B实际上时父进程A的一个拷贝，因此会拥有与父进程相同的物理页面。为了达到节约内存和加快创建速度的目标，fork()函数会让子进程B以只读的方式共享父进程A的物理页面。同时，将父进程A对这些物理页面的访问权限也设置成只读。详见copy_page_tables()函数。这样一来，当父进程A或子进程B任何一方对这些以共享的物理页面执行写操作时，都会产生页面出错异常(page_fault int14)中断，此时CPU会执行系统提供的异常处理函数do_wp_page()来试图解决这个异常。” — 《Linux 0.11 内核完全剖析》</p><p>do_wp_page() 对写入异常中断的物理页面进行取消共享操作（调用un_wp_page()函数），为写进程复制一新的物理页面，让父进程A和子进程B各自拥有一块内容相同的物理页面。并且把将要执行写入操作的这块物理页面标记成可以写访问的。最后，从异常处理函数中返回时，CPU就会重新执行刚才导致异常的写入的操作指令，让其能够继续执行下去。</p><p>写时复制，通俗点来说，就是在存在写入时，内存才真正进行复制内存页，如果没有写入的操作，内存只是做映射共享而已。</p><p>另外，进程调用某个’系统调用‘时，会提前调用内存页面中是否有共享页面存在，如果存在，则进行写时复制。所以，这也解释了，我们日常电脑使用经验，当相同的程序再执行第二遍的时候，往往比第一遍时间要短。</p><h3 id="do-wp-page"><a href="#do-wp-page" class="headerlink" title="do_wp_page"></a>do_wp_page</h3><p>当父进程A或子进程B任何一方对这些以共享的物理页面执行写操作时，都会产生页面出错异常(page_fault int14)中断，此时CPU会执行系统提供的异常处理函数do_wp_page()来试图解决这个异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This routine handles present pages, when users try to write</span><br><span class="hljs-comment"> * to a shared page. It is done by copying the page to a new address</span><br><span class="hljs-comment"> * and decrementing the shared-page counter for the old page.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If it&#x27;s in code space we exit with a segment error.</span><br><span class="hljs-comment"> */</span><br><br> <span class="hljs-comment">// The page_fault() call this function</span><br> <span class="hljs-comment">// 这个函数还是取消写保护. 因为page fault调用的时候,是因为程序想要写入共享页,但是共享页只读.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">/* we cannot do this yet: the estdio library writes to code space */</span><br><span class="hljs-comment">/* stupid, stupid. I really want the libc.a from GNU */</span><br>    <span class="hljs-keyword">if</span> (CODE_SPACE(address))<br>        do_exit(SIGSEGV);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    un_wp_page((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *)<br>        (((address&gt;&gt;<span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffc</span>) + (<span class="hljs-number">0xfffff000</span> &amp;  <span class="hljs-comment">//((address&gt;&gt;10) &amp; 0xffc) 保留 DIR|PAGE . 表示某个页表项的偏移地址</span><br>        *((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((address&gt;&gt;<span class="hljs-number">20</span>) &amp;<span class="hljs-number">0xffc</span>)))));<span class="hljs-comment">/* S1: ((address&gt;&gt;20) &amp;0xffc) 保留 DIR .</span><br><span class="hljs-comment">                                                          S2:  *DIR 取地址以后 就是某个page table .</span><br><span class="hljs-comment">                                                          S3:  0xfffff000 &amp; page table获得page table所存的地址,这个地址指向某个PAGE FRAME</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                                                         这两个为什么要加呢? 前者指的页表项的的偏移地址</span><br><span class="hljs-comment">                                                         后者指的是某个页表项的基地址</span><br><span class="hljs-comment">                                                         基地址+偏移地址 ,正好表示某个页表项</span><br><span class="hljs-comment">        整条命令等价于 ： up_wp_page(某个页表项具体地址)；</span><br><span class="hljs-comment">        */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="un-wp-page"><a href="#un-wp-page" class="headerlink" title="un_wp_page"></a>un_wp_page</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//un-write protect page  取消写保护，入参是某个页表项</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">un_wp_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> * table_entry)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> old_page,new_page;<br><br>    old_page = <span class="hljs-number">0xfffff000</span> &amp; *table_entry; <span class="hljs-comment">//去掉页表项属性</span><br>    <span class="hljs-comment">//页面不能写的状态有两种，占用or共享</span><br>    <span class="hljs-comment">//后者判断页面是否处于共享状态；== 1 则表示 未处于共享状态，但是处于占用状态</span><br>    <span class="hljs-keyword">if</span> (old_page &gt;= LOW_MEM &amp;&amp; mem_map[MAP_NR(old_page)]==<span class="hljs-number">1</span>) &#123;<br>        *table_entry |= <span class="hljs-number">2</span>;<span class="hljs-comment">// |2 取消写保护  r/w bit . 1 =w ; 0=r </span><br>        invalidate();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//处于共享状态，不能直接写入，如果写入会破坏原进程</span><br>    <span class="hljs-keyword">if</span> (!(new_page=get_free_page()))<span class="hljs-comment">//如果申请的新页面为空</span><br>        oom();<br>    <span class="hljs-keyword">if</span> (old_page &gt;= LOW_MEM)<span class="hljs-comment">//申请到new_page,判断old_page是否大于LOW_MEM</span><br>        mem_map[MAP_NR(old_page)]--;<span class="hljs-comment">//从2减1，取消共享标记</span><br>    *table_entry = new_page | <span class="hljs-number">7</span>; <span class="hljs-comment">// | 7 表示可读可写,让*table_entry指向new_page(物理页的地址)</span><br>    invalidate();<br>    copy_page(old_page,new_page);<span class="hljs-comment">// 将old_page复制给new_page</span><br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="write-verify"><a href="#write-verify" class="headerlink" title="write_verify"></a>write_verify</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">write_verify() : why need to verify .写页面之前做验证，目的是尝试是否可写</span><br><span class="hljs-comment">             in : linear address </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">write_verify</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page;<br><br>    <span class="hljs-keyword">if</span> (!( (page = *((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((address&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>)) )&amp;<span class="hljs-number">1</span>)) <span class="hljs-comment">// twice get value :  equal to ** (address &gt;&gt; 22)</span><br>        <span class="hljs-keyword">return</span>;<br>    page &amp;= <span class="hljs-number">0xfffff000</span>; <span class="hljs-comment">//去掉属性</span><br>    page += ((address&gt;&gt;<span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffc</span>);  <span class="hljs-comment">// page = page + address ( DIR | PAGE )</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-number">3</span> &amp; *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) page) == <span class="hljs-number">1</span>)  <span class="hljs-comment">/* non-writeable, present */</span>  <br>                                             <span class="hljs-comment">/* 3(dec) = 11(bin)   </span><br><span class="hljs-comment">                                                3 &amp; 1011 = 3;</span><br><span class="hljs-comment">                                                3 &amp; 1001 = 1;</span><br><span class="hljs-comment">                                                bit write/read , 0 non-writeable</span><br><span class="hljs-comment">                                            The Present bit indicates whether a page table</span><br><span class="hljs-comment">                                            entry can be used in address translation. </span><br><span class="hljs-comment">                                            P=1 indicates that the entry can be used.</span><br><span class="hljs-comment">                                             */</span><br>        un_wp_page((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) page);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="与pags-s-page-fault-相关的函数"><a href="#与pags-s-page-fault-相关的函数" class="headerlink" title="与pags.s:page_fault 相关的函数"></a>与pags.s:page_fault 相关的函数</h2><p>他们的调用关系是: do_no_page – share_page – try_to_share</p><h3 id="share-page"><a href="#share-page" class="headerlink" title="share_page"></a>share_page</h3><p>尝试寻找一个进程，可以与当前进程共享页面。address是期望共享页面的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * share_page() tries to find a process that could share a page with</span><br><span class="hljs-comment"> * the current one. Address is the address of the wanted page relative</span><br><span class="hljs-comment"> * to the current data space.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * We first check if it is at all feasible by checking executable-&gt;i_count.</span><br><span class="hljs-comment"> * It should be &gt;1 if there are other tasks sharing this inode.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">share_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> ** <span class="hljs-title">p</span>;</span>   <br><br>    <span class="hljs-keyword">if</span> (!current-&gt;executable)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (current-&gt;executable-&gt;i_count &lt; <span class="hljs-number">2</span>) <span class="hljs-comment">// ? </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) &#123;<br>        <span class="hljs-keyword">if</span> (!*p)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (current == *p)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> ((*p)-&gt;executable != current-&gt;executable)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (try_to_share(address,*p)) <span class="hljs-comment">// address 期望共享的页面地址；p某一个进程</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="try-to-share"><a href="#try-to-share" class="headerlink" title="try_to_share"></a>try_to_share</h3><p>将期望共享的页面共享给当前进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * try_to_share() checks the page at address &quot;address&quot; in the task &quot;p&quot;,</span><br><span class="hljs-comment"> * to see if it exists, and if it is clean. If so, share it with the current</span><br><span class="hljs-comment"> * task.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * NOTE! This assumes we have checked that p != current, and that they</span><br><span class="hljs-comment"> * share the same executable.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">try_to_share</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address, <span class="hljs-keyword">struct</span> task_struct * p)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> from_page;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> to_page;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> phys_addr;<br><br>    from_page = to_page = ((address&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>); <span class="hljs-comment">// DIR</span><br>    from_page += ((p-&gt;start_code&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);  <span class="hljs-comment">// 加上相对p进程的DIR</span><br>    to_page += ((current-&gt;start_code&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);<span class="hljs-comment">// 加上相对current进程的DIR</span><br><span class="hljs-comment">/* is there a page-directory at from? */</span><br>    from = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) from_page;  <span class="hljs-comment">//from(page table entry)</span><br>    <span class="hljs-keyword">if</span> (!(from &amp; <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    from &amp;= <span class="hljs-number">0xfffff000</span>;  <span class="hljs-comment">// 去掉属性</span><br>    from_page = from + ((address&gt;&gt;<span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffc</span>); <span class="hljs-comment">//得到相对进程p的page_table_entry</span><br>    phys_addr = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) from_page; <br><span class="hljs-comment">/* is the page clean and present? */</span><br>    <span class="hljs-keyword">if</span> ((phys_addr &amp; <span class="hljs-number">0x41</span>) != <span class="hljs-number">0x01</span>) <span class="hljs-comment">//0x41 对应表项中的Dirty和Present标志</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    phys_addr &amp;= <span class="hljs-number">0xfffff000</span>;<br>    <span class="hljs-keyword">if</span> (phys_addr &gt;= HIGH_MEMORY || phys_addr &lt; LOW_MEM)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    to = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) to_page; <br>    <span class="hljs-keyword">if</span> (!(to &amp; <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-keyword">if</span> ((to = get_free_page()))<br>            *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) to_page = to | <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">else</span><br>            oom();<br>    &#125;<br>    to &amp;= <span class="hljs-number">0xfffff000</span>;<br>    to_page = to + ((address&gt;&gt;<span class="hljs-number">10</span>) &amp; <span class="hljs-number">0xffc</span>)；<span class="hljs-comment">//得到相对进程current的page_table_entry</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> &amp; *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) to_page)<br>        panic(<span class="hljs-string">&quot;try_to_share: to_page already exists&quot;</span>);<br><span class="hljs-comment">/* share them: write-protect */</span><br>    *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) from_page &amp;= ~<span class="hljs-number">2</span>;  <span class="hljs-comment">// 设置写保护</span><br>    <span class="hljs-comment">// 共享，to_page 和from_page指向相同的物理页地址</span><br>    *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) to_page = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) from_page;<br>    invalidate();<br>    phys_addr -= LOW_MEM;<br>    phys_addr &gt;&gt;= <span class="hljs-number">12</span>;<br>    mem_map[phys_addr]++; <span class="hljs-comment">// 共享标记</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-no-page"><a href="#do-no-page" class="headerlink" title="do_no_page"></a>do_no_page</h3><p>此函数是在当进程运行时，内存分页不够用的时候，产生中断后调用此函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// @brief 这个是在当进程运行时,内存分页不够用的时候该做什么事情. </span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1. 进程动态申请内存页面 映射一页物理页</span><br><span class="hljs-comment">    2. 尝试与已加载的相同文件进行页面共享</span><br><span class="hljs-comment">    3. 从文件中读取所缺的数据页面到指定线性地址处</span><br><span class="hljs-comment">    当进程要使用内存页时,在线性地址空间寻找时,发现内存页不够了. 于是page_default调用do_no_page函数</span><br><span class="hljs-comment">    */</span><br><span class="hljs-comment">/// @param error_code </span><br><span class="hljs-comment">/// @param address  缺页的线性地址</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">do_no_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br>    <span class="hljs-type">int</span> nr[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tmp;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page;<br>    <span class="hljs-type">int</span> block,i;<br><br>    address &amp;= <span class="hljs-number">0xfffff000</span>;<br>    tmp = address - current-&gt;start_code; <span class="hljs-comment">// 进程线性地址空间对应偏移地址  . 从进程的start_code开始计算</span><br>    <span class="hljs-keyword">if</span> (!current-&gt;executable || tmp &gt;= current-&gt;end_data) &#123;<br>        get_empty_page(address);  <span class="hljs-comment">// no_page的处理方式1 , 获取一个free page 并且与address 建立映射. </span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (share_page(tmp)) <span class="hljs-comment">// no_page 的处理方式2  </span><br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!(page = get_free_page()))<br>        oom();<br><span class="hljs-comment">/* remember that 1 block is used for header */</span><br>    block = <span class="hljs-number">1</span> + tmp/BLOCK_SIZE;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">4</span> ; block++,i++)<br>        nr[i] = bmap(current-&gt;executable,block);<br>    bread_page(page,current-&gt;executable-&gt;i_dev,nr);<br>    i = tmp + <span class="hljs-number">4096</span> - current-&gt;end_data;<br>    tmp = page + <span class="hljs-number">4096</span>;<br>    <span class="hljs-keyword">while</span> (i-- &gt; <span class="hljs-number">0</span>) &#123;<br>        tmp--;<br>        *(<span class="hljs-type">char</span> *)tmp = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (put_page(share_page,address))<br>        <span class="hljs-keyword">return</span>;<br>    free_page(page);<br>    oom();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="get-empty-page-amp-put-page"><a href="#get-empty-page-amp-put-page" class="headerlink" title="get_empty_page &amp; put_page"></a>get_empty_page &amp; put_page</h2><h3 id="get-empty-page"><a href="#get-empty-page" class="headerlink" title="get_empty_page"></a>get_empty_page</h3><p>此函数让一个线性地址与空闲页建立映射，这个线性地址存在一个空页面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// @brief get free page and map to address </span><br><span class="hljs-comment">//  the difference between get_empty_page and get_free_page ?</span><br><span class="hljs-comment">//  get_free_page : not relative to linear addres </span><br><span class="hljs-comment">//  get_empty_page : map free page and linear address. this page called empty page.</span><br><span class="hljs-comment">/// @param address : if successed , param address map to empty page .</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">get_empty_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tmp;<br><br>    <span class="hljs-keyword">if</span> (!(tmp=get_free_page()) || !put_page(tmp,address)) &#123;<br>        free_page(tmp);        <span class="hljs-comment">/* 0 is ok - ignored */</span><br>        oom();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="put-page"><a href="#put-page" class="headerlink" title="put_page"></a>put_page</h3><p>此函数是让内存页面和想要的线性地址进行映射，建立关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This function puts a page in memory at the wanted address.</span><br><span class="hljs-comment"> * It returns the physical address of the page gotten, 0 if</span><br><span class="hljs-comment"> * out of memory (either when trying to access page-table or</span><br><span class="hljs-comment"> * page.)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 入参: page(4K)-- &gt; PAGE FRAME</span><br><span class="hljs-comment"> * 入参: address  linear address</span><br><span class="hljs-comment"> * put page to  linear address </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 总结:实际上这个函数表达的意思是, 用入参address得到的page基地址 映射到 入参page基地址</span><br><span class="hljs-comment"> *         也就是变更了线性地址中的某个页表所指向的PAGEFRAME </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 有几个问题 1. page_table 是数组吗？ 如果不是 怎么可以page_table[] 进行操作 ，如果是，unsigned long page_tables 不是定义数组 </span><br><span class="hljs-comment"> *             答 : 数组的本质是指针 , 所以指针可以用数组表示,他们可以互相表示.</span><br><span class="hljs-comment"> * 2. page_table是局部变量 ,这样的映射是否有效,在函数之外?</span><br><span class="hljs-comment"> *             答 : 其实实际上操作的是内存中的值, 所以在函数之外是有效的. 对dir;page_table;pageframe操作,这些都是在内存中.</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">put_page</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> page,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span> <br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> tmp, *page_table;<br><br><span class="hljs-comment">/* NOTE !!! This uses the fact that _pg_dir=0 */</span><br><br>    <span class="hljs-keyword">if</span> (page &lt; LOW_MEM || page &gt;= HIGH_MEMORY)  <span class="hljs-comment">// page variable is page table or page entry ? page pointer ? page </span><br>        printk(<span class="hljs-string">&quot;Trying to put page %p at %p\n&quot;</span>,page,address);<br>    <span class="hljs-keyword">if</span> (mem_map[(page-LOW_MEM)&gt;&gt;<span class="hljs-number">12</span>] != <span class="hljs-number">1</span>) <br>        printk(<span class="hljs-string">&quot;mem_map disagrees with %p at %p\n&quot;</span>,page,address);<br>    page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) ((address&gt;&gt;<span class="hljs-number">20</span>) &amp; <span class="hljs-number">0xffc</span>);  <span class="hljs-comment">// 目录项偏移地址, 前面变量名应该为dir才对</span><br>    <span class="hljs-comment">// (address&gt;&gt;20) &amp; 0xffc: extract DIR(10bits) of LINER ADDRESS </span><br>    <span class="hljs-comment">//  0xffc = 1111 1111 1100 . 所以这里是为了mask掉最后 2bits.</span><br>    <span class="hljs-keyword">if</span> ((*page_table)&amp;<span class="hljs-number">1</span>) <span class="hljs-comment">//指向pagetable的DIR 是否有效</span><br>        page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) (<span class="hljs-number">0xfffff000</span> &amp; *page_table); <span class="hljs-comment">// 接上面  (unsigned long *) (0xfffff000 &amp; *dir) </span><br>                                                                   <span class="hljs-comment">//  *dir 等价于page_table </span><br>                                                                   <span class="hljs-comment">//  0xfffff000 &amp; page_table  只保留page table 中的frame page address,也就是指向某个page frame</span><br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果无效</span><br>        <span class="hljs-keyword">if</span> (!(tmp=get_free_page()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        *page_table = tmp|<span class="hljs-number">7</span>;<br>        page_table = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *) tmp;<br>    &#125;<br>    page_table[(address&gt;&gt;<span class="hljs-number">12</span>) &amp; <span class="hljs-number">0x3ff</span>] = page | <span class="hljs-number">7</span>;   <span class="hljs-comment">/* </span><br><span class="hljs-comment">                                                    address &gt;&gt; 12  保留DIR|PAGE| ; OFFSET 被移出</span><br><span class="hljs-comment">                                                    0x3ff = 0011 1111 1111   </span><br><span class="hljs-comment">                                                    (address&gt;&gt;12) &amp; 0x3ff : 保留10bits , 其他mask , get PAGE(10bits) </span><br><span class="hljs-comment">                                                    page_table[(address&gt;&gt;12) &amp; 0x3ff] 等价于 page_table[PAGE] ,</span><br><span class="hljs-comment">                                                    等价于page_table的基地址+偏移地址PAGE 可以计算得到一个page frame的起始地址</span><br><span class="hljs-comment">                                                    总结:实际上这个函数表达的意思是, 用入参address得到的page基地址 映射到 入参page基地址</span><br><span class="hljs-comment">                                                    也就是变更了线性地址中的某个页表所指向的PAGEFRAME </span><br><span class="hljs-comment">                                                    */</span>                        <br><span class="hljs-comment">/* no need for invalidate */</span><br>    <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="附：内存寻址全局图"><a href="#附：内存寻址全局图" class="headerlink" title="附：内存寻址全局图"></a>附：内存寻址全局图</h1><p><img src="/../img/Linux-0-11-MMU-Code-Reading-Record/Linux0.11-mm%2080306%20Addressing%20Machanism-Page-1.jpg"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.oldlinux.org/download/clk011c-3.0.pdf">Linux 内核完全注释</a></p><p><a href="https://weread.qq.com/web/bookReview/list?bookId=eb432a1059346feb43178b3">Linux 内核设计的艺术</a></p><p><a href="https://zhuanlan.zhihu.com/p/67714693?utm_id=0">segmentation和保护模式（二）</a></p><p><a href="https://juejin.cn/post/7084117128508342302">深入理解Linux内核虚拟内存原理与实现 - 掘金</a></p><p><a href="https://juejin.cn/post/6976168717142982693">【Linux 0.11】第十三章 内存管理 - 掘金</a></p><p><a href="https://datasheetspdf.com/datasheet/I386.html">I386 Datasheet | Intel - Datasheetspdf.com</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>MMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 0.11 内存管理-寻址 Linux 0.11 MMU Addressing Machanism</title>
    <link href="/2023/11/23/Linux-0-11-MMU-Addressing-Machanism/"/>
    <url>/2023/11/23/Linux-0-11-MMU-Addressing-Machanism/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-0-11-内存管理-寻址-Linux-0-11-MMU-Addressing-Machanism"><a href="#Linux-0-11-内存管理-寻址-Linux-0-11-MMU-Addressing-Machanism" class="headerlink" title="Linux 0.11 内存管理-寻址 Linux 0.11 MMU Addressing Machanism"></a>Linux 0.11 内存管理-寻址 Linux 0.11 MMU Addressing Machanism</h1><p>什么是内存管理? <strong>内存管理</strong>，是指<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6" title="软件">软件</a>运行时对计算机<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" title="内存">内存</a>资源的分配和使用的技术。其最主要的目的是如何高效、快速的分配，并且在适当的时候释放和回收内存资源。</p><p>在此之下还有一个关键基础内容需要了解，也就是<strong>寻址</strong></p><p><del>寻址, 是指计算机处理器通过某种特定的规则访问内存或存储器中的数据.</del></p><p>在操作系统中，”寻址”通常指的是处理器或CPU（中央处理器）计算有效地址的过程。以便内存管理或其他程序从内存中读取或写入数据。</p><p>在Linux0.11中, 内存做了分段和分页处理, 由此形成了两种不同的寻址方式.</p><p>下面我会花大量篇幅先把这两种的寻址原理介绍清楚。</p><p>下一期再介绍MMU(Memory Management Unit)。</p><h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>当程序需要访问内存时，操作系统负责将虚拟地址转换为物理地址，这个过程称为地址寻址。通过地址寻址，操作系统能够确保不同程序或进程的内存空间相互隔离，并为每个程序提供独立的虚拟地址空间。这有助于提高系统的安全性和稳定性，同时允许程序使用比实际物理内存更大的虚拟内存空间。</p><p>寻址相当于是程序的访问内存的遵循的规则，程序遵循这个规律，才能正确访问内存。</p><p>用函数表示逻辑地址到物理地址的关系, 见下方</p><p>                                            内存的物理地址&#x3D;f(逻辑地址)</p><p>f(x)在这里是一个寻址规则, 这个规则也称作变换.</p><p>操作系统中一次完整的寻址, 经过段变换(Segment Translation)和页变换(Page Translation). 两种变换的示意图如下 </p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-23-21-24-05-image.png"></p><p>段变换(Segment Translation): 将逻辑地址（虚拟地址）变换为线性地址，如果没有开启分页机制，则变换为物理地址。</p><p>页变换(Page Translation) : 将线性地址变换为物理地址</p><p>一个逻辑地址(LOGICAL ADDRESS)通过一次完整的寻址经过两次变换段变换和页变换. 如果页变换没有开启, 则线性地址(LINEAR ADDRESS)经过段变换的地址直接映射到物理地址(PHYSICAL ADDRESS).</p><p>所以可以总结, 寻址情况有两种</p><ol><li><p>经过一次段变换后实现寻址</p></li><li><p>经过段变换和页变换后实现寻址</p></li></ol><h2 id="段变换寻址"><a href="#段变换寻址" class="headerlink" title="段变换寻址"></a>段变换寻址</h2><p>段变换寻址也称在保护模式下寻址。</p><p>内存是分段的，通过一种机制如何寻址到某一个内存段。</p><h3 id="理论模型呈现"><a href="#理论模型呈现" class="headerlink" title="理论模型呈现"></a>理论模型呈现</h3><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-26-11-56-07-image.png"></p><p>在段变换中, 逻辑地址中选择子(Selector)会指向描述符表(Descriptor Table)的段描述符(Segment Descriptor), 再根据段描述符中记录的基地址与逻辑地址的偏移值(OFFSET)来得到新的地址. </p><p>如果分页机制没有开启, 那么新的地址就是得到物理地址. 否则, 得到的新地址是一个线性地址, 需经过页变换才能得到物理地址. 所述如下图</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-14-16-01-08-image.png"></p><p>这里有几个概念需要澄清一下</p><p>描述符表(Descriptor Table), 是一个数据结构里面设置了多个描述符组成的表单,通常是GDT或者LDT. </p><p>选择子(Selector), 是用于指向描述符表中某一个描述符，其实也是一个偏移值， 所以称作选择子. GDTR 确定了基地址, Selector 确定了偏移值。确定GDT中的某一个描述符。</p><p>段描述符(Segment Descriptor), 用于指向一段已经划分好的内存基地址, 并且还描述了这个内存段的限长等其他信息. </p><p>总之，这里的Selector是GDT的一个偏移值，OFFSET线性地址段的偏移值。所以逻辑地址（Logical address)的构成是两个偏移地址的组合（selector, offset)。</p><p>最终还是符合一个寻址原则：基地址+偏移地址，并且由前一个地址推导出后面一个地址。</p><h3 id="代码呈现"><a href="#代码呈现" class="headerlink" title="代码呈现"></a>代码呈现</h3><p>根据上面的一段论述, 现在已经确认好了模型</p><p>再来看看代码中是如何实现的?</p><p>代码在<strong>Setup.s</strong>中体现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">end_move:<br>    mov    $SETUPSEG, %ax    <span class="hljs-meta"># right, forgot this at first. didn<span class="hljs-string">&#x27;t work :-)</span></span><br><span class="hljs-string"><span class="hljs-meta">    mov    %ax, %ds</span></span><br><span class="hljs-string"><span class="hljs-meta">    lidt    idt_48        # load idt with 0,0</span></span><br><span class="hljs-string"><span class="hljs-meta">    lgdt    gdt_48        # load gdt with whatever appropriate</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">gdt_48:<br>    .word    <span class="hljs-number">0x800</span>            <span class="hljs-meta"># gdt limit=2048, 256 GDT entries</span><br>    .word   <span class="hljs-number">512</span>+gdt, <span class="hljs-number">0x9</span>      <span class="hljs-meta"># gdt base = 0X9xxxx, </span><br>    # <span class="hljs-number">512</span>+gdt is the real gdt after setup is moved to <span class="hljs-number">0x9020</span> * <span class="hljs-number">0x10</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">gdt:<br>    .word    <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>        <span class="hljs-meta"># dummy</span><br><br>    .word    <span class="hljs-number">0x07FF</span>        # <span class="hljs-number">8</span>Mb - limit=<span class="hljs-number">2047</span> (<span class="hljs-number">2048</span>*<span class="hljs-number">4096</span>=<span class="hljs-number">8</span>Mb)<br>    .word    <span class="hljs-number">0x0000</span>        <span class="hljs-meta"># base address=0</span><br>    .word    <span class="hljs-number">0x9A00</span>        <span class="hljs-meta"># code read/exec</span><br>    .word    <span class="hljs-number">0x00C0</span>        <span class="hljs-meta"># granularity=4096, 386</span><br><br>    .word    <span class="hljs-number">0x07FF</span>        # <span class="hljs-number">8</span>Mb - limit=<span class="hljs-number">2047</span> (<span class="hljs-number">2048</span>*<span class="hljs-number">4096</span>=<span class="hljs-number">8</span>Mb)<br>    .word    <span class="hljs-number">0x0000</span>        <span class="hljs-meta"># base address=0</span><br>    .word    <span class="hljs-number">0x9200</span>        <span class="hljs-meta"># data read/write</span><br>    .word    <span class="hljs-number">0x00C0</span>        <span class="hljs-meta"># granularity=4096, 386</span><br></code></pre></td></tr></table></figure><p>上方的几段代码执行后, 完成了工作如下图所示</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-24-13-26-46-image.png"></p><p>lgdt命令将gdt_48 的数据结构加载到GDTR中, GDTR是一个位于CPU内的寄存器。 48bit 和 数据结构是取决于GDTR的大小和结构. ( 数据结构为 32bit 基地址 | 16bit 段限长。)  限长设置0x800 . </p><p>GDT中包含 256 GDT entries, 但是只是用了3个entries .  第一项 为 空 ； 第二项为 code ; 第三项为data。</p><p>gdt 变量是一个地址。512+gdt 是移动后的gdt基地址. </p><p>在完成上述的初始化配置后, CPU的寻址过程就是 通过读取GDTR的高32bit找到GDT, 根据GDT中的描述符GD entry 的基地址找到对应的内存段, 在结合offset偏移值, 最后获取到数据. 如下图所示.</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-12-19-08-image.png"></p><p>Segment Descriptor 段描述符是一个64bit数据结构的描述符，数据结构定义如下</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-14-16-24-19-image.png"></p><h3 id="为什么需要段机制-保护模式"><a href="#为什么需要段机制-保护模式" class="headerlink" title="为什么需要段机制(保护模式)?"></a>为什么需要段机制(保护模式)?</h3><p><strong>实模式寻址VS保护模式寻址</strong></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-05-30-11-09-43-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-05-30-11-09-56-image.png"></p><p>从上方描述，“索引值”包含 内存段的基地址 ，段的最大长度值和段的访问级别。因为有这几个参数，内存访问都遵循着这个规律，所以保护了其他的内存段，程序访问时不会超过其他内存边界，不会影响到其他的内存。另外还有访问时的权限，说明只有特定的程序访问特定的内存段，所以也起到了保护作用。</p><p>保护模式寻址 需要通过一个段描述符(设置了寻址的属性)，作为映射到物理地址的一个中间手续。</p><p>举一个不恰当的例子。就像用户作为CPU，要想存钱和取钱需要经过银行柜台的认证和许可才可以取钱。这里的银行柜台就是中间手续.</p><p>银行柜台能够对银行中的钱起到保护作用；相当于描述符能够对内存起到保护作用。</p><p>银行柜台会告诉你不同身份的用户可以存取多少钱，也就是描述符会告诉你内存段的限长。银行柜台再你取钱时会确定你的身份信息, 如果另外一个人来取钱，肯定是不允许的。对于不同身份不同级别的程序，对内存的操作权限也是不同的。</p><p>相对于实模式，连银行柜台都没有，可以直接获取金库的钱。所以这很不安全。</p><h2 id="页变换寻址"><a href="#页变换寻址" class="headerlink" title="页变换寻址"></a>页变换寻址</h2><h3 id="为什么需要分页机制"><a href="#为什么需要分页机制" class="headerlink" title="为什么需要分页机制?"></a>为什么需要分页机制?</h3><p>我们看到，分段管理机制已经提供了很好的保护机制，那为什么还要加上分页管理机制呢？其实它的主要目的在于实现虚拟存储器（虚拟内存）。线性地址中任意一个页都能映射到物理地址中的任何一个页，这无疑使得内存管理变得相当灵活。</p><p>虚拟内存允许程序使用比实际物理内存更大的内存空间，同时具有以下特点：</p><ol><li>虚拟内存空间的大小可以超出物理内存空间大小。</li><li>通过操作系统的管理和调用，虚拟内存和物理内存之间的映射关系可以变化。</li></ol><p>因此，虚拟内存提供了一种灵活的内存管理方式，使得不同的进程之间彼此独立，使得某一个进程在执行时看起来拥有独立的地址空间，避免了不同进程的地址冲突问题。而线性地址空间则是实现虚拟内存机制的方式，它为程序提供了一种连续的地址空间，使得程序看起来具有独立的地址空间，与其他的程序和操作系统本身隔离开来。</p><h3 id="理论模型呈现-1"><a href="#理论模型呈现-1" class="headerlink" title="理论模型呈现"></a>理论模型呈现</h3><p>页变换是将线性地址转化为物理地址，将线性地址空间转化为物理地址空间</p><p> 线性地址来源是由逻辑地址经过段变换后得到的</p><p>一个线性地址组成 如下 </p><p>DIR | PAGE | OFFSET </p><p>DIR 包含页目录表项(PDT entry)的地址，也就是页目录表的偏移地址</p><p>PAGE 包含页表项(PT entry)的地址，也就是页表的偏移地址</p><p>OFFSET 包含内存页(4K)的偏移地址</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-23-22-04-45-image.png"></p><p>这张图表示如何通过线性地址寻址到物理地址的. 首先将线性地址拆分成三块分别是DIR, PAGE, OFFSET. </p><p>CR3是属于CPU中的寄存器包含着某个页目录表(PDT)的基地址, 而DIR则可以进一步地确认PDT中具体使用到哪个页目录项(PD entry)</p><p>页目录项(PD entry)包含着某个页表的基地址, 而线性地址中的PAGE则可以进一步地确定具体是哪个页表项</p><p>页表项中包含着某个内存分页（PAGE FRAME或者称为页帧）的基地址, 而OFFSET偏移值则可以进一步地确定内存分页中具体的内存地址.</p><p>总的来看, 不管是段变换还是页变换，寻址依旧是遵守一个原则就是, 基地址+ 偏移值，并且由前面一个推导出后面一个。</p><h3 id="代码呈现-1"><a href="#代码呈现-1" class="headerlink" title="代码呈现"></a>代码呈现</h3><p>说完了分页机制寻址模型, 接下来看看代码是如何实现的</p><p>关于分页的工作主要在代码文件head.s中, 整个代码文件主要完成的工作有:</p><p><strong>head.s</strong>做了什么工作</p><ol><li><p>从这里开始,内核完全都是在保护模式下运行了</p></li><li><p>加载各个数据段寄存器,重新设置中断描述符表 idt</p></li><li><p>然后重新设置全局描述符表 gdt</p></li><li><p>设置管理内存的分页处理机制</p></li><li><p>紧随后面放置共可寻址 16MB 内存的 4 个页表,并分别设置它们的表项</p></li></ol><p>从以上来看, 与分页机制相关的工作是3,4,5几个步骤. 工作内容3其实已经在分段机制阶段说明了, 不再赘述. 4和5工作内容详细展开来讲讲. 下面关于页变换实现的步骤陈述如下</p><p>第一步: 页目录表和页表初始化</p><p>为1个页目录表和 4 个页表（为了能够索引 16MB 内存空间）在内核中申请空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nasm">....<br>pg_dir:<br>....<br>/*<br> * I put the kernel page tables right after the page directory,<br> * using 4 of them to span 16 Mb of physical memory. People with<br> * more than 16MB will have to expand this.<br> */<br>.org 0x1000<br>pg0:<br><br>.org 0x2000<br>pg1:<br><br>.org 0x3000<br>pg2:<br><br>.org 0x4000<br>pg3:<br><br>.org 0x5000<br></code></pre></td></tr></table></figure><p>第二步: 清空页目录表和 4 个页表的内容。如代码 201~204 行所示</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-15-41-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-16-17-image.png"></p><p>第三步: 设置页目录表项映射4个页表</p><p>内核中我们设置了4个页表, 所以我们需要在页目录表中设置4个页目录项来索引它们. 如代码205 ~ 208 行所示. 第一个页表所在的线性地址为0x1000, 赋予第一个页表的属性为0x7, 表示该页存在, 可读可写. 由于每个页目录项大小为4B, 故pg_dir+4可以跳转到下一个页目录项.</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-20-38-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-51-08-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-52-44-image.png"></p><p>第四步: 对页表中的每项映射内存分页地址</p><p>设置每个页表中的页表项。每个页表大小为 4*1024B（标识物理页号范围：0-0xfff），如代码 209~214 行所示。<code>pg3+4092</code> 表示从最后一页的最后一个页表项开始填起，填写的内容为<strong>该页表项所映射的物理内存页号以及该页的属性0x7</strong>，将循环判断变量 eax 减去 4K，继续设置下一页表项，直至零，表示已将 4096 个页表项填写完毕，即 16M 内存分页完毕。<img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-56-14-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-59-32-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-59-52-image.png"></p><p>第五步: 设置CR3映射到页目录表和设置CR0开启分页机制</p><p>设置页目录表的起始地址. 将页目录表起始地址赋予CR3寄存器, 如代码216-217行所示. 开启分页机制. 如代码218 - 221 行所示, 将CR0寄存器的最高位设置为1来开启分页机制.</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-18-01-29-image.png"></p><p>总结：经过以上几个步骤之后，配置好了以下几个方面：<br>1.CR3指向页目录表<br>2.页目录表中的页目录项指向4个页表<br>3.页表中的页表项指向内存寻址空间（以4K分隔）  </p><h1 id="运行和调试"><a href="#运行和调试" class="headerlink" title="运行和调试"></a>运行和调试</h1><h2 id="线性地址到物理地址"><a href="#线性地址到物理地址" class="headerlink" title="线性地址到物理地址"></a>线性地址到物理地址</h2><p>在分页模式下，线性地址到物理地址的过程会涉及：</p><p>CR3 – Page DIR – Page DIR Entry – Page Table – Page Table Entry – Frame Page (physical address)</p><p>主要是想查看相关变量和寄存器，看下是否符合理论并且能够加深理解</p><p>通过Bochs 虚拟机，并输入相关指令可以查看寄存器和变量</p><ol><li><p>查看CR3寄存器</p><p>CR3寄存器中设置了页目录的基地址</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-16-19-38-11-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-16-19-37-44-image.png"></p><ol start="2"><li><p>查看Page DIR</p><p>按照理论，CR3的寄存器地址就是Page DIR</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-16-19-47-42-image.png"></p><p>通过上图的指令，可以查看几个页目录表的地址内容。从代码里面可以看到主要设置了4个页目录表。基本上与上方的显示结果对应。</p><p>第一个Page DIR ： 0x1027   &#x3D; 0x1000 + 0x27 </p><p>0x1000是Page Table的地址， 0x27 是关于设置页的属性。</p></li><li><p>查看Page Table</p><p>通过相同的方法查看内存地址0x1000得到的值是0x800000.这正好是一个FRAME PAGE的地址。内存寻址空间的最大在0xFFFFFF</p></li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>通过调试查看线性地址到物理地址寻址过程相关的地址。对代码有了 更深的理解。回顾一下线性地址组成</p><p>                                            DIR | PAGE | OFFSET</p><p>LINEAR ADDRESS: 0x0(+DIR) – 0x1000(+PAGE) – 0x800000(+offset)<br>假设线性地址的偏移地址都是零，用（0，0，0）来表示。所以这个线性地址得到的最终物理地址是0x800000。</p><p>如果线性地址LINEAR ADDRESS: (1,14,25)，那么最终计算结果也就前一个地址加上该位置的偏移地址后，最终推导出物理地址。而线性地址中的每一位其实是与之相对应容器的偏移值。DIR是PAGE DIR的偏移值；PAGE是PAGE TABLE的偏移值; OFFSET是FRAME PAGE的偏移值。</p></li></ol><h2 id="逻辑地址（虚拟地址）到线性地址"><a href="#逻辑地址（虚拟地址）到线性地址" class="headerlink" title="逻辑地址（虚拟地址）到线性地址"></a>逻辑地址（虚拟地址）到线性地址</h2><p>在分段模式下，逻辑地址到线性地址的过程会涉及：</p><p>GDTR – Descriptor Table – Segment Descriptor – 线性地址</p><ol><li><p>查看GDTR </p><p>在bochs中输入sreg可以查看到gdtr保存的地址, 这个0x5cb8就是指向Descriptor Table的地址</p></li></ol><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-17-22-05-03-image.png"></p><ol start="2"><li><p>查看Descriptor Table与Segment Descriptor</p><p>通过x查看某内存地址的值. 0x5cb8是gdt的基地址, +8 可以查看下一个Descriptor , 一次查看几个Descriptors, 验证一下是否与书上, 代码上的是否一致. </p><p>移动后的GDT,如下图所示：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-20-21-10-23-image.png"></p></li></ol><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-21-22-19-06-info%20gdt.png"></p><p>查看相同地址，在bochs下的显示结果：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-20-21-31-14-image.png"></p><p>查看相同地址，在qemu下的显示结果：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-17-22-22-12-image.png"></p><p>查看理论上移动后的GDT基地址：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-17-22-16-17-image.png"></p><p>分段寻址参考：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/segment-ma.jpg"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><p>因为Segment descriptor的数据结构是64bit(8B), 所以base+8可以找到下一个descriptor</p></li><li><p>通过qemu和bochs打印的descriptor会不一样，但是和理论的大差不差。</p></li><li><p>descriptor最后寻址到的是线性地址。如果没有开启分页模式那实际上就是物理地址。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.oldlinux.org/download/clk011c-3.0.pdf">Linux  内核完全注释</a></p><p><a href="https://weread.qq.com/web/bookReview/list?bookId=eb432a1059346feb43178b3">Linux 内核设计的艺术</a></p><p><a href="https://zhuanlan.zhihu.com/p/67714693?utm_id=0">segmentation和保护模式（二）</a></p><p><a href="https://juejin.cn/post/7084117128508342302">深入理解Linux内核虚拟内存原理与实现 - 掘金</a></p><p><a href="https://juejin.cn/post/6976168717142982693">【Linux 0.11】第十三章 内存管理 - 掘金</a></p><p><a href="https://datasheetspdf.com/datasheet/I386.html">I386 Datasheet | Intel - Datasheetspdf.com</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>MMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC: openharmony与android有多相似/IPC: how similar between openharmony and android</title>
    <link href="/2022/07/09/IPC-how-similar-between-openharmony-and-android/"/>
    <url>/2022/07/09/IPC-how-similar-between-openharmony-and-android/</url>
    
    <content type="html"><![CDATA[<h1 id="IPC-openharmony与android有多相似-x2F-IPC-how-similar-between-openharmony-and-android"><a href="#IPC-openharmony与android有多相似-x2F-IPC-how-similar-between-openharmony-and-android" class="headerlink" title="IPC: openharmony与android有多相似&#x2F;IPC: how similar between openharmony and android"></a>IPC: openharmony与android有多相似&#x2F;IPC: how similar between openharmony and android</h1><p>通过本篇文章 你会发现 在IPC这块的代码和架构设计 . openharmony（以下简称oh）与android 有相当大程度的相似性</p><p>可能有人会认为oh是在抄袭android, 所以给予oh负面的评价.</p><p>本篇的主要目的 不是为了贬低oh或者国人os, 只是从技术角度展示oh的真实情况. 至于什么样的评价,取决于其他人加入了什么样的想法.</p><p>科学技术代表智慧, 智慧没有国界 更没有界限 , 都是人类智慧的结晶</p><p>好了开始正文</p><h2 id="IPC-介绍"><a href="#IPC-介绍" class="headerlink" title="IPC 介绍"></a>IPC 介绍</h2><p>Binder-IPC 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。<br>从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。</p><h2 id="工作逻辑"><a href="#工作逻辑" class="headerlink" title="工作逻辑"></a>工作逻辑</h2><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/workcircle.png" alt="IPC-binder工作流程"></p><ol><li>以上这种工作逻辑来源于android的分析资料, 通过阅读oh的代码后,发现这张图也同样适用.</li></ol><h2 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a>架构方面</h2><p><strong>android</strong></p><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/arch-android.png" alt="android-binder 架构"></p><p><strong>openharmony</strong></p><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/arch-oh.png" alt="oh-binder 架构"></p><ol><li>以oh3.1为例,整理了oh-IPC的类关系图,再经过整理、删减，可以发现类的关系架构图能够和android的相对应.</li></ol><h2 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面"></a>代码方面</h2><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/stack.jpg" alt="层级关系"></p><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/code.jpg" alt="代码对比"></p><ol><li>android-IPC中的IPCThreadState与oh-IPC的BinderInvoker存在对应关系</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>以上对比了openharmony与android的架构,层级,工作逻辑还有代码. 他们基本上是差不多的. 可以说在以上展示的代码片段中, 基本一样，只是换掉了不同的名称</li><li>要说为什么要这样. 这个取决于他们都选用了同一个IPC-binder的通信框架. 技术框架一旦确定，整体方面一般不会发生变化。最多修改的是一些枝叶</li><li>在项目和产品开发中，技术选型至关重要。一旦确定后，后面的开发工作都是会围绕和基于这个选型展开</li><li>对于openharmony的评价，虽然上面有很多android 的影子，但是oh自身具备了一些android不具备的功能和特点. 例如HDF驱动框架</li><li>binder原本是一个开源项目, 不能将binder与某种操作系统绑定起来。只是这两种操作系统都采用了binder-IPC方式</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>书名：深入解析Android 5.0系统 作者：刘超 </li><li>书名：Android的设计与实现：卷Ⅰ 作者：杨云君</li><li><a href="https://gitee.com/openharmony/communication_ipc?_from=gitee_search">openharmony ipc</a></li><li><a href="http://gityuan.com/2015/10/31/binder-prepare/">Binder系列—开篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>团队周例会开展心得 comprehension of team weekly report</title>
    <link href="/2022/07/03/comprehension-of-team-weekly-report/"/>
    <url>/2022/07/03/comprehension-of-team-weekly-report/</url>
    
    <content type="html"><![CDATA[<h1 id="团队周例会开展心得-comprehension-of-team-weekly-report"><a href="#团队周例会开展心得-comprehension-of-team-weekly-report" class="headerlink" title="团队周例会开展心得 comprehension of team weekly report"></a>团队周例会开展心得 comprehension of team weekly report</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>亲身经历,目前所在公司,几千人下的一个十几人的团队中<br>每次周例会将要长达1个小时多<br>每个人对自己做的事情做一些描述,基本这样就结束了<br>大多数人多是在做流水账<br>团队leader给出一些点评和建议这样就结束了<br>而且每周都是这样<br>周例会开得不痛不痒<br>团队的效率和协作潜力根本没有激发出来<br>这样的团队怎么能够帮助公司保质保量的完成项目?</p><h2 id="这种周例会方式是有问题的"><a href="#这种周例会方式是有问题的" class="headerlink" title="这种周例会方式是有问题的"></a>这种周例会方式是有问题的</h2><p>目前的周例会方式,存在一些问题：</p><ol><li>没有将团队目标和团队计划传达到团队中的每一个人. 有的团队管理方式,可能只有团队leader自己知道目标和计划,但是没有传达到其他成员上去。导致每周开始行动之前,每位团队成员没有各自的每周目标,而且没有计划。我们团队leader也不会有要求。先说如果团队目标没有传达到每一个团队成员上并且和大家达成共识,如何凝聚团队的心呢?团队的力量一定是分散的.</li><li>在以上这种情况下,团队leader委派任务也没有时间要求,只是说这块由谁来做,给出了单单从leader角度一个任务分配责任人表就完事了. 没有和团队成员确认,是否适合做这件事情.有些团队成员脾气好一点可能直接就答应了, 不敢有其他意见. 但是内心还是有想要去做他感兴趣的事情. 在工作中和一位同事交流后才知道, 他更想做偏图像方面的开发.但是他目前在做的是系统的其他模块, 但是却没有敢和团队leader提.</li><li>团队成员大多在周报上写下的内容, 都是本周做了什么的一个描述, 流水账式的. 没有体现本周是否达成了目标, 或者获得了什么进展.或者遇到了哪些困难, 哪些风险(没有目标和计划的话,风险就无从谈起)。</li><li>没有人提建议。没有对团队中所做的事情,对达到目标偏差所造成的原因进行分析,从而做改进.</li></ol><p>周例会只是冰山一角。从周例会的一些问题来看,团队的效率不高,没有发挥团队协作的潜力.<br>从而带来的就是团队成员经常性的加班,而且那些效率高的人还要陪着效率低的人一起加班.<br>因为效率不高,公司还觉得一些员工在混加班费的…</p><h2 id="对于这些团队协作上的苦涩-整理了一些自己的看法-心得和建议"><a href="#对于这些团队协作上的苦涩-整理了一些自己的看法-心得和建议" class="headerlink" title="对于这些团队协作上的苦涩,整理了一些自己的看法,心得和建议"></a>对于这些团队协作上的苦涩,整理了一些自己的看法,心得和建议</h2><ol><li>在团队开始行动之前，需要和团队成员们对团队目标达成共识（认识到目标的意义）。需要组织一个团队会议去陈述这个目标。在会议开始之前，团队leader应该有一个自己的初步规划。任务的划分，每个子任务的责任人，时间计划等等。</li><li>团队leader委派任务和团队成员需要相互确认。确认是否有什么大的问题，如果没有特别严重的问题，团队成员接收任务之后，对任务做工作量评估，将评估结果反馈给团队leader。团队leader来看这件事情是否在团队计划内.</li><li>团队成员对任务规划自己的每周目标。下次在周例会上便可反馈是否达到了本周目标，如果没有困难，就可以反馈出来，然后就可以知道，在执行过程中，需要什么支持，依赖什么资源，需要谁的帮助。这样团队才能相互协作起来，发挥团队的协作效率，1+1&gt;2。</li><li>通过协作工具，发挥团队协作潜力。团队成员中每个人的擅长点、模块学习的累积和团队成员的每周目标应该体现在团队协作表格上，大家都能够看到的。这样团队成员就可以知道其他人在做哪些事情，擅长什么，团队下运行的过程中，成员们自己可以找相应的人寻求帮助，不用等着团队leader来协调资源。否则，没有协作的团队，一件事情每个人都要重新学习一边，一个问题对于新入手的人来说可能需要一天，对于擅长的人来说，只用10分钟就可以搞定。</li><li>一个成熟的团队不是一天两天，也不是一周两周建设起来的，需要不断的修正和打磨。团队需要在周例会上对本周的工作进行回顾和总结。对于达成目标的进行鼓励。对于，未达成目标的，分析原因，做出调整。团队或团队成员为什么没有达到目标，原因是什么，我们应该做什么调整。团队成员首先可以从自己着手的事情来提出可以调整的行动方针。<br>举个例子，我本周没有达到目标的原因是因为，处理一个系统上的问题，这个问题一直跟踪到了内核上，内核这块虽然不是我擅长的，但是我想自己搞定，结果花费了太多时间，没想到搞定这个问题之后，还会有其他内核问题。如果我能够求助其他队友，他应该就能很快能够搞定。所以，可以总结，我的下次行动建议是，如果遇到我一个不熟悉的领域，并且已经花费了少部分时间也没有搞定，这个时候应该求助于其他人。<br>这样的团队总结不是一个批斗会，而是帮助团队优化，促使每位团队成员一起成长的方法。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>team</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Lifecycle</title>
    <link href="/2022/06/26/OS-Lifecycle/"/>
    <url>/2022/06/26/OS-Lifecycle/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-Lifecycle-x2F-OS-生命周期"><a href="#OS-Lifecycle-x2F-OS-生命周期" class="headerlink" title="OS Lifecycle &#x2F; OS 生命周期"></a>OS Lifecycle &#x2F; OS 生命周期</h1><p><img src="/../img/OS-Lifecycle/OS-lifecycle-Page-1.jpg" alt="OS Lifecycle"></p><p><strong>操作系统生命周期 主要包含几个阶段</strong></p><p>简单描述</p><ul><li><p>重生&#x2F;Reborn :  描述一个操作系统是如何诞生的.通过用户的反馈,功能增加,性能优化,BUG修复等,不断迭代出更加完善的操作系统.</p></li><li><p>部署&#x2F;Deployment : 描述操作系统软件是如何被部署安装在不同的硬件机器上.</p></li><li><p>维护&#x2F;Maintenance : 描述OS操作系统在使用的过程中,后端工程师是如何维护和持续提升操作系统的.</p></li><li><p>优化&#x2F;Optimize : 描述OS操作系统如何通过维护方法得到优化的.</p></li></ul><p>他们是一个周期循环,是一个整体</p><h2 id="重生-x2F-Reborn"><a href="#重生-x2F-Reborn" class="headerlink" title="重生&#x2F;Reborn"></a>重生&#x2F;Reborn</h2><ol><li>一个OS镜像的组成.通常是bootloader,kernel,rootfs,oem(apps,license,repo等)组成</li><li>通过镜像制作工具(例如mkiso)可生成.img或者.iso等镜像文件</li><li>bootloader对于X86来说的是bios+grub;对于arm等嵌入式架构来说通常是fastboot等</li><li>kernel 直接获取上游开源的即可.kernel 也有针对不同平台的版本,有专门针对arm架构的,比x86架构的kernel要小的许多</li><li>rootfs的制作可以使用debootstrap,buildroot,yocto等工具直接可以构建出一个rootfs.img. debootstap 通常是使用上游debian构建好最小rootfs,方便oem定制</li><li>oem 或者不同的Linux发行版通常对桌面环境(desktop environment),仓库源,认证和证书方式做了定制. 但是底层还是借用上游的.</li><li>由于工程师手动去构建OS比较麻烦,是过程自动化,借用CI&#x2F;CD工具–jenkins实现.</li></ol><h2 id="部署-x2F-Deployment"><a href="#部署-x2F-Deployment" class="headerlink" title="部署&#x2F;Deployment"></a>部署&#x2F;Deployment</h2><ol><li>构建好系统镜像之后,就可以部署到不同的机器上了,主流x86和ARM.</li><li>对于X86来说, 通常刻在CD光碟上或者使用Udisk制作镜像盘,制作镜像盘后就可以给机器安装系统了. 在批量生产上,为了提高效率,通常使用PXE链接网络文件系统(NFS)的方式,进行批量部署安装机器</li><li>对于ARM来说,通常烧录的方式将镜像烧录到ROM中,并且前提已经做好了分区.(在X86中,通常是在安装的时候,才做的分区)</li></ol><h2 id="维护-x2F-Maintenance"><a href="#维护-x2F-Maintenance" class="headerlink" title="维护&#x2F;Maintenance"></a>维护&#x2F;Maintenance</h2><ol><li>操作系统架构设计时,已经考虑到了系统的后续维护,为了应对各种紧急情况.例如数据丢失与保护,或者系统变砖无法开机等等</li><li>对于数据丢失,系统有备份功能,将数据拷贝到备用的分区建立还原点,但下次不小心把数据搞丢时,可以通过恢复功能还原到原来的时间点.</li><li>对于系统变砖或者开不了机,系统背后存在另外一个备份系统,这个备份系统可以覆盖正在使用的系统使系统恢复正常. 这里的机制称为SLOT AB.可以用于系统升级,恢复还原等.</li><li>系统将来需要升级,也可以静默升级,因为存在另外一个备用系统,可以升级这个备用系统,而不影响目前系统的使用,下次重启之后,就可以直接使用升级后的系统.</li><li>升级也具备多种模式.例如全量升级(full update) , 差分升级(diff update) .差分升级更加适合在arm嵌入式操作系统的场合,因为磁盘资源有限. OTA升级方式包含以上两种方式.</li><li>对于后端工程师来说,系统出现了bug需要借助一系列维护工具分析问题的原因所在,从现象层面,定位到模块原因,再定位到代码原因,最后修正代码,重新提交到gitlab或者gerrit.</li></ol><h2 id="优化-x2F-Optimize"><a href="#优化-x2F-Optimize" class="headerlink" title="优化&#x2F;Optimize"></a>优化&#x2F;Optimize</h2><ol><li>通过用户的反馈,功能增加,性能优化,BUG修复等,不断迭代出版本的操作系统.</li><li>操作系统也是代码,修正代码后,提交到gitlab和gerrit进行审核.</li><li>审核通过后Code Merge到代码分支中(片段代码融入了整体)</li><li>最后还是由jenkins自动化工具构建生成新一轮的操作系统.</li></ol><p>周而复始…</p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ANN vs Hash Table</title>
    <link href="/2020/07/08/ANNvsHashTable/"/>
    <url>/2020/07/08/ANNvsHashTable/</url>
    
    <content type="html"><![CDATA[<h1 id="ANN-artificial-neural-network-VS-Hash-Table"><a href="#ANN-artificial-neural-network-VS-Hash-Table" class="headerlink" title="ANN( artificial neural network ) VS Hash Table"></a>ANN( artificial neural network ) VS Hash Table</h1><p>The story began that when I reviewed Hash table in Data Structure lesson and I saw the figure of Hash table principle ,suddenly , a idea comes to my mind that there’s somehow relationship between ANN(artificial neural network ) and  Hash Table .</p><h2 id="What’s-the-relationship"><a href="#What’s-the-relationship" class="headerlink" title="What’s the  relationship ?"></a>What’s the  relationship ?</h2><p><img src="/../img/ANNvsHashTable/ann.png" alt="figure of ANN"></p><p><img src="/../img/ANNvsHashTable/hash.png" alt="figure of Hash table"></p><p>We could notice that both two figures have three part : the left ,the middle ,the right ; Actually , each part of the middle is function part . The only difference between these is that the function of ANN is trained by tons of data and the function of Hash table ,called hash function ,is designed by manual actions usually .</p><p>The former funciton is unknown ,black box .But the later function is known ,white box .</p><h3 id="About-the-history"><a href="#About-the-history" class="headerlink" title="About the history"></a>About the history</h3><h4 id="Hash-function"><a href="#Hash-function" class="headerlink" title="Hash function"></a>Hash function</h4><blockquote><p>The term “hash” offers a natural analogy with its non-technical meaning (to “chop” or “make a mess” out of something), given how hash functions scramble their input data to derive their output.[20] In his research for the precise origin of the term, Donald Knuth notes that, while Hans Peter Luhn of IBM appears to have been the first to use the concept of a hash function in a memo dated January 1953, the term itself would only appear in published literature in the late 1960s, on Herbert Hellerman’s Digital Computer System Principles, even though it was already widespread jargon by then.[21]</p></blockquote><h4 id="ANN"><a href="#ANN" class="headerlink" title="ANN"></a>ANN</h4><blockquote><p>Warren McCulloch and Walter Pitts[4] (1943) opened the subject by creating a computational model for neural networks.[5] In the late 1940s, D. O. Hebb[6] created a learning hypothesis based on the mechanism of neural plasticity that became known as Hebbian learning. Farley and Wesley A. Clark[7] (1954) first used computational machines, then called “calculators”, to simulate a Hebbian network. Rosenblatt[8] (1958) created the perceptron.[9] The first functional networks with many layers were published by Ivakhnenko and Lapa in 1965, as the Group Method of Data Handling.[10][11][12] The basics of continuous backpropagation[10][13][14][15] were derived in the context of control theory by Kelley[16] in 1960 and by Bryson in 1961,[17] using principles of dynamic programming.</p></blockquote><p>According to these history , the first ANN came out at 1943 and the first concept of hash function came out at 1953 . The time between these are so close , it can’t be wasn’t somehow relationship in there !!</p><h2 id="What’s-role-of-Hash-table-played-in-Data-Structure"><a href="#What’s-role-of-Hash-table-played-in-Data-Structure" class="headerlink" title="What’s role of Hash table played in Data Structure ?"></a>What’s role of Hash table played in Data Structure ?</h2><blockquote><p>In computing, a hash table (hash map) is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index, also called a hash code, into an array of buckets or slots, from which the desired value can be found. During lookup, the key is hashed and the resulting hash indicates where the corresponding value is stored.</p></blockquote><h3 id="Why-Hash-table-called-“Hash-table-“"><a href="#Why-Hash-table-called-“Hash-table-“" class="headerlink" title="Why Hash table called “Hash table “?"></a>Why Hash table called “Hash table “?</h3><p>I supposed Hash is people’s name who invented Hash function and Hash table . But actually , it wasn’t . </p><p><a href="https://softwareengineering.stackexchange.com/questions/108124/why-it-is-called-hash-table-or-hash-function-hash-doesnt-make-any-sense-t">Why it is called “hash table”, or “hash function”? </a></p><h2 id="What’s-role-of-ANN-played-in-Machine-Learning"><a href="#What’s-role-of-ANN-played-in-Machine-Learning" class="headerlink" title="What’s role of ANN played in Machine Learning ?"></a>What’s role of ANN played in Machine Learning ?</h2><blockquote><p>Artificial neural networks (ANN) or connectionist systems are computing systems vaguely inspired by the biological neural networks that constitute animal brains.</p></blockquote><blockquote><p>The data structures and functionality of neural nets are designed to simulate associative memory. Neural nets learn by processing examples, each of which contains a known “input” and “result,” forming probability-weighted asociations between the two, which are stored within the data structure of the net itself. (The “input” here is more accurately called an input set, since it generally consists of multiple independent variables, rather than a single value.) Thus, the “learning” of a neural net from a given example is the difference in the state of the net before and after processing the example. After being given a sufficient number of examples, the net becomes capable of predicting results from inputs, using the associations built from the example set. If a feedback loop is provided to the neural net about the accuracy of its predictions, it continues to refine its associations, resulting in an ever-increasing level of accuracy. In short, there is a direct relationship between the number and diversity of examples processed by a neural net and the accuracy of its predictions. This is why a neural net gets “better” with use. What is interesting about neural nets is that because they are indiscriminate in the way they form associations, they can form unexpected associations, and reveal relationships and dependencies that were not previously known.</p></blockquote><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We discussed the similarity and differences of ANN and Hash table in aspects of principle and history , which hopefully we could discover the new idea that are able to optimize algorithms of both or apply to the some specific issues  . One of the applications ,in my opinion , is that the Hash function could be replace by method of DeepLearning whose function trained by data . The advantages of this method is save algorithms development time of handled design .</p><p>On the other hand , because of the same structure form –input, functions, output – it’s unfortunately that , in some way ,there is no prograss about AI field during computer science development .</p><p>If we want to make some application using ideas we discovered ,we have to research in it more .</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Artificial_neural_network">wiki&#x2F;Artificial_neural_network</a></p><p><a href="https://en.wikipedia.org/wiki/Hash_table">wiki&#x2F;Hash_table</a></p><p><a href="https://en.wikipedia.org/wiki/Hash_function">wiki&#x2F;Hash_function</a></p><p><a href="https://softwareengineering.stackexchange.com/questions/108124/why-it-is-called-hash-table-or-hash-function-hash-doesnt-make-any-sense-t">Why it is called “hash table”, or “hash function”? </a></p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Robomaster Evolution</title>
    <link href="/2020/05/09/RobomasterRovo/"/>
    <url>/2020/05/09/RobomasterRovo/</url>
    
    <content type="html"><![CDATA[<h1 id="Robomaster-Evolution"><a href="#Robomaster-Evolution" class="headerlink" title="Robomaster Evolution"></a>Robomaster Evolution</h1><p><img src="/../img/RobomasterRovo/00.jpg"><br><img src="/../img/RobomasterRovo/01.jpg"><br><img src="/../img/RobomasterRovo/02.jpg"><br><img src="/../img/RobomasterRovo/03.jpg"><br><img src="/../img/RobomasterRovo/04.jpg"><br><img src="/../img/RobomasterRovo/05.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
      <tag>Robot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Structure From Multi-Views</title>
    <link href="/2020/05/06/StructureFromMultiViews/"/>
    <url>/2020/05/06/StructureFromMultiViews/</url>
    
    <content type="html"><![CDATA[<h1 id="Structure-From-Multi-Views"><a href="#Structure-From-Multi-Views" class="headerlink" title="Structure From Multi-Views"></a>Structure From Multi-Views</h1><h2 id="DEMO-at-first"><a href="#DEMO-at-first" class="headerlink" title="DEMO at first"></a>DEMO at first</h2><p><img src="/../img/StructureFromMultiViews/demo.gif" alt="DEMO"></p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ol start="0"><li><p>this project is modified from Chapter4_StructureFromMotion</p></li><li><p>non gpu version is better for beginner of learning CV . i.e. compile the project would be easy .</p></li><li><p>structure from multiple views</p></li><li><p>use AKAZE FeatureDetector and DescriptorExtractor instead of ORB </p></li><li><p>non opencv3_contrib verison</p></li></ol><h2 id="AKAZE-VS-ORB"><a href="#AKAZE-VS-ORB" class="headerlink" title="AKAZE VS ORB"></a>AKAZE VS ORB</h2><blockquote><p>We have concluded that, although ORB is faster to compute, AKAZE shows a better compromise between speed and performance than ORB for images with low resolution. Keywords: ORB, AKAZE, UAV, visual odometry, feature matching.</p></blockquote><p><a href="http://www.epacis.net/ccis2016/papers/paper_121.pdf">For more details – &gt; paper </a></p><h2 id="Matcher-FLANN-BASED-MATCHER-VS-BFMATCHER"><a href="#Matcher-FLANN-BASED-MATCHER-VS-BFMATCHER" class="headerlink" title="Matcher : FLANN-BASED MATCHER VS BFMATCHER"></a>Matcher : FLANN-BASED MATCHER VS BFMATCHER</h2><blockquote><p>BFMatcher is going to try all the possibilities (which is the meaning of “Brute Force” and hence it will find the best matches.</p></blockquote><blockquote><p>FLANN, meaning “Fast Library for Approximate Nearest Neighbors”, will be much faster but will find an approximate nearest neighbors. It will find a good matching, but not necessarily the best possible one. You can play with FLANN’s parameters in order to increase the precision (i.e. the “quality” of the matchings), but it will be at the cost of slowing the algorithm.</p></blockquote><blockquote><p>In other words: FLANN is much faster than BFMatcher but it only finds an approximate nearest neighbor, which is a good matching but not necessarily the best. You can play with the parameters of FLANN in order to increase its speed or its precision.</p></blockquote><p><a href="https://stackoverflow.com/questions/10610966/difference-between-bfmatcher-and-flannbasedmatcher">For more details – &gt; Q&amp;A </a></p><h2 id="Parse-SFM-project"><a href="#Parse-SFM-project" class="headerlink" title="Parse SFM project"></a>Parse SFM project</h2><h3 id="Files-Function"><a href="#Files-Function" class="headerlink" title="Files Function"></a>Files Function</h3><p><img src="/../img/StructureFromMultiViews/filesfunction.jpg"></p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="/../img/StructureFromMultiViews/UML.jpg"></p><h3 id="process-diagram"><a href="#process-diagram" class="headerlink" title="process diagram"></a>process diagram</h3><p><img src="/../img/StructureFromMultiViews/process.jpg"></p><h2 id="Project-repository"><a href="#Project-repository" class="headerlink" title="Project repository"></a>Project repository</h2><p><a href="https://github.com/MasteringOpenCV/code/tree/master/Chapter4_StructureFromMotion">original–Chapter4_StructureFromMotion</a></p><p><a href="https://github.com/pans0ul/StructureFromMultiViews">this project</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>SFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Structure From two views</title>
    <link href="/2020/04/28/StructureFrom2views/"/>
    <url>/2020/04/28/StructureFrom2views/</url>
    
    <content type="html"><![CDATA[<h1 id="Structure-From-two-views"><a href="#Structure-From-two-views" class="headerlink" title="Structure From two views"></a>Structure From two views</h1><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ol start="0"><li><p>this project is modified from Chapter4_StructureFromMotion</p></li><li><p>non gpu version is better for beginner of learning CV . i.e. compile the project would be easy .</p></li><li><p>structure from two views</p></li><li><p>non opencv3_contrib verison</p></li></ol><h2 id="Fix-bug-in-the-project"><a href="#Fix-bug-in-the-project" class="headerlink" title="Fix bug in the project"></a>Fix bug in the project</h2><h3 id="original-in-Distance-h"><a href="#original-in-Distance-h" class="headerlink" title="original in Distance.h"></a>original in Distance.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnlyMatchFeatures</span><span class="hljs-params">(<span class="hljs-type">int</span> strategy = STRATEGY_USE_OPTICAL_FLOW + STRATEGY_USE_DENSE_OF + STRATEGY_USE_FEATURE_MATCH)</span> </span>&#123;<br>imgpts1.<span class="hljs-built_in">clear</span>(); imgpts2.<span class="hljs-built_in">clear</span>(); fullpts1.<span class="hljs-built_in">clear</span>(); fullpts2.<span class="hljs-built_in">clear</span>();<br><br>std::vector&lt;cv::Mat&gt; imgs; imgs.<span class="hljs-built_in">push_back</span>(left_im); imgs.<span class="hljs-built_in">push_back</span>(right_im);<br>std::vector&lt;std::vector&lt;cv::KeyPoint&gt; &gt; imgpts; imgpts.<span class="hljs-built_in">push_back</span>(imgpts1); imgpts.<span class="hljs-built_in">push_back</span>(imgpts2);<br><br><span class="hljs-function">RichFeatureMatcher <span class="hljs-title">rfm</span><span class="hljs-params">(imgs,imgpts)</span></span>;<br>rfm.<span class="hljs-built_in">MatchFeatures</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>imgpts1 = rfm.<span class="hljs-built_in">GetImagePoints</span>(<span class="hljs-number">0</span>);<br>imgpts2 = rfm.<span class="hljs-built_in">GetImagePoints</span>(<span class="hljs-number">1</span>);<br><br>features_matched = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RecoverDepthFromImages</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(!features_matched) <br><span class="hljs-built_in">OnlyMatchFeatures</span>();<br><br>std::vector&lt;cv::DMatch&gt; matches;<br><span class="hljs-built_in">FindCameraMatrices</span>(K, Kinv, distortion_coeff, imgpts1, imgpts2, imgpts1_good, imgpts2_good, P, P1, matches, pointcloud<br><br></code></pre></td></tr></table></figure><h3 id="modified-in-Distance-h"><a href="#modified-in-Distance-h" class="headerlink" title="modified in Distance.h"></a>modified in Distance.h</h3><ol><li>the variable matches is set as global in class Distance </li><li>rfm.MatchFeatures(0, 1,&amp;matches);</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">OnlyMatchFeatures(<span class="hljs-params">int</span> <span class="hljs-params">strategy</span> = STRATEGY_USE_OPTICAL_FLOW + STRATEGY_USE_DENSE_OF + STRATEGY_USE_FEATURE_MATCH)</span> &#123;<span class="hljs-comment">//Q</span><br>imgpts1.clear<span class="hljs-literal">()</span>; imgpts2.clear<span class="hljs-literal">()</span>; fullpts1.clear<span class="hljs-literal">()</span>; fullpts2.clear<span class="hljs-literal">()</span>;<br><br>std::vector&lt;cv::Mat&gt; imgs; imgs.push<span class="hljs-constructor">_back(<span class="hljs-params">left_im</span>)</span>; imgs.push<span class="hljs-constructor">_back(<span class="hljs-params">right_im</span>)</span>;<br>std::vector&lt;std::vector&lt;cv::KeyPoint&gt; &gt; imgpts; imgpts.push<span class="hljs-constructor">_back(<span class="hljs-params">imgpts1</span>)</span>; imgpts.push<span class="hljs-constructor">_back(<span class="hljs-params">imgpts2</span>)</span>;<br><br>RichFeatureMatcher rfm(imgs,imgpts); <span class="hljs-comment">//detect feature &amp; compute descriptors as globle of class RichFeatureMatcher</span><br><br><br><span class="hljs-comment">//pans0ul fix</span><br>rfm.<span class="hljs-constructor">MatchFeatures(0, 1,&amp;<span class="hljs-params">matches</span>)</span>;<br><br>imgpts1 = rfm.<span class="hljs-constructor">GetImagePoints(0)</span>; <span class="hljs-comment">//imgpts1 is globle of Distance</span><br>imgpts2 = rfm.<span class="hljs-constructor">GetImagePoints(1)</span>;<br><br>features_matched = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Reasons"><a href="#Reasons" class="headerlink" title="Reasons"></a>Reasons</h3><ol><li>function MatchFeatures() will update variable matches </li><li>the correct algorithm order is function FindCameraMatrices() after get matches </li><li>if the variable matches is empty ,there is no necessary to compute camera matrix</li></ol><h2 id="Parse-SFM-project"><a href="#Parse-SFM-project" class="headerlink" title="Parse SFM project"></a>Parse SFM project</h2><h3 id="Files-Function"><a href="#Files-Function" class="headerlink" title="Files Function"></a>Files Function</h3><p><img src="/../img/StructureFrom2views/filesfunction.jpg"></p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="/../img/StructureFrom2views/UML.jpg"></p><h3 id="process-diagram"><a href="#process-diagram" class="headerlink" title="process diagram"></a>process diagram</h3><p><img src="/../img/StructureFrom2views/process.jpg"></p><h2 id="Project-repository"><a href="#Project-repository" class="headerlink" title="Project repository"></a>Project repository</h2><p><a href="https://github.com/MasteringOpenCV/code/tree/master/Chapter4_StructureFromMotion">original–Chapter4_StructureFromMotion</a></p><p><a href="https://github.com/pans0ul/StructureFrom2views_of_Chapter4_StructureFromMotion">this project</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>SFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>National Undergraduate Electronic Design Contest</title>
    <link href="/2020/04/21/nationalUndergraduateElectronicDesignContest/"/>
    <url>/2020/04/21/nationalUndergraduateElectronicDesignContest/</url>
    
    <content type="html"><![CDATA[<h1 id="National-Undergraduate-Electronic-Design-Contest"><a href="#National-Undergraduate-Electronic-Design-Contest" class="headerlink" title="National Undergraduate Electronic Design Contest"></a>National Undergraduate Electronic Design Contest</h1><p><strong>National Undergraduate Electronic Design Contest consists of two parts .One is analog electronic design ,another is theme design.</strong> </p><p><img src="/../img/NationalUndergraduateElectronicDesignContest/Nation%20ELEC%20Match-A.jpg" alt="analog practise"></p><p><img src="/../img/NationalUndergraduateElectronicDesignContest/Nation%20ELEC%20Match-xian.jpg" alt="Contest memories"></p><p><img src="/../img/NationalUndergraduateElectronicDesignContest/li-poem.jpg" alt="poem from Mr.Li"></p><p><strong>致谢</strong><br><strong>温州大学</strong><br><strong>我的导师–陈老师</strong><br><strong>我的导师和诗人–李老师</strong><br><strong>我的两位队友</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reading SFM in book Mastering OpenCV</title>
    <link href="/2020/04/03/Reading-SFM%20in%20book%20-Mastering%20OpenCV/"/>
    <url>/2020/04/03/Reading-SFM%20in%20book%20-Mastering%20OpenCV/</url>
    
    <content type="html"><![CDATA[<h1 id="Reading-SFM-in-book-Mastering-OpenCV"><a href="#Reading-SFM-in-book-Mastering-OpenCV" class="headerlink" title="Reading SFM in book: Mastering OpenCV"></a>Reading SFM in book: Mastering OpenCV</h1><blockquote><p>Mastering OpenCV with Practical Computer Vision Projects</p></blockquote><h3 id="chartper-4-Exploring-Structure-from-Motion-Using-OpenCV"><a href="#chartper-4-Exploring-Structure-from-Motion-Using-OpenCV" class="headerlink" title="chartper 4 : Exploring Structure from Motion Using OpenCV"></a>chartper 4 : Exploring Structure from Motion Using OpenCV</h3><p><strong>This book is a good tutorial to explain SFM ( structure from motion ) implementation . I give brief about in this charpter : SFM covered</strong></p><p><img src="/../img/Reading-SFM%20in%20book%20-Mastering%20OpenCV/2020-04-18-15-41-49.png"></p><h3 id="Section-1-Structure-from-Motion-concepts"><a href="#Section-1-Structure-from-Motion-concepts" class="headerlink" title="Section 1 : Structure from Motion concepts"></a>Section 1 : Structure from Motion concepts</h3><p>Every knowledge was built by concepts at first .Structure from Motion concepts in Section 1  to tell us that what is SFM ,about concepts related to SFM ,such as camera calibration ,triangulation of 3d points ,camera motion ,the brief of principle that how to reconstruction 3D object , etc..</p><h3 id="Section-2-Estimating-the-camera-motion-from-a-pair-of-images"><a href="#Section-2-Estimating-the-camera-motion-from-a-pair-of-images" class="headerlink" title="Section 2: Estimating the camera motion from a pair of images"></a>Section 2: Estimating the camera motion from a pair of images</h3><p>Estimating the camera motion from a pair of images talk about that how to get Essential Matrix and decompose it to obtain the R, t  from two key images which are taken from monocular with sequence time , where R is rotation matrix of camera motion ,and the t  is translation matrix of camera motion . Briefly ,R , t is two key matrix to consist of camera motion .</p><h3 id="Section-3-Reconstructing-the-scene"><a href="#Section-3-Reconstructing-the-scene" class="headerlink" title="Section 3 : Reconstructing the scene"></a>Section 3 : Reconstructing the scene</h3><p>Reconstructing the scene to tell us that after extract camera motion matrix , we use triangulation method and motion matrix to reconstruct 3d points into the scene ,but only to use two camera views . Then this book give the mothed how to extract high quality 3d points by using contrasting two 2d points . one of the point is original in the photo and another is reimaged point from 3d points . </p><h3 id="Section-4-Reconstruction-from-many-views"><a href="#Section-4-Reconstruction-from-many-views" class="headerlink" title="Section 4 : Reconstruction from many views"></a>Section 4 : Reconstruction from many views</h3><p>According the method from Section3 , the principle of Reconstruction from many views would be same . So it just does more procedures to be done .</p><h3 id="Section-5-Refinement-of-the-reconstruction"><a href="#Section-5-Refinement-of-the-reconstruction" class="headerlink" title="Section 5 : Refinement of the reconstruction"></a>Section 5 : Refinement of the reconstruction</h3><p>Refinement of the reconstruction .This process is helpful for get precise and high quality 3d points . The known as the process of Bundle Adjustment(BA) ,helping for refining and optimizing the reconstructed scene . One implementation of a bundle adjustment algorithm is Simple Sparse Bundle Adjustment (SSBA) . You will see the illustration of construction between algorithm applied and doesn’t .</p><h3 id="Section-6-Visualizing-3D-point-clouds"><a href="#Section-6-Visualizing-3D-point-clouds" class="headerlink" title="Section 6: Visualizing 3D point clouds"></a>Section 6: Visualizing 3D point clouds</h3><p>Visualizing 3D point clouds ,this section give a introduction about visualization tool, PCL (point cloud library) , The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D&#x2F;3D image and point cloud processing. Also could be use in this case—SFM.</p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>SFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D-printer</title>
    <link href="/2019/08/18/3d-printer/"/>
    <url>/2019/08/18/3d-printer/</url>
    
    <content type="html"><![CDATA[<h1 id="DIY-for-3D-printer-during-two-weeks"><a href="#DIY-for-3D-printer-during-two-weeks" class="headerlink" title="DIY for 3D-printer during two weeks"></a>DIY for 3D-printer during two weeks</h1><p><img src="/../img/3d-printer/3D-PRINTER-comp.jpg" alt="some components"><br><img src="/../img/3d-printer/3D-PRINTER-assem.jpg" alt="building"><br><img src="/../img/3d-printer/3D-PRINTER-run.jpg" alt="try to print"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TI-Tintin-OPT8241二次开发和应用系列--建议阅读顺序</title>
    <link href="/2019/04/15/TOF-dev-Reading-Advice/"/>
    <url>/2019/04/15/TOF-dev-Reading-Advice/</url>
    
    <content type="html"><![CDATA[<h1 id="TI-Tintin-OPT8241二次开发和应用系列–建议阅读顺序"><a href="#TI-Tintin-OPT8241二次开发和应用系列–建议阅读顺序" class="headerlink" title="TI-Tintin-OPT8241二次开发和应用系列–建议阅读顺序"></a>TI-Tintin-OPT8241二次开发和应用系列–建议阅读顺序</h1><p>一文读懂 TOF 深度相机技术原理 –TI-Tintin-OPT8241 二次开发和应用系列 –Theory Level (1&#x2F;3)</p><p>TI-Tintin-OPT8241 二次开发和应用系列 –Theory Level (2&#x2F;3)</p><p>TI-Tintin-OPT8241 二次开发和应用系列 –Hardware Level</p><p>TI-Tintin-OPT8241 二次开发和应用系列 –Software Level</p><p>TI-Tintin-OPT8241 二次开发和应用系列 –Theory Level (3&#x2F;3)- 参数理解</p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>TOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TI-Tintin-OPT8241二次开发和应用系列--Theory Level(3/3)-参数理解</title>
    <link href="/2019/01/26/TOF-theory-3-3/"/>
    <url>/2019/01/26/TOF-theory-3-3/</url>
    
    <content type="html"><![CDATA[<h1 id="TI-Tintin-OPT8241二次开发和应用系列–Theory-Level-3-x2F-3-参数理解"><a href="#TI-Tintin-OPT8241二次开发和应用系列–Theory-Level-3-x2F-3-参数理解" class="headerlink" title="TI-Tintin-OPT8241二次开发和应用系列–Theory Level(3&#x2F;3)-参数理解"></a>TI-Tintin-OPT8241二次开发和应用系列–Theory Level(3&#x2F;3)-参数理解</h1><p>理解一些深度相机的基本参数对系统理解和在开发中起到至关重要的作用，例如参数integration time ,unambiguous range,Depth resolution等。</p><h2 id="1-integration-time"><a href="#1-integration-time" class="headerlink" title="1.integration time"></a>1.integration time</h2><p>在“TI-Tintin-OPT8241二次开发和应用系列–Theory Level(1&#x2F;3)–4.TOF传感器（感光芯片）工作原理”中已经介绍，深度相机感光传感器的整个读取周期包括四个阶段，其中一个阶段就是integration。如果integration time越大，则接收的光子越多，能量越大，那么接收到的图像就越清晰，但过大的integration time会导致图像饱和。通常integration time设置在50%以下。integration time在OPT82中的说明：<br><img src="/../img/TOF-theory-3-3/3-3%20(1).png"></p><p>integration time在OPT92中的说明以及对应参数名称：<br><img src="/../img/TOF-theory-3-3/3-3%20(2).png"></p><h2 id="2-unambiguous-range"><a href="#2-unambiguous-range" class="headerlink" title="2.unambiguous range"></a>2.unambiguous range</h2><h3 id="什么是unambiguous-range？"><a href="#什么是unambiguous-range？" class="headerlink" title="什么是unambiguous range？"></a>什么是unambiguous range？</h3><p>在“TI-Tintin-OPT8241二次开发和应用系列–Theory Level(1&#x2F;3)”距离d推导过程中，在坐标转换后计算相位theta，有一副很好的图，如下图所示：<br><img src="/../img/TOF-theory-3-3/3-3%20(3).png"></p><p>出自TI官方文档–system design</p><p>图中的参数说明：<br><img src="/../img/TOF-theory-3-3/3-3%20(4).png"></p><p><img src="/../img/TOF-theory-3-3/3-3%20(5).png"></p><p>角度theta 表示距离的相位，phase</p><p>R表示：在图示中，表示这个圆的半径R；在公式中，R 表示unambiguous 并且 R&#x3D;Confidence (置信度)；</p><hr><p>为了求得距离d，所以要求theta，之后才能求得phase，计算出距离d，表示相机与物体的距离。</p><p>为了了解系统，更加深入的理解这张图，思考其中的R代表的是什么意思？为什么 R&#x3D;Confidence ？距离d与R有什么关系？</p><h3 id="Q1：为什么R表示的是unambiguous-range？距离d与R有什么关系？"><a href="#Q1：为什么R表示的是unambiguous-range？距离d与R有什么关系？" class="headerlink" title="Q1：为什么R表示的是unambiguous range？距离d与R有什么关系？"></a>Q1：为什么R表示的是unambiguous range？距离d与R有什么关系？</h3><p>从公式的角度理解，因为距离d的计算公式:<br><img src="/../img/TOF-theory-3-3/3-3%20(6).png"></p><p>，对比上图中R&#x3D;unambiguous range的公式，R少了距离d的什么？是theta&#x2F;2π，而少了的这部分正好表示的是距离d在总距离的时间占比。</p><p>这样看来，R没有这项（这项为1）,也就是说R表示深度相机能够测量的最远距离。可以说距离d始终在R这个范围内，并且计算得到的距离d表示R的一部分。下图表示：<br><img src="/../img/TOF-theory-3-3/3-3%20(7).png"></p><p>因为，结合实际经验并且试想一下，在ambiguous（小于R或者超出R）的情况是怎么样的？图片呈现黑色，如果没有相位差，或者重叠，都是一种ambiguous的状态，都呈现黑色。距离太近会出现ambigious,距离太远也会出现ambigious ，所以range 是一个范围。</p><p>再从图中设想一下，假设需要被检测的物体超过这个range，那么距离d的长度就会大于上图中圆的半径，超过这个圆的半径的长度就会截止，也就是说在图像上超过这个距离的被测物体无法显示（显示黑色）；当距离d的长度小于上图中圆的半径，很显然，结果同理。</p><p>从公式上解释R的含义： R&#x3D;confidence&#x3D; C&#x2F;2F &#x3D;&gt; R&#x3D;tc&#x2F;2 公式的意思是：2分之光速经历一个时间周期T走过的距离。所以R表示的就是非重叠距离，并且把光速的距离分成每个周期。</p><h3 id="Q2-R为什么与可测的距离相等？是最大可测的距离？"><a href="#Q2-R为什么与可测的距离相等？是最大可测的距离？" class="headerlink" title="Q2:R为什么与可测的距离相等？是最大可测的距离？"></a>Q2:R为什么与可测的距离相等？是最大可测的距离？</h3><p>因为，在“TI-Tintin-OPT8241二次开发和应用系列–Theory Level”文中提到，在固定红外发射频率的条件下，每一个周期的占空比是有限的，只有在这个占空比范围内才能够正常检测。</p><p>而且，<img src="/../img/TOF-theory-3-3/3-3%20(9).png"></p><p><img src="/../img/TOF-theory-3-3/3-3%20(10).png"></p><p><img src="/../img/TOF-theory-3-3/3-3%20(11).png"></p><p>例如重叠之后，就不知道真实物体的距离了，假设能显示图像，range的范围是1-5米，超过5米的距离的物体重叠相位，真实物体的距离是7M，但是超过了range,图像上显示物体的距离只是2m，但是实际操作上，超过这个range之后图像一般显示黑色。</p><h4 id="另外，R的实际公式"><a href="#另外，R的实际公式" class="headerlink" title="另外，R的实际公式"></a>另外，R的实际公式</h4><p>以上关于R的公式其实是一个理想的公式，实际公式如下：<br><img src="/../img/TOF-theory-3-3/3-3%20(12).png"></p><p>所以还会有另外两个参数可以设置，分别是mod_freq1 ， mod_freq2，关于他们更多详细内容，参考OPT9221芯片说明。</p><h2 id="3-与数据输出相关的参数"><a href="#3-与数据输出相关的参数" class="headerlink" title="3.与数据输出相关的参数"></a>3.与数据输出相关的参数</h2><p>在“TI-Tintin-OPT8241二次开发和应用系列–Software Level”一文中，已经介绍了depthFrame包含那些信息，接下来将说明depthFrame是怎么构成的。<br><img src="/../img/TOF-theory-3-3/3-3%20(13).png"></p><p><img src="/../img/TOF-theory-3-3/3-3%20(14).png"></p><p>一帧depthFrame有多个sub-frame组成；一个sub-frame有4个quad组成；每个quad被拆分成传感器处理的四个步骤。</p><p>一帧depthFrame代表一幅深度图像；sub-frame代表深度图像上的每一个像素点；4个quad才能计算出该点像素的深度；</p><p>相信看官们看出对应关系了。</p><p>以上的所有参数都会在OPT9221芯片说明中体现，包含参数有以下：</p><p>sub_frame_cnt_max – SUB_FRAME_CNT_MAX<br><img src="/../img/TOF-theory-3-3/3-3%20(15).png"></p><p>quad_cnt_max – QUAD_CNT_MAX<br><img src="/../img/TOF-theory-3-3/3-3%20(16).png"></p><p>freq_ratio – FREQ_RATIO<br><img src="/../img/TOF-theory-3-3/3-3%20(17).png"></p><p>op_clk_freq–OP_CLK_FREQ<br><img src="/../img/TOF-theory-3-3/3-3%20(18).png"></p><p><img src="/../img/TOF-theory-3-3/3-3%20(19).png"></p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p><strong>属于OPT8241的一些参数</strong></p><p>op_clk_freq–OP_CLK_FREQ</p><p>mod_freq1\mod_freq2</p><p>freq_ratio – FREQ_RATIO</p><p><strong>属于OPT9221的一些参数</strong></p><p>Frame_rate</p><p>sub_frame_cnt_max</p><p>quad_cnt_max</p><h2 id="4-Depth-resolution"><a href="#4-Depth-resolution" class="headerlink" title="4.Depth resolution"></a>4.Depth resolution</h2><p>对Depth resolution我刚开始只是一知半解。直到我向TI官方人员提问过后，才明白。他们的回答是这样的：</p><p>Depth resolution is the standard deviation of the measured distance over a large set of frames captured int the system.  </p><p>The only thing that “Depth Resolution” conveys is the precision of the depth measurement of the 3D ToF system. Typically, your image processing algorithm and your application would decide how much depth resolution is needed.  </p><p>Please read through the user guide present in your system estimator installation folder to understand how to use the software.</p><p>总结上面的话，就是说depth resolution 是一个深度测量的准确度偏差。例如被测物体实际物体是3m，按道理在图像上显示的深度也应该3m，如果depth resolution是1%，也就是说在图像上不能准确显示，会有0.03m(3m*0.01)的偏差，实际显示可能是2.97m；</p><p>公式：<img src="/../img/TOF-theory-3-3/3-3%20(20).png"></p><p>从公式上解释就是，在有效的检测范围内，有效的接收图像、像素、分辨率，depth resolution 越小，越小越好。</p><hr><p>交流QQ： 365334601</p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>TOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TI-Tintin-OPT8241二次开发和应用系列--Software Level</title>
    <link href="/2019/01/25/TOF-dev-Software-Level/"/>
    <url>/2019/01/25/TOF-dev-Software-Level/</url>
    
    <content type="html"><![CDATA[<h1 id="TI-Tintin-OPT8241二次开发和应用系列–Software-Level"><a href="#TI-Tintin-OPT8241二次开发和应用系列–Software-Level" class="headerlink" title="TI-Tintin-OPT8241二次开发和应用系列–Software Level"></a>TI-Tintin-OPT8241二次开发和应用系列–Software Level</h1><h2 id="1-了解-VOXEL-SDK-软件工程框架"><a href="#1-了解-VOXEL-SDK-软件工程框架" class="headerlink" title="1.了解 VOXEL SDK 软件工程框架"></a>1.了解 VOXEL SDK 软件工程框架</h2><p>详情参考：<a href="https://github.com/3dtof/voxelsdk/wiki/Voxel-SDK-Architecture">https://github.com/3dtof/voxelsdk/wiki/Voxel-SDK-Architecture</a></p><h3 id="主要的三个模块"><a href="#主要的三个模块" class="headerlink" title="主要的三个模块"></a>主要的三个模块</h3><ol><li><p>Voxel Libraries</p><p>主要作用是，一个处理对不同的深度相机系统获取的深度数据的上位机程序（有点拗口）包括数据交换、下载和上传，深度数据处理与现实等等。简而言之，这部分就是处理深度数据的上位机程序。TI主要是对自己生产的不同深度相机开发板定制的一个软件库。例如tintinOPT8241,OPT8320、haddockCamera、CalculusCamera等等深度相机。</p></li><li><p>Configuration Files 主要作用是，文件中包含了深度相机系统的参数信息，深度相机链接上位机的时候，可以读取这个文件，让深度相机可以获取合适的参数配置。其中包括相机肚子的参数，相机共有的内参外参等标定系数等。</p></li><li><p>Firmware Files 主要作用是，Firmware（固件）是烧写在深度相机开发板芯片上的文件。就像智能手机，它有它自己的固件。固件类似于，将程序编写好之后下载到单片机上，而这里的程序就是固件，往往这部分功能是作为系统的驱动层。不过，非常遗憾的是，除了1，2部分，这部分TI他们是不开源的。</p></li></ol><h3 id="了解-Voxel-Libraries-架构"><a href="#了解-Voxel-Libraries-架构" class="headerlink" title="了解 Voxel Libraries 架构"></a>了解 Voxel Libraries 架构</h3><p><img src="/../img/TOF-dev-Software-Level/sl-1.png"></p><p>如上图所示，Voxel Libraries 主要有两个库组成：Voxel library、TI3DToF library，<a href="http://封装为libvoxel.so/">封装为libvoxel.so</a> on Linux； <a href="http://libti3dtof.so/">libti3dtof.so</a> on Linux 。 他们各自都有自己的namespace, Voxel:: 与 Voxel::TI:: ,TI3DToF library 继承 Voxel library 。</p><p>实线箭头表示继承关系；虚线箭头表示引用或者使用关系；虚框表示的是抽象类；实框表示的是实体类。抽象类只能被继承不能实体化，实体类可以继承也可以实体化。</p><p>因为文章的目的侧重是做应用开发，所以关于Voxel Libraries介绍，我讲个大概。</p><p>在Voxel library中，CameraSystem 是最主要的，许多其他类都要依赖他。主要作用是相机（不一定指深度相机）一些通用的参数配置。在这个基础上才会有DepthCamera类等一系列的深度相机设置。</p><p>继承Voxel library的TI3DToF library更加有针对性，虽然可以看到这个TI3DToF library里的类都是抽象类，没有实体类，但是这部分都是作为TI一系列DepthCamera所用的抽象公共类，将来要被具体tintinDepthCamera-CDK实体类继承。</p><p>关于Voxle Device Library 看到在这个Voxel Libraries构架图中，你会发现没有tintinDepthCamera-CDK的继承框图，这个图上没有画出它的继承关系。实际上，TintinCamera–OPT8241继承的是TOFtintinCamera与TOFCameraFactoryBase。</p><h2 id="2-了解-amp-安装-VOXEL-SDK"><a href="#2-了解-amp-安装-VOXEL-SDK" class="headerlink" title="2.了解&amp;安装 VOXEL SDK"></a>2.了解&amp;安装 VOXEL SDK</h2><p>安装教程详见：<a href="https://github.com/3dtof/voxelsdk/wiki#installation">https://github.com/3dtof/voxelsdk/wiki#installation</a> Linux or Windows ，建议选择linux - ubuntu 14.04 作为开发环境，因为后续一些应用只能在linux上展开。</p><p>下载 SDK Open-Source 包含以下主要的文件夹</p><ol><li>Voxel - the Core Voxel-SDK library</li><li>TI3DToF - For TI’s depth camera support</li><li>VoxelPCL - For Voxel-PCL integration</li><li>App - For VoxelCLI and other apps</li><li>Test - For individual test programs</li></ol><p>文件夹的名称和关系基本与之前所介绍的Voxel Libraries对应。其他的，VoxelPCL这个整合了PCL的一个应用，主要用于PCL的三维点云显示。APP文件夹中主要包含两个应用程序，SimpleVoxelViewer and Voxel CLI 。SimpleVoxelViewer只是一个PCL显示；而Voxel CLI 即可以显示还可以做其他交互操作。</p><p>关于Voxel CLI 详见：<a href="https://github.com/3dtof/voxelsdk/wiki/Voxel-CLI">https://github.com/3dtof/voxelsdk/wiki/Voxel-CLI</a></p><p>关于文件夹Test</p><p>可能是做开发时、调试时，留下的单独测试程序，我运行测试过，但是没有链接成功过 :_( 。但基本不会影响我的后续应用开发。</p><p>以下所openSource 中所有的Test子程序：</p><p><img src="/../img/TOF-dev-Software-Level/sl-2.png"></p><h2 id="3-如何获取-depth-data"><a href="#3-如何获取-depth-data" class="headerlink" title="3.如何获取 depth data"></a>3.如何获取 depth data</h2><p>连接设备之后，以Voxel CLI方式，可以保存的数据有：</p><ul><li>RAW</li></ul><p><img src="/../img/TOF-dev-Software-Level/sl-3.png"></p><ul><li>Phase</li></ul><p><img src="/../img/TOF-dev-Software-Level/sl-4.png"></p><ul><li>Depth data</li></ul><p><img src="/../img/TOF-dev-Software-Level/sl-5.png"></p><ul><li>Ambient</li></ul><p><img src="/../img/TOF-dev-Software-Level/sl-6.png"></p><ul><li>Amplitude</li></ul><p><img src="/../img/TOF-dev-Software-Level/sl-7.png"></p><ul><li>Flags</li></ul><p><img src="/../img/TOF-dev-Software-Level/sl-8.png"></p><ul><li>PointCloud</li></ul><p><img src="/../img/TOF-dev-Software-Level/sl-9.png"></p><ul><li>Vxl</li></ul><p><img src="/../img/TOF-dev-Software-Level/sl-10.png"></p><p>以上数据类型，主要可以分成四类： 对应wiki中的pipeline 详见： <a href="https://github.com/3dtof/voxelsdk/wiki/Voxel::DepthCamera">https://github.com/3dtof/voxelsdk/wiki/Voxel::DepthCamera</a></p><p><img src="/../img/TOF-dev-Software-Level/sl-11.png"></p><p>第一类 :Raw data</p><ul><li>RAW</li><li>Phase</li></ul><p>这里的Raw data 不管是有没有处理过的(processed)都是Raw data</p><p>第二类 ：depthFrame</p><ul><li>Depth data</li><li>Ambient</li><li>Amplitude</li><li>Flags</li></ul><p>注意这里的depth data 不是depthFrame，一个 depthFrame 中包含以上4个数据类型信息。 depthFrame输出的数据格式已经向前在芯片资料中已经给出。</p><p><img src="/../img/TOF-dev-Software-Level/sl-12.png"></p><p>第三类 ：PointCloudFrame</p><ul><li>PointCloud</li></ul><p>PointCloud点云数据，包含xyzi等3D数据信息，是由depthFrame通过像素坐标系转换世界坐标系得到的。</p><p>第四类： 用户（TI）自定义类型</p><ul><li>Vxl</li></ul><p>这部分是TI自定义数据类型，一个vxl的数据格式文件，里面可能同时包含depthFrame和PointCloudFrame。用户可以通过更改open source 程序得到自己想要的数据格式。</p><p>在open source 中的以下代码中可以更改</p><p><img src="/../img/TOF-dev-Software-Level/sl-13.png"></p><p>使用Tintin深度相机做应用，比较多用到的数据类型是depthFrame和PointCloudFrame，所以深刻认识这两个数据类型是应用开发的基础。在之后的内容中，会进一步介绍depthFrame和PointCloudFrame。</p><h2 id="4-Depth-data的认识与其应用"><a href="#4-Depth-data的认识与其应用" class="headerlink" title="4.Depth data的认识与其应用"></a>4.Depth data的认识与其应用</h2><p>先来看一下，下图对于depth与PointCloud的定义：</p><p><img src="/../img/TOF-dev-Software-Level/sl-14.png"></p><p><img src="/../img/TOF-dev-Software-Level/sl-15-coke.png"></p><p>右边是RGB采集的图像，左边是深度相机采集的深度图，亮度越亮表示距离越近，越暗的表示距离越远。 </p><p><img src="/../img/TOF-dev-Software-Level/sl-15.png"></p><p>另外，深度图还可以被渲染成不同的RGB24颜色，颜色越暖越近，颜色越冷越远。 depth 表示的是相机与物体之间的距离，图示：</p><p><img src="/../img/TOF-dev-Software-Level/sl-16.png"></p><p>PointCloud 每个点包含xyz 信息，通常是由depth 数据得到，一个立体的图像是由无数多个点组成并呈现出来的。</p><p><img src="/../img/TOF-dev-Software-Level/sl-17.png"></p><p>depthFrame 的数据格式，用文本打开使用CLI保存的Depth 数据，你会发现，四个字节之间会有一定规律，是符合芯片说明中的4-ByteMode。</p><p><img src="/../img/TOF-dev-Software-Level/sl-18.png"></p><p>而且，在Open source 中也体现了，如图所示 ：</p><p><img src="/../img/TOF-dev-Software-Level/sl-19.png"></p><p>所以说，<strong>每个DepthFrame其中包含了 amplitude 与 depth .</strong></p><h3 id="RGB-Image-与-DepthFrame"><a href="#RGB-Image-与-DepthFrame" class="headerlink" title="RGB Image 与 DepthFrame"></a>RGB Image 与 DepthFrame</h3><p><strong>RGB与Depth data本质区别—-RGB 像素的值代表颜色，depth data像素的值代表深度</strong></p><p>RGB图片每个像素都有他自己的坐标，在一个像素坐标系表示，坐标分别用u,v 表示。每一点（u,v）的值表示该点的颜色，范围在0-255（RGB888）。一张有depth data构成的图片也适用于像素坐标系中，深度相机采集到的图像的坐标也是分别用u,v 表示,只不过每一点的值是相机与物体的距离，可以用(u,v,d)表示。同理，RGB图像每一点可以用（u,v,color）表示。</p><p>理解了RGB的数据格式，以及depth与RGB数据格式的区别之后，会发现他们的<strong>本质区别在于代表的含义不同</strong>。RGB与depth他们的数据都是相同的数字，只不过再通过一种规定的数据“格式”编码，并且用“工具”呈现出来罢了，其他两个是相同的，真正的不同在于代表的含义。可以用示意图表示：</p><p><img src="/../img/TOF-dev-Software-Level/sl-20.png"></p><p>（当时，我发现这点的时候，我想到了一个哲学范畴，每个人身上都具备相同“工具”——眼、耳、口、鼻、四肢等，但真正不同的是人的“数据含义”——思想，因为真正的思想不同，当用“工具”呈现时将是完全不同的意义，如果思想越先进，那么这个意义就越举足轻重。）</p><p><strong>如何应用depth data做图像处理？</strong></p><p>由于深度图像的(u,v,d)每个像素点表示物体与相机的距离，这里的d是一个float类型，打印输出的值就是距离，如下图所示：（某一点被检测物体的距离为：3.27979）。</p><p><img src="/../img/TOF-dev-Software-Level/sl-21.png"></p><p>因为深度图像上每一点上得到的信息是距离，所以在算法上我们可以将保留设置的距离范围内，滤除不必要的距离的物体。<strong>所以，处理深度图像相比RGB图像最大的优势在于，能够得到非常清晰的前后景分离的图像。</strong></p><h3 id="深度图像的算法处理"><a href="#深度图像的算法处理" class="headerlink" title="深度图像的算法处理"></a>深度图像的算法处理</h3><p>对于深度图像的算法处理，通常做法是： 1.前后景分离 2.转换成黑白图像 3.形态学处理 4.形状、形态分析 5.物体识别或跟踪</p><p><img src="/../img/TOF-dev-Software-Level/sl-22.png"></p><p>这里针对GITHUB上TI提供的“Demo-application–handTracking”程序作分析。</p><h4 id="S1：前后景分离"><a href="#S1：前后景分离" class="headerlink" title="S1：前后景分离"></a>S1：前后景分离</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Jive::update</span><span class="hljs-params">(DepthFrame *frm)</span></span><br><span class="hljs-function"></span>&#123;<br>   DepthFrame hand;<br>   vector&lt; vector&lt;cv::Point&gt; &gt; contours;<br>   vector&lt;Vec4i&gt; hierarchy;<br>   <span class="hljs-function">RNG <span class="hljs-title">rng</span><span class="hljs-params">(<span class="hljs-number">12345</span>)</span></span>;   <br>   Mat gray;<br><br>   <span class="hljs-comment">// Create silhouette</span><br>   <span class="hljs-built_in">clipBackground</span>(*frm, hand);<br><br></code></pre></td></tr></table></figure><p>分析：DepthFrame *frm作为clipBackground()的传入参数，得到深度数据帧。函数功能是分离背景，如何分离背景？再看：</p><p><img src="/../img/TOF-dev-Software-Level/sl-23.png"></p><p>关键在于这里for循环，这个函数有两个输出参数，但是第二个当做输出。在这个循环中，遍历深度数据帧frm（一个深度数据帧包括depth&amp;amplitude，所以这里写in.amplitude.sieze()也可以），条件是：如果frm中像素深度值小于depthClip(是一个阈值，可以设置为1.2等，ampClip同理，范围在0-1)并且amplitude大于阈值，那么保留该点的深度值，并且push到新创建的DepthFrame hand的depth数据中，否则该点设置为0；下一个语句条件是：符合条件的，push到DepthFrame hand的amplitude数据中为1,否则该点的amplitude设置为0；</p><h4 id="S2：转化成黑白图像，深度数据可视化"><a href="#S2：转化成黑白图像，深度数据可视化" class="headerlink" title="S2：转化成黑白图像，深度数据可视化"></a>S2：转化成黑白图像，深度数据可视化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">_binaryMat = <span class="hljs-built_in">Mat</span>(hand.size.height, hand.size.width, CV_32FC1, hand.amplitude.<span class="hljs-built_in">data</span>());  <br>_binaryMat.<span class="hljs-built_in">convertTo</span>(gray, CV_8U, <span class="hljs-number">255.0</span>);<span class="hljs-comment">//amplitude date 0~1</span><br><span class="hljs-built_in">threshold</span>(gray, gray, <span class="hljs-number">200</span>, <span class="hljs-number">255</span>, THRESH_BINARY);<span class="hljs-comment">//to binary</span><br><br></code></pre></td></tr></table></figure><p>分析：分离前后景之后，就可以通过OpenCV库创建一个Mat矩阵操作与显示（这里创建的Mat以hand中的amplituede的数据，也可以用depth，可以写为hand.depth.data()）；如果后面加上 imshow(“Binary”, _binaryMat);imshow(“Contours”, drawing); 显示的就是非常分离清晰的前后景图像；相比RGB相机通过帧差法分离前后景效果要好很多的。</p><h4 id="S3：形态学处理，形状分析，物体跟踪等应用"><a href="#S3：形态学处理，形状分析，物体跟踪等应用" class="headerlink" title="S3：形态学处理，形状分析，物体跟踪等应用"></a>S3：形态学处理，形状分析，物体跟踪等应用</h4><p>程序中的处理方式如下，自行分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-built_in">findContours</span>(gray, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::<span class="hljs-built_in">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>   Mat drawing = Mat::<span class="hljs-built_in">zeros</span>( gray.<span class="hljs-built_in">size</span>(), CV_8UC3 );<br><br>   <span class="hljs-type">int</span> hands = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">if</span> (contours.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br><br>      vector&lt;<span class="hljs-type">int</span>&gt; hull, rhull;<br>      vector&lt;<span class="hljs-type">int</span>&gt; defect;<br>      vector&lt;<span class="hljs-type">int</span>&gt; tips;<br>      cv::Point center = cv::<span class="hljs-built_in">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>      <span class="hljs-type">float</span> radius = <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; contours.<span class="hljs-built_in">size</span>(); i++ ) &#123;  <br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">contourArea</span>(contours[i]) &gt; <span class="hljs-built_in">adjPix</span>(<span class="hljs-number">1000</span>)) &#123;<br>            hands++;<br>            <span class="hljs-built_in">findPalmCenter</span>(contours[i], center, radius);<br>            <span class="hljs-type">float</span> palm_depth = <span class="hljs-built_in">depthAt</span>(*frm, center);<br>            cv::<span class="hljs-built_in">circle</span>(drawing, center, (<span class="hljs-type">int</span>)radius, <span class="hljs-built_in">Scalar</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">1</span>);<br><br>            <span class="hljs-built_in">findKeyPoints</span>(contours[i], hull, defect, <span class="hljs-built_in">adjPix</span>(<span class="hljs-number">15</span>));<br>            <span class="hljs-built_in">distillHullPoints</span>(contours[i], hull, rhull, <span class="hljs-built_in">adjPix</span>(<span class="hljs-number">10</span>));<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k &lt; rhull.<span class="hljs-built_in">size</span>(); k++) &#123;<br>               <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>)<br>                  cv::<span class="hljs-built_in">line</span>(drawing, contours[i][rhull[k<span class="hljs-number">-1</span>]], contours[i][rhull[k]], <span class="hljs-built_in">Scalar</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>);<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 1</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k &lt; defect.<span class="hljs-built_in">size</span>(); k++) <br>               cv::<span class="hljs-built_in">circle</span>(drawing, contours[i][defect[k]], <span class="hljs-built_in">adjPix</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">Scalar</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            vector&lt;cv::Point&gt; tips;<br>            <span class="hljs-built_in">kCurvature</span>(contours[i], rhull, <span class="hljs-built_in">adjPix</span>(<span class="hljs-number">5</span>), <span class="hljs-built_in">adjPix</span>(<span class="hljs-number">25</span>), <span class="hljs-number">60.0</span>, temp);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k &lt; temp.<span class="hljs-built_in">size</span>(); k++) &#123;<br>          <span class="hljs-comment">//     if (depthAt(*frm, contours[i][temp[k]]) &lt; palm_depth) </span><br>                  tips.<span class="hljs-built_in">push_back</span>(contours[i][temp[k]]);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k &lt; tips.<span class="hljs-built_in">size</span>(); k++) &#123;<br>               cv::<span class="hljs-built_in">circle</span>(drawing, tips[k], <span class="hljs-built_in">adjPix</span>(<span class="hljs-number">4</span>), <span class="hljs-built_in">Scalar</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);<br>            &#125;<br><br></code></pre></td></tr></table></figure><p>在得到物体清晰的轮廓之后，一些应用便非常容易展开，OpenCV拥有大量的应用处理例程可以付之于上。</p><p>handTracking程序连接：</p><p><a href="https://github.com/3dtof/DemoApplications/tree/master/TinTin/hand_tracking">https://github.com/3dtof/DemoApplications/tree/master/TinTin/hand_tracking</a></p><h3 id="关于了解depthFrame的Q-amp-A-refrence"><a href="#关于了解depthFrame的Q-amp-A-refrence" class="headerlink" title="关于了解depthFrame的Q&amp;A refrence"></a>关于了解depthFrame的Q&amp;A refrence</h3><ol><li><a href="https://blog.csdn.net/o_sun_o/article/details/8351037">https://blog.csdn.net/o_sun_o&#x2F;article&#x2F;details&#x2F;8351037</a></li><li><a href="https://blog.csdn.net/mouse8166/article/details/6195047">https://blog.csdn.net/mouse8166/article/details/6195047</a></li><li><a href="https://blog.csdn.net/leixiaohua1020/article/details/12682381">https://blog.csdn.net/leixiaohua1020/article/details/12682381</a></li><li><a href="https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/row-wise-binding?view=sql-server-2017">https://docs.microsoft.com/en-us/sql/odbc/reference/develop-app/row-wise-binding?view=sql-server-2017</a></li><li><a href="https://e2e.ti.com/support/sensors/f/1023/t/666615?tisearch=e2e-sitesearch&keymatch=OPT8241%20MATLAB">https://e2e.ti.com/support/sensors/f/1023/t/666615?tisearch=e2e-sitesearch&keymatch=OPT8241 MATLAB</a></li><li><a href="http://e2e.ti.com/support/sensors/f/1023/p/721965/2703526#2703526">http://e2e.ti.com/support/sensors/f/1023/p/721965/2703526#2703526</a></li><li><a href="http://e2e.ti.com/support/sensors/f/1023/t/730122?tisearch=e2e-sitesearch&keymatch=vxl">http://e2e.ti.com/support/sensors/f/1023/t/730122?tisearch=e2e-sitesearch&keymatch=vxl</a></li><li><a href="https://www.ibm.com/support/knowledgecenter/en/SSEPEK_11.0.0/odbc/src/tpc/db2z_rowwisebind.html">https://www.ibm.com/support/knowledgecenter/en/SSEPEK_11.0.0&#x2F;odbc&#x2F;src&#x2F;tpc&#x2F;db2z_rowwisebind.html</a></li><li><a href="https://www.codeproject.com/Tips/819613/Kinect-Version-Depth-Frame-to-mat-File-Exporter">https://www.codeproject.com/Tips/819613/Kinect-Version-Depth-Frame-to-mat-File-Exporter</a></li><li><a href="https://social.msdn.microsoft.com/Forums/en-US/4da8c75e-9aad-4dc3-bd83-d77ab4cd2f82/common-nui-problems-and-faq?forum=kinectsdk">https://social.msdn.microsoft.com/Forums/en-US/4da8c75e-9aad-4dc3-bd83-d77ab4cd2f82/common-nui-problems-and-faq?forum=kinectsdk</a></li><li><a href="https://social.msdn.microsoft.com/Forums/zh-TW/9aaa03b5-d2c1-46ed-80ad-b4d23882c136/depth-frame-data-format-and-ranges?forum=kinectsdk">https://social.msdn.microsoft.com/Forums/zh-TW/9aaa03b5-d2c1-46ed-80ad-b4d23882c136/depth-frame-data-format-and-ranges?forum=kinectsdk</a></li></ol><hr><p>交流QQ： 365334601</p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>TOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TI-Tintin-OPT8241二次开发和应用系列--Hardware Level</title>
    <link href="/2019/01/13/TOF-dev-Hardware-Level/"/>
    <url>/2019/01/13/TOF-dev-Hardware-Level/</url>
    
    <content type="html"><![CDATA[<h1 id="TI-Tintin-OPT8241二次开发和应用系列–Hardware-Level"><a href="#TI-Tintin-OPT8241二次开发和应用系列–Hardware-Level" class="headerlink" title="TI-Tintin-OPT8241二次开发和应用系列–Hardware Level"></a>TI-Tintin-OPT8241二次开发和应用系列–Hardware Level</h1><h2 id="1-TI-Tintin-TOF-solution-系统介绍"><a href="#1-TI-Tintin-TOF-solution-系统介绍" class="headerlink" title="1.TI-Tintin-TOF-solution 系统介绍"></a>1.TI-Tintin-TOF-solution 系统介绍</h2><p>OPT8241 Evaluation Module，是TI提供的一个TOF深度相机的开发板,如下图所示:</p><p><img src="/../img/TOF-dev-Hardware-Level/hl-1.png"></p><p>这个开发板基本开源了全部内容，硬件电路原理图、PCB图，软件提供了SDK，但是一部分还是保密的。</p><p>根据“TI-Tintin-OPT8241二次开发和应用系列–Theory Level” 介绍，一个TOF深度相机系统，必须包括几个部分，主动光发射模块，接收模块。整个开发板分两层，上面一层是IB（illumination board） ，下面一层是SB（sensor board） 。IB（illumination board） 就是主动光发射模块；SB（sensor board）就是接收模块。</p><h2 id="2-开发板硬件结构框架"><a href="#2-开发板硬件结构框架" class="headerlink" title="2.开发板硬件结构框架"></a>2.开发板硬件结构框架</h2><p>构成开发板的主要芯片由这么几个组成，OPT8241,OPT9221,发射红外模块，如下图所示：</p><p><img src="/../img/TOF-dev-Hardware-Level/hl-2.png"></p><p>OPT82：控制光源发射+反射光接受与处理，作为传感器</p><p>OPT92：接收脉冲与处理，得到深度数据，作为处理器</p><p>红外发射模块:作为OPT82驱动的主动光设备</p><h3 id="更加详细的"><a href="#更加详细的" class="headerlink" title="更加详细的"></a>更加详细的</h3><p>更加详细的硬件结构关系如下图：</p><p><img src="/../img/TOF-dev-Hardware-Level/hl-3.png"></p><p>图中，主要有三个虚线框，蓝色的表示IB ，红色的表示SB ，绿色的表示上位机部分；</p><p>可以看到IB中主要的是发射模块和温度传感器。开发板采用laser LED ; 一些其他公司的产品会采用VCSEL。</p><p>在SB中，主要展示了 OPT8241与OPT9221还有接口芯片（USB FX2LP18）内部的功能模块，还有三者的关系。</p><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>对比“TI-Tintin-OPT8241二次开发和应用系列–Theory Level(2&#x2F;3)”中的相机系统一般组成结构，对应关系如下：</p><p>OPT8241–作为传感器的角色</p><p>OPT9221–作为处理器的角色</p><p>USB FX2LP18–作为接口芯片的角色</p><p>绿色框–作为上位机的角色</p><p>一个主要的数据流向，在上图中已经用了双实线的方向箭头表示了。首先是光进入OPT82传感器中的感光区域（Pixel Array）-&gt; AD Converter-&gt;Output Block -&gt; LVDS seriallizer -&gt; 数据传输到OPT92的LVDS De-seriallizer -&gt;Depth Engine -&gt; Output interface -&gt;USB接口芯片的FIFO -&gt;最后传输给上位机。</p><p>IB 与OPT82的关系： OPT82需要给Driver 发送调制脉冲，并且接收反射回来红外脉冲波并转化为数字信号；</p><p>IB 与OPT92的关系：IB中的温度传感器的温度数据给与OPT92,之后OPT92 计算一个温度补偿，并反馈给IB中的红外发射Driver。因为driver持续工作会产生明显的温度变化，如果不对这个温度变化导致的测量准确度漂移进行补偿，那将是一场灾难；</p><p>OPT82与OPT92的关系：OPT92一方面需要接收OPT82从感光传感器得到的数据(代表物体反射的红外光)，另一方面，OPT92需要知道OPT82调制的脉冲波的频率是多少(代表主动光发射的频率)。这样,OPT92得到了主动光数据与反射光数据，才能在OPT92中的Depth Engine中计算相位差，得到被测物体的距离；</p><p>OPT92与接口芯片的关系：OPT92出来的数据需要存放在接口芯片中的FIFO中，组合队列成一副图像的帧数据，并且按照USB接口通信协议的方式把数据传输给上位机；</p><p>电路原理图构成如下，符合上图的硬件结构框图：</p><p><img src="/../img/TOF-dev-Hardware-Level/hl-4.png"><img src="/../img/TOF-dev-Hardware-Level/hl-5.png"></p><p>放大的OPT8241与OPT9221芯片的内部功能图：</p><p><img src="/../img/TOF-dev-Hardware-Level/hl-6.png"></p><p><img src="/../img/TOF-dev-Hardware-Level/hl-7.png"></p><p>关于开发板更加详细的介绍，请参照 :<a href="http://www.ti.com/tool/TIDA-01173">http://www.ti.com/tool/TIDA-01173</a></p><hr><p>交流QQ： 365334601</p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>TOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TI-Tintin-OPT8241二次开发和应用系列--Theory Level(2/3)</title>
    <link href="/2019/01/13/TOF-theory-2-3/"/>
    <url>/2019/01/13/TOF-theory-2-3/</url>
    
    <content type="html"><![CDATA[<h1 id="TI-Tintin-OPT8241二次开发和应用系列–Theory-Level-2-x2F-3"><a href="#TI-Tintin-OPT8241二次开发和应用系列–Theory-Level-2-x2F-3" class="headerlink" title="TI-Tintin-OPT8241二次开发和应用系列–Theory Level(2&#x2F;3)"></a>TI-Tintin-OPT8241二次开发和应用系列–Theory Level(2&#x2F;3)</h1><p>前言：本篇的主要目的是，以传统RGB相机为例，做入门程度的介绍。在硬件层，介绍相机的一般系统组成；在软件层，简单介绍相机获得的图像数据格式。相机系统与TOF深度相机他们之间有着一定联系，理解相机一般系统对理解深度相机以及各类相机有着巨大的帮助。</p><hr><p>最原始的摄像头模块从过去输出信号为模拟信号，到现在市面上非常常见的输出为数字信号的摄像头模块，并且接上电脑USB接口就可以使用，非常方便。</p><p>这里的RGB相机指的是传统的摄像头模块，在淘宝上、网上搜索资料一大堆。</p><p><img src="/../img/TOF-theory-2-3/2-3-1.png"><br><img src="/../img/TOF-theory-2-3/2-3-2.png"></p><p>在开始之前，最好先了解以下，相机原理与概念，快门、光圈、景深、ISO、视角(FOV）、色域、白平衡等，可以在B站搜索一些视频食用。</p><p><strong>摄像头模块的一般系统组成如下框图：</strong></p><p><img src="/../img/TOF-theory-2-3/2-3-3.png"></p><h2 id="1-硬件层–传统RGB相机"><a href="#1-硬件层–传统RGB相机" class="headerlink" title="1.硬件层–传统RGB相机"></a>1.硬件层–传统RGB相机</h2><p>摄像头是一个提取自然景色的传感器。当自然光进入镜头之后，滤除噪声，感光传感器将光信号转化为模拟电信号，模拟电信号经过处理芯片之后变成数字电信号并且编码成一帧图像信息，再通过接口芯片（例如USB通信接口芯片）将帧图像信息上传到上位机上，上位机还原帧图像信息并显示，最后我们才可以看到数字图像。</p><p>摄像头获取自然景色的信息，这个信息的流向一般是：从右往左</p><p><img src="/../img/TOF-theory-2-3/2-3-4.png"></p><h3 id="各模块简单介绍"><a href="#各模块简单介绍" class="headerlink" title="各模块简单介绍"></a>各模块简单介绍</h3><h4 id="镜头模组"><a href="#镜头模组" class="headerlink" title="镜头模组"></a>镜头模组</h4><p>镜头模组中的镜头材料会有玻璃材料、塑料、半玻璃等等；镜头模组的组要作用是设置光学参数，FOV、焦距、光圈，滤除不想要的光噪声等等。</p><h4 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h4><p>传感器通常有两种，CCD与CMOS 。 CCD（charge-coupled device），CCD的特点是成本比较高、功耗好、效果比较好、像素密度大、低温漂、低噪声；</p><p>CMOS（complementary metal oxide semiconductor），CMOS特点是，成本低、但是功耗较高、像素密度较小、效果较差、相对高噪声。</p><p>但是目前市面上貌似出现了一个趋势，CMOS的成像质量越来越好，可能要赶上CCD，未来可能许多电子产品的摄像头会采用CMOS传感器。</p><h4 id="处理芯片"><a href="#处理芯片" class="headerlink" title="处理芯片"></a>处理芯片</h4><p>主要接收传感器发送的模拟信号，并转化为数字信号。RGB相机可能要计算每一点的色彩值，TOF深度相机中的处理器TFC-OPT9221内部有一个depth engine ,主要计算每一个像素点的深度值。还有在其他的相机系统中，我见过使用DSP\FPGA等做处理器芯片。</p><h4 id="接口芯片"><a href="#接口芯片" class="headerlink" title="接口芯片"></a>接口芯片</h4><p>数据通信方式有许多种，主要有并行、串行方式，类型有USB、火线等等。接口芯片主要作用是，接收到控制器计算后的数据存储在接口芯片的FIFO，并且排列成有序的一帧图像数据，并以特定的图像格式（RGB的图像格式有MJPG,YUY2,RGB8等等）发送给上位机。如果是使用USB接口芯片，则对应的USB协议是UVC（USB video class) 传输协议。</p><p>所以，一个摄像头系统的典型硬件系统组成为：模组+传感器+处理芯片+接口芯片+开发平台。在软件层上的开发平台主要是为了做应用开发，可以是在PC上也可以实在嵌入式上等。<strong>最终，可以说任何一个摄像头系统都符合TCP&#x2F;IP五层模型</strong>，但是我更想这样概括，这个五层模型可以为：硬件层、硬件连接层、驱动层、通信层、应用层。</p><p>硬件层：就是物理层，传感器与处理芯片，接口芯片与上位机等；</p><p>硬件连接层：传感器与处理芯片连接电路，接口芯片与上位机通信连接电缆等；</p><p>驱动层：一些通信协议，USB接口芯片与上位机的一些数据交互、通信。不同的接口芯片有不同的通信协议，不同的时序，不同的方式，同步还是异步。</p><p>通信层：在驱动层之后，控制信息、数据传输策略与分配。</p><p>应用层：就是在通信层得到的数据做应用处理，图像呈现、图像预处理等开发。</p><p><img src="/../img/TOF-theory-2-3/2-3-5.png"></p><p><img src="/../img/TOF-theory-2-3/2-3-6.png"></p><h2 id="2-软件层–图像数据格式"><a href="#2-软件层–图像数据格式" class="headerlink" title="2.软件层–图像数据格式"></a>2.软件层–图像数据格式</h2><p>如果一副彩色图像采用RGB888格式编制，这幅图的每一个像素点都有一个RGB值，也就是说每一个像素点有三个值RED、GREEN、BLUE值的范围在0-255之间构成一个像素点的颜色。这幅图一幅RGB的三通道（通俗的理解，就是有几层单元合成的）的彩色图。</p><p>详见：</p><p>常见数据格式 YUV : <a href="http://www.cnblogs.com/qiqibaby/p/5252414.html">http://www.cnblogs.com/qiqibaby/p/5252414.html</a></p><p>常见数据格式 RGB888 : <a href="https://baike.baidu.com/item/RGB/342517?fr=aladdin">https://baike.baidu.com/item/RGB/342517?fr=aladdin</a></p><hr><p>交流QQ： 365334601</p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>TOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文读懂TOF深度相机技术原理--TI-Tintin-OPT8241二次开发和应用系列--Theory Level(1/3)</title>
    <link href="/2019/01/04/TOF-theory-1-3/"/>
    <url>/2019/01/04/TOF-theory-1-3/</url>
    
    <content type="html"><![CDATA[<h1 id="一文读懂TOF深度相机技术原理–TI-Tintin-OPT8241二次开发和应用系列–Theory-Level-1-x2F-3"><a href="#一文读懂TOF深度相机技术原理–TI-Tintin-OPT8241二次开发和应用系列–Theory-Level-1-x2F-3" class="headerlink" title="一文读懂TOF深度相机技术原理–TI-Tintin-OPT8241二次开发和应用系列–Theory Level(1&#x2F;3)"></a><strong>一文读懂TOF深度相机技术原理–TI-Tintin-OPT8241二次开发和应用系列–Theory Level(1&#x2F;3)</strong></h1><h2 id="1-TOF介绍"><a href="#1-TOF介绍" class="headerlink" title="1.TOF介绍"></a>1.TOF介绍</h2><p><img src="/../img/TOF-theory-1-3/1-3-1.png"></p><p>TOF, 即time of flight ,直译过来就是飞行时间。故名思义，即，测量光在空间中飞行的时间，通过换算成距离，就可以测得深度相机与物体的距离。通常，TOF深度相机组成有一个发射模块，一个接收模块。发射模块可以是LED、激光等发射元件，它将发射例如850nm的调制红外光，物体经过反射后，由接收模块接收到反射的红外光。由于发射和接收的都是调制波，TOF深度相机可以计算发射和接收的相位差，通过换算得到深度值，即深度相机与物体的深度距离。</p><h2 id="2-TOF深度相机-单点测距原理"><a href="#2-TOF深度相机-单点测距原理" class="headerlink" title="2.TOF深度相机-单点测距原理"></a>2.TOF深度相机-单点测距原理</h2><p>一个简易的单点TOF系统组成如下图：</p><p><img src="/../img/TOF-theory-1-3/1-3-2.png"></p><p>它由一个发射二极管、接收二极管、调制模块，解调模块、处理器几部分组成。调制模块负责调制发射的红外调制波，通过发射二极管将信号发射出去；解调模块负责对接受二极管接收到的反射红外波解调；处理器中包含ADC和数据处理，ADC是为了将模拟信号转化为数字信号，具体是什么模拟信号下文将会详细讲述；数据处理为了将测得的相位差换算成深度信息。</p><h2 id="3-TOF深度相机-多点测距原理"><a href="#3-TOF深度相机-多点测距原理" class="headerlink" title="3.TOF深度相机-多点测距原理"></a>3.TOF深度相机-多点测距原理</h2><p>一个完整的TOF深度相机系统组成如下图：</p><p><img src="/../img/TOF-theory-1-3/1-3-3.png"></p><p>它和传统RGB摄像头的组成结构基本相似；</p><p>另外，它与点单的TOF系统比较区别在于，测量范围不是一个点，它是一个面，因此，接收模块变成了点阵的光敏传感器，通常使用的是CMOS传感器；在传感器前面、和发射二极管前面多了光学镜片，一个是为了红外波的辐射范围、一个是为了滤除850nm以外的光线，就是说，要保证进入传感器的光线只是850nm的，这样才能保证测量的准确度。</p><p>因为相位差即代表物体的与摄像头的距离，即深度，由于每个点的相位差不同，所以才能组成有关物体整幅深度图像。</p><h2 id="4-TOF传感器（感光芯片）工作原理"><a href="#4-TOF传感器（感光芯片）工作原理" class="headerlink" title="4.TOF传感器（感光芯片）工作原理"></a>4.TOF传感器（感光芯片）工作原理</h2><p>TOF传感器工作原理中主要有两种，基于脉冲波（paulse base）的技术原理、基于连续调制波（CW）的技术原理。</p><p>在这之前，需要知道解调模块是如何工作的，如何读取感光传感器上面的电荷量。以单点像素的读取测量为例：</p><p><img src="/../img/TOF-theory-1-3/1-3-4.png"></p><p>整个读取测量过程主要分为4个步骤：</p><p><img src="/../img/TOF-theory-1-3/1-3-5.png"></p><p>分别是，Reset;Integration;Readout;Deadtime</p><p>Reset：在上图中看到，Rst开关，在测量电荷量之前，需要将Rst开关闭合，让电容CA与CB充电，充好点之后断开。</p><p>Integration：Integration period ,DMIX0和DMIX1是由解调模块控制的开关，什么时候开关，与调制和解调的频率有关。当光子被感光元件(蓝色圆圈箭头)接收时，并且当DMIX0闭合时，这时候，充好电的电容CA就会和感光元件释放出来的电子中和，电容CA放电，直到中和完毕，最后得到的电容电平代表着接受光子数量和时间的电平。</p><p>Readout：中和完毕之后，Address Decode 开关打开，读取电容上的电平。</p><p>Deadtime：死区时间</p><p>从以上四个环节来看，Integration Time 是最重要的。</p><p>为什么还会有DMIX0和DMIX1？</p><h3 id="基于脉冲波（paulse-base）的技术原理"><a href="#基于脉冲波（paulse-base）的技术原理" class="headerlink" title="基于脉冲波（paulse base）的技术原理"></a>基于脉冲波（paulse base）的技术原理</h3><p>发射模块发射矩形脉冲波，物体发射后具有相位差的脉冲波，测量相位差的方法如下图：</p><p><img src="/../img/TOF-theory-1-3/1-3-6.png"></p><p>发射脉冲可以设定一个频率f，并且开启两个反向的窗口，DMIX0与DMIX1用来接收光子的数量， 一个窗口的频率和相位是与发射脉冲是一致的，另外一个是与DMIX1反向，并且相位差为180。</p><p>在两个窗口打开的时候，也就是高电平的时候，并且这时候存在物体反射过来的脉冲波，这时候两个不同窗口在各自的时间内收集电荷。在图上已经用红色上色表示。假设DMIX0收集到的电荷量为Q0，DMIX1收集到的电荷量为Q1。Q0与Q1相加的这部分就是有反射脉冲时间内收集的电荷量。</p><p>td表示相位差存在的时间，为了计算td，可以通过计算Q1在反射脉冲所占的时间，为了计算Q1这部分的时间，我们可以读取DMIX0与DMIX1窗口上的电平，也就是Q0加Q1与Q1的比值，再乘上发射电平高电平的时间。因此，可以通过式子计算相位差d：</p><p><img src="/../img/TOF-theory-1-3/1-3-7.png"></p><p>注：以上的整个过程称为IntegrationTime</p><h3 id="基于连续调制波（CW）的技术原理"><a href="#基于连续调制波（CW）的技术原理" class="headerlink" title="基于连续调制波（CW）的技术原理"></a>基于连续调制波（CW）的技术原理</h3><p>连续调制波在脉冲波的基础上而来，连续调制波通常是连续正弦波调制，与脉冲不同的是，连续调制波开启了4个窗口分别是C1-C4.如下图所示：</p><p><img src="/../img/TOF-theory-1-3/1-3-8.png"></p><p>由于连续调制波通常是连续正弦波调制，可以将调制波看成是正弦波如下图所示：</p><p><img src="/../img/TOF-theory-1-3/1-3-9.png"></p><p>连续正弦波调制测量方法，推导过程如下。序号1-8对应下图的公式1-8。</p><p>1.        假设发射的正弦信号s(t)振幅是a，调制频率是f</p><p>2.        经过时延 △t后接收到的信号为接收r(t)，衰减后的振幅为A，强度偏移（由环境光引起）为B</p><p>3.        四个采样时间间隔相等，均为T&#x2F;4</p><p>4.        根据上述采样时间可以列出四个方程组</p><p>5.        从而可以计算出发射和接收的正弦信号的相位偏移△φ</p><p>6.        据此可以根据（6）中公式计算物体和深度相机的距离d</p><p>7.        接收信号的衰减后的振幅A的计算结果</p><p>8.        接收信号强度偏移B的计算结果，反映了环境光</p><p><img src="/../img/TOF-theory-1-3/1-3-10.png"></p><p>更加详细的推导过程如下：</p><p><img src="/../img/TOF-theory-1-3/1-3-11.png"></p><p>其实两种基于不同原理的计算相位的方法差不多，连续调制波相对复杂。关于如何推到，更多的是数学的部分，最后计算d公式中，其实表示的含义是一样的，只是符号不同罢了。</p><h2 id="5-两种基于不同测量方法的优缺点分析"><a href="#5-两种基于不同测量方法的优缺点分析" class="headerlink" title="5.两种基于不同测量方法的优缺点分析"></a>5.两种基于不同测量方法的优缺点分析</h2><h3 id="基于脉冲波（paulse-base）的技术原理-1"><a href="#基于脉冲波（paulse-base）的技术原理-1" class="headerlink" title="基于脉冲波（paulse base）的技术原理"></a>基于脉冲波（paulse base）的技术原理</h3><p>优点：</p><p>1. 因为不用计算振幅和环境光，测量方法简单，响应较快，可以提高相机的帧率</p><p>2. 由于脉冲占空比在整个周期中比CW方法要窄很多，所以在理论上设计可以检测更远的距离</p><p>缺点：</p><p>1. 由于没有抵消环境光对测量的影响，所以将会受到环境光的影响。但是可以通过开设一个接收环境光分量的窗口弥补。</p><p>2. 相对于CW的方案，测量精度较低，但也不会低到离谱</p><h3 id="基于连续调制波（CW）的技术原理-1"><a href="#基于连续调制波（CW）的技术原理-1" class="headerlink" title="基于连续调制波（CW）的技术原理"></a>基于连续调制波（CW）的技术原理</h3><p>优点：</p><p>1. 相位偏移（公式5）中的(r2-r0)和(r1-r3)相对于脉冲调试法消除了由于测量器件或者环境光引起的固定偏差。连续调制波使用多个测量窗口，(Q 3 -Q 4 )及(Q 1 -Q 2 )可以减掉测量中的共同成分（复位电压，环境光，电容增益等）及其中的偏差。</p><p>2. 可以根据接收信号的振幅A和强度偏移B来间接的估算深度测量结果的精确程度（方差）。</p><p>3.  不要求光源必须是短时高强度脉冲，可以采用不同类型的光源，运用不同的调制方法</p><p>缺点：</p><p>​​ 1.需要多次采样，测量时间较长，限制了相机的帧率</p><p>2. 因为采集和计算量大，导致在相同成本的产品中，深度分辨率降低</p><h2 id="6-参考文献："><a href="#6-参考文献：" class="headerlink" title="6.参考文献："></a>6.参考文献：</h2><ol><li><p><a href="https://blog.csdn.net/electech6/article/details/78349107">深度相机原理揭秘–飞行时间（TOF）</a></p></li><li><p><a href="http://www.ti.com/sensors/specialty-sensors/time-of-flight/overview.html#design">TI documents</a></p></li></ol><hr><p>转载请注明出处：<a href="https://my.oschina.net/u/4037487/blog/2996798">https://my.oschina.net/u/4037487/blog/2996798</a></p><p>转载请注明出处（旧）：<a href="https://www.cnblogs.com/pans0ul/p/9747441.html">https://www.cnblogs.com/pans0ul/p/9747441.html</a></p><p>交流QQ： 365334601</p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>TOF</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
