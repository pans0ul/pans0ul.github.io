<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux 0.11 内存管理-寻址 Linux 0.11 MMU Addressing Machanism</title>
    <link href="/2023/11/23/Linux-0-11-MMU-Addressing-Machanism/"/>
    <url>/2023/11/23/Linux-0-11-MMU-Addressing-Machanism/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-0-11-内存管理-寻址-Linux-0-11-MMU-Addressing-Machanism"><a href="#Linux-0-11-内存管理-寻址-Linux-0-11-MMU-Addressing-Machanism" class="headerlink" title="Linux 0.11 内存管理-寻址 Linux 0.11 MMU Addressing Machanism"></a>Linux 0.11 内存管理-寻址 Linux 0.11 MMU Addressing Machanism</h1><p>什么是内存管理? <strong>内存管理</strong>，是指<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6" title="软件">软件</a>运行时对计算机<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" title="内存">内存</a>资源的分配和使用的技术。其最主要的目的是如何高效、快速的分配，并且在适当的时候释放和回收内存资源。</p><p>在此之下还有一个关键基础内容需要了解，也就是<strong>寻址</strong></p><p><del>寻址, 是指计算机处理器通过某种特定的规则访问内存或存储器中的数据.</del></p><p>在操作系统中，”寻址”通常指的是处理器或CPU（中央处理器）计算有效地址的过程。以便内存管理或其他程序从内存中读取或写入数据。</p><p>在Linux0.11中, 内存做了分段和分页处理, 由此形成了两种不同的寻址方式.</p><p>下面我会花大量篇幅先把这两种的寻址原理介绍清楚。</p><p>下一期再介绍MMU(Memory Management Unit)。</p><h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>当程序需要访问内存时，操作系统负责将虚拟地址转换为物理地址，这个过程称为地址寻址。通过地址寻址，操作系统能够确保不同程序或进程的内存空间相互隔离，并为每个程序提供独立的虚拟地址空间。这有助于提高系统的安全性和稳定性，同时允许程序使用比实际物理内存更大的虚拟内存空间。</p><p>寻址相当于是程序的访问内存的遵循的规则，程序遵循这个规律，才能正确访问内存。</p><p>用函数表示逻辑地址到物理地址的关系, 见下方</p><p>                                            内存的物理地址&#x3D;f(逻辑地址)</p><p>f(x)在这里是一个寻址规则, 这个规则也称作变换.</p><p>操作系统中一次完整的寻址, 经过段变换(Segment Translation)和页变换(Page Translation). 两种变换的示意图如下 </p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-23-21-24-05-image.png"></p><p>段变换(Segment Translation): 将逻辑地址（虚拟地址）变换为线性地址，如果没有开启分页机制，则变换为物理地址。</p><p>页变换(Page Translation) : 将线性地址变换为物理地址</p><p>一个逻辑地址(LOGICAL ADDRESS)通过一次完整的寻址经过两次变换段变换和页变换. 如果页变换没有开启, 则线性地址(LINEAR ADDRESS)经过段变换的地址直接映射到物理地址(PHYSICAL ADDRESS).</p><p>所以可以总结, 寻址情况有两种</p><ol><li><p>经过一次段变换后实现寻址</p></li><li><p>经过段变换和页变换后实现寻址</p></li></ol><h2 id="段变换寻址"><a href="#段变换寻址" class="headerlink" title="段变换寻址"></a>段变换寻址</h2><p>段变换寻址也称在保护模式下寻址。</p><p>内存是分段的，通过一种机制如何寻址到某一个内存段。</p><h3 id="理论模型呈现"><a href="#理论模型呈现" class="headerlink" title="理论模型呈现"></a>理论模型呈现</h3><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-26-11-56-07-image.png"></p><p>在段变换中, 逻辑地址中选择子(Selector)会指向描述符表(Descriptor Table)的段描述符(Segment Descriptor), 再根据段描述符中记录的基地址与逻辑地址的偏移值(OFFSET)来得到新的地址. </p><p>如果分页机制没有开启, 那么新的地址就是得到物理地址. 否则, 得到的新地址是一个线性地址, 需经过页变换才能得到物理地址. 所述如下图</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-14-16-01-08-image.png"></p><p>这里有几个概念需要澄清一下</p><p>描述符表(Descriptor Table), 是一个数据结构里面设置了多个描述符组成的表单,通常是GDT或者LDT. </p><p>选择子(Selector), 是用于指向描述符表中某一个描述符，其实也是一个偏移值， 所以称作选择子. GDTR 确定了基地址, Selector 确定了偏移值。确定GDT中的某一个描述符。</p><p>段描述符(Segment Descriptor), 用于指向一段已经划分好的内存基地址, 并且还描述了这个内存段的限长等其他信息. </p><p>总之，这里的Selector是GDT的一个偏移值，OFFSET线性地址段的偏移值。所以逻辑地址（Logical address)的构成是两个偏移地址的组合（selector, offset)。</p><p>最终还是符合一个寻址原则：基地址+偏移地址，并且由前一个地址推导出后面一个地址。</p><h3 id="代码呈现"><a href="#代码呈现" class="headerlink" title="代码呈现"></a>代码呈现</h3><p>根据上面的一段论述, 现在已经确认好了模型</p><p>再来看看代码中是如何实现的?</p><p>代码在<strong>Setup.s</strong>中体现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">end_move:<br>    mov    $SETUPSEG, %ax    <span class="hljs-meta"># right, forgot this at first. didn<span class="hljs-string">&#x27;t work :-)</span></span><br><span class="hljs-string"><span class="hljs-meta">    mov    %ax, %ds</span></span><br><span class="hljs-string"><span class="hljs-meta">    lidt    idt_48        # load idt with 0,0</span></span><br><span class="hljs-string"><span class="hljs-meta">    lgdt    gdt_48        # load gdt with whatever appropriate</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">gdt_48:<br>    .word    <span class="hljs-number">0x800</span>            <span class="hljs-meta"># gdt limit=2048, 256 GDT entries</span><br>    .word   <span class="hljs-number">512</span>+gdt, <span class="hljs-number">0x9</span>      <span class="hljs-meta"># gdt base = 0X9xxxx, </span><br>    # <span class="hljs-number">512</span>+gdt is the real gdt after setup is moved to <span class="hljs-number">0x9020</span> * <span class="hljs-number">0x10</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">gdt:<br>    .word    <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>        <span class="hljs-meta"># dummy</span><br><br>    .word    <span class="hljs-number">0x07FF</span>        # <span class="hljs-number">8</span>Mb - limit=<span class="hljs-number">2047</span> (<span class="hljs-number">2048</span>*<span class="hljs-number">4096</span>=<span class="hljs-number">8</span>Mb)<br>    .word    <span class="hljs-number">0x0000</span>        <span class="hljs-meta"># base address=0</span><br>    .word    <span class="hljs-number">0x9A00</span>        <span class="hljs-meta"># code read/exec</span><br>    .word    <span class="hljs-number">0x00C0</span>        <span class="hljs-meta"># granularity=4096, 386</span><br><br>    .word    <span class="hljs-number">0x07FF</span>        # <span class="hljs-number">8</span>Mb - limit=<span class="hljs-number">2047</span> (<span class="hljs-number">2048</span>*<span class="hljs-number">4096</span>=<span class="hljs-number">8</span>Mb)<br>    .word    <span class="hljs-number">0x0000</span>        <span class="hljs-meta"># base address=0</span><br>    .word    <span class="hljs-number">0x9200</span>        <span class="hljs-meta"># data read/write</span><br>    .word    <span class="hljs-number">0x00C0</span>        <span class="hljs-meta"># granularity=4096, 386</span><br></code></pre></td></tr></table></figure><p>上方的几段代码执行后, 完成了工作如下图所示</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-24-13-26-46-image.png"></p><p>lgdt命令将gdt_48 的数据结构加载到GDTR中, GDTR是一个位于CPU内的寄存器。 48bit 和 数据结构是取决于GDTR的大小和结构. ( 数据结构为 32bit 基地址 | 16bit 段限长。)  限长设置0x800 . </p><p>GDT中包含 256 GDT entries, 但是只是用了3个entries .  第一项 为 空 ； 第二项为 code ; 第三项为data。</p><p>gdt 变量是一个地址。512+gdt 是移动后的gdt基地址. </p><p>在完成上述的初始化配置后, CPU的寻址过程就是 通过读取GDTR的高32bit找到GDT, 根据GDT中的描述符GD entry 的基地址找到对应的内存段, 在结合offset偏移值, 最后获取到数据. 如下图所示.</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-12-19-08-image.png"></p><p>Segment Descriptor 段描述符是一个64bit数据结构的描述符，数据结构定义如下</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-14-16-24-19-image.png"></p><h3 id="为什么需要段机制-保护模式"><a href="#为什么需要段机制-保护模式" class="headerlink" title="为什么需要段机制(保护模式)?"></a>为什么需要段机制(保护模式)?</h3><p><strong>实模式寻址VS保护模式寻址</strong></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-05-30-11-09-43-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-05-30-11-09-56-image.png"></p><p>从上方描述，“索引值”包含 内存段的基地址 ，段的最大长度值和段的访问级别。因为有这几个参数，内存访问都遵循着这个规律，所以保护了其他的内存段，程序访问时不会超过其他内存边界，不会影响到其他的内存。另外还有访问时的权限，说明只有特定的程序访问特定的内存段，所以也起到了保护作用。</p><p>保护模式寻址 需要通过一个段描述符(设置了寻址的属性)，作为映射到物理地址的一个中间手续。</p><p>举一个不恰当的例子。就像用户作为CPU，要想存钱和取钱需要经过银行柜台的认证和许可才可以取钱。这里的银行柜台就是中间手续.</p><p>银行柜台能够对银行中的钱起到保护作用；相当于描述符能够对内存起到保护作用。</p><p>银行柜台会告诉你不同身份的用户可以存取多少钱，也就是描述符会告诉你内存段的限长。银行柜台再你取钱时会确定你的身份信息, 如果另外一个人来取钱，肯定是不允许的。对于不同身份不同级别的程序，对内存的操作权限也是不同的。</p><p>相对于实模式，连银行柜台都没有，可以直接获取金库的钱。所以这很不安全。</p><h2 id="页变换寻址"><a href="#页变换寻址" class="headerlink" title="页变换寻址"></a>页变换寻址</h2><h3 id="为什么需要分页机制"><a href="#为什么需要分页机制" class="headerlink" title="为什么需要分页机制?"></a>为什么需要分页机制?</h3><p>我们看到，分段管理机制已经提供了很好的保护机制，那为什么还要加上分页管理机制呢？其实它的主要目的在于实现虚拟存储器（虚拟内存）。线性地址中任意一个页都能映射到物理地址中的任何一个页，这无疑使得内存管理变得相当灵活。</p><p>虚拟内存允许程序使用比实际物理内存更大的内存空间，同时具有以下特点：</p><ol><li>虚拟内存空间的大小可以超出物理内存空间大小。</li><li>通过操作系统的管理和调用，虚拟内存和物理内存之间的映射关系可以变化。</li></ol><p>因此，虚拟内存提供了一种灵活的内存管理方式，使得不同的进程之间彼此独立，使得某一个进程在执行时看起来拥有独立的地址空间，避免了不同进程的地址冲突问题。而线性地址空间则是实现虚拟内存机制的方式，它为程序提供了一种连续的地址空间，使得程序看起来具有独立的地址空间，与其他的程序和操作系统本身隔离开来。</p><h3 id="理论模型呈现-1"><a href="#理论模型呈现-1" class="headerlink" title="理论模型呈现"></a>理论模型呈现</h3><p>页变换是将线性地址转化为物理地址，将线性地址空间转化为物理地址空间</p><p> 线性地址来源是由逻辑地址经过段变换后得到的</p><p>一个线性地址组成 如下 </p><p>DIR | PAGE | OFFSET </p><p>DIR 包含页目录表项(PDT entry)的地址，也就是页目录表的偏移地址</p><p>PAGE 包含页表项(PT entry)的地址，也就是页表的偏移地址</p><p>OFFSET 包含内存页(4K)的偏移地址</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-23-22-04-45-image.png"></p><p>这张图表示如何通过线性地址寻址到物理地址的. 首先将线性地址拆分成三块分别是DIR, PAGE, OFFSET. </p><p>CR3是属于CPU中的寄存器包含着某个页目录表(PDT)的基地址, 而DIR则可以进一步地确认PDT中具体使用到哪个页目录项(PD entry)</p><p>页目录项(PD entry)包含着某个页表的基地址, 而线性地址中的PAGE则可以进一步地确定具体是哪个页表项</p><p>页表项中包含着某个内存分页（PAGE FRAME或者称为页帧）的基地址, 而OFFSET偏移值则可以进一步地确定内存分页中具体的内存地址.</p><p>总的来看, 不管是段变换还是页变换，寻址依旧是遵守一个原则就是, 基地址+ 偏移值，并且由前面一个推导出后面一个。</p><h3 id="代码呈现-1"><a href="#代码呈现-1" class="headerlink" title="代码呈现"></a>代码呈现</h3><p>说完了分页机制寻址模型, 接下来看看代码是如何实现的</p><p>关于分页的工作主要在代码文件head.s中, 整个代码文件主要完成的工作有:</p><p><strong>head.s</strong>做了什么工作</p><ol><li><p>从这里开始,内核完全都是在保护模式下运行了</p></li><li><p>加载各个数据段寄存器,重新设置中断描述符表 idt</p></li><li><p>然后重新设置全局描述符表 gdt</p></li><li><p>设置管理内存的分页处理机制</p></li><li><p>紧随后面放置共可寻址 16MB 内存的 4 个页表,并分别设置它们的表项</p></li></ol><p>从以上来看, 与分页机制相关的工作是3,4,5几个步骤. 工作内容3其实已经在分段机制阶段说明了, 不再赘述. 4和5工作内容详细展开来讲讲. 下面关于页变换实现的步骤陈述如下</p><p>第一步: 页目录表和页表初始化</p><p>为1个页目录表和 4 个页表（为了能够索引 16MB 内存空间）在内核中申请空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nasm">....<br>pg_dir:<br>....<br>/*<br> * I put the kernel page tables right after the page directory,<br> * using 4 of them to span 16 Mb of physical memory. People with<br> * more than 16MB will have to expand this.<br> */<br>.org 0x1000<br>pg0:<br><br>.org 0x2000<br>pg1:<br><br>.org 0x3000<br>pg2:<br><br>.org 0x4000<br>pg3:<br><br>.org 0x5000<br></code></pre></td></tr></table></figure><p>第二步: 清空页目录表和 4 个页表的内容。如代码 201~204 行所示</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-15-41-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-16-17-image.png"></p><p>第三步: 设置页目录表项映射4个页表</p><p>内核中我们设置了4个页表, 所以我们需要在页目录表中设置4个页目录项来索引它们. 如代码205 ~ 208 行所示. 第一个页表所在的线性地址为0x1000, 赋予第一个页表的属性为0x7, 表示该页存在, 可读可写. 由于每个页目录项大小为4B, 故pg_dir+4可以跳转到下一个页目录项.</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-20-38-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-51-08-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-52-44-image.png"></p><p>第四步: 对页表中的每项映射内存分页地址</p><p>设置每个页表中的页表项。每个页表大小为 4*1024B（标识物理页号范围：0-0xfff），如代码 209~214 行所示。<code>pg3+4092</code> 表示从最后一页的最后一个页表项开始填起，填写的内容为<strong>该页表项所映射的物理内存页号以及该页的属性0x7</strong>，将循环判断变量 eax 减去 4K，继续设置下一页表项，直至零，表示已将 4096 个页表项填写完毕，即 16M 内存分页完毕。<img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-56-14-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-59-32-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-17-59-52-image.png"></p><p>第五步: 设置CR3映射到页目录表和设置CR0开启分页机制</p><p>设置页目录表的起始地址. 将页目录表起始地址赋予CR3寄存器, 如代码216-217行所示. 开启分页机制. 如代码218 - 221 行所示, 将CR0寄存器的最高位设置为1来开启分页机制.</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-06-25-18-01-29-image.png"></p><p>总结：经过以上几个步骤之后，配置好了以下几个方面：<br>1.CR3指向页目录表<br>2.页目录表中的页目录项指向4个页表<br>3.页表中的页表项指向内存寻址空间（以4K分隔）  </p><h1 id="运行和调试"><a href="#运行和调试" class="headerlink" title="运行和调试"></a>运行和调试</h1><h2 id="线性地址到物理地址"><a href="#线性地址到物理地址" class="headerlink" title="线性地址到物理地址"></a>线性地址到物理地址</h2><p>在分页模式下，线性地址到物理地址的过程会涉及：</p><p>CR3 – Page DIR – Page DIR Entry – Page Table – Page Table Entry – Frame Page (physical address)</p><p>主要是想查看相关变量和寄存器，看下是否符合理论并且能够加深理解</p><p>通过Bochs 虚拟机，并输入相关指令可以查看寄存器和变量</p><ol><li><p>查看CR3寄存器</p><p>CR3寄存器中设置了页目录的基地址</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-16-19-38-11-image.png"></p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-16-19-37-44-image.png"></p><ol start="2"><li><p>查看Page DIR</p><p>按照理论，CR3的寄存器地址就是Page DIR</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-16-19-47-42-image.png"></p><p>通过上图的指令，可以查看几个页目录表的地址内容。从代码里面可以看到主要设置了4个页目录表。基本上与上方的显示结果对应。</p><p>第一个Page DIR ： 0x1027   &#x3D; 0x1000 + 0x27 </p><p>0x1000是Page Table的地址， 0x27 是关于设置页的属性。</p></li><li><p>查看Page Table</p><p>通过相同的方法查看内存地址0x1000得到的值是0x800000.这正好是一个FRAME PAGE的地址。内存寻址空间的最大在0xFFFFFF</p></li></ol></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>通过调试查看线性地址到物理地址寻址过程相关的地址。对代码有了 更深的理解。回顾一下线性地址组成</p><p>                                            DIR | PAGE | OFFSET</p><p>LINEAR ADDRESS: 0x0(+DIR) – 0x1000(+PAGE) – 0x800000(+offset)<br>假设线性地址的偏移地址都是零，用（0，0，0）来表示。所以这个线性地址得到的最终物理地址是0x800000。</p><p>如果线性地址LINEAR ADDRESS: (1,14,25)，那么最终计算结果也就前一个地址加上该位置的偏移地址后，最终推导出物理地址。而线性地址中的每一位其实是与之相对应容器的偏移值。DIR是PAGE DIR的偏移值；PAGE是PAGE TABLE的偏移值; OFFSET是FRAME PAGE的偏移值。</p></li></ol><h2 id="逻辑地址（虚拟地址）到线性地址"><a href="#逻辑地址（虚拟地址）到线性地址" class="headerlink" title="逻辑地址（虚拟地址）到线性地址"></a>逻辑地址（虚拟地址）到线性地址</h2><p>在分段模式下，逻辑地址到线性地址的过程会涉及：</p><p>GDTR – Descriptor Table – Segment Descriptor – 线性地址</p><ol><li><p>查看GDTR </p><p>在bochs中输入sreg可以查看到gdtr保存的地址, 这个0x5cb8就是指向Descriptor Table的地址</p></li></ol><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-17-22-05-03-image.png"></p><ol start="2"><li><p>查看Descriptor Table与Segment Descriptor</p><p>通过x查看某内存地址的值. 0x5cb8是gdt的基地址, +8 可以查看下一个Descriptor , 一次查看几个Descriptors, 验证一下是否与书上, 代码上的是否一致. </p><p>移动后的GDT,如下图所示：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-20-21-10-23-image.png"></p></li></ol><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-21-22-19-06-info%20gdt.png"></p><p>查看相同地址，在bochs下的显示结果：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-20-21-31-14-image.png"></p><p>查看相同地址，在qemu下的显示结果：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-17-22-22-12-image.png"></p><p>查看理论上移动后的GDT基地址：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/2023-08-17-22-16-17-image.png"></p><p>分段寻址参考：</p><p><img src="/../img/Linux-0-11-MMU-Addressing-Machanism/segment-ma.jpg"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><p>因为Segment descriptor的数据结构是64bit(8B), 所以base+8可以找到下一个descriptor</p></li><li><p>通过qemu和bochs打印的descriptor会不一样，但是和理论的大差不差。</p></li><li><p>descriptor最后寻址到的是线性地址。如果没有开启分页模式那实际上就是物理地址。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.oldlinux.org/download/clk011c-3.0.pdf">Linux  内核完全注释</a></p><p><a href="https://weread.qq.com/web/bookReview/list?bookId=eb432a1059346feb43178b3">Linux 内核设计的艺术</a></p><p><a href="https://zhuanlan.zhihu.com/p/67714693?utm_id=0">segmentation和保护模式（二）</a></p><p><a href="https://juejin.cn/post/7084117128508342302">深入理解Linux内核虚拟内存原理与实现 - 掘金</a></p><p><a href="https://juejin.cn/post/6976168717142982693">【Linux 0.11】第十三章 内存管理 - 掘金</a></p><p><a href="https://datasheetspdf.com/datasheet/I386.html">I386 Datasheet | Intel - Datasheetspdf.com</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>MMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC: openharmony与android有多相似/IPC: how similar between openharmony and android</title>
    <link href="/2022/07/09/IPC-how-similar-between-openharmony-and-android/"/>
    <url>/2022/07/09/IPC-how-similar-between-openharmony-and-android/</url>
    
    <content type="html"><![CDATA[<h1 id="IPC-openharmony与android有多相似-x2F-IPC-how-similar-between-openharmony-and-android"><a href="#IPC-openharmony与android有多相似-x2F-IPC-how-similar-between-openharmony-and-android" class="headerlink" title="IPC: openharmony与android有多相似&#x2F;IPC: how similar between openharmony and android"></a>IPC: openharmony与android有多相似&#x2F;IPC: how similar between openharmony and android</h1><p>通过本篇文章 你会发现 在IPC这块的代码和架构设计 . openharmony（以下简称oh）与android 有相当大程度的相似性</p><p>可能有人会认为oh是在抄袭android, 所以给予oh负面的评价.</p><p>本篇的主要目的 不是为了贬低oh或者国人os, 只是从技术角度展示oh的真实情况. 至于什么样的评价,取决于其他人加入了什么样的想法.</p><p>科学技术代表智慧, 智慧没有国界 更没有界限 , 都是人类智慧的结晶</p><p>好了开始正文</p><h2 id="IPC-介绍"><a href="#IPC-介绍" class="headerlink" title="IPC 介绍"></a>IPC 介绍</h2><p>Binder-IPC 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。<br>从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。</p><h2 id="工作逻辑"><a href="#工作逻辑" class="headerlink" title="工作逻辑"></a>工作逻辑</h2><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/workcircle.png" alt="IPC-binder工作流程"></p><ol><li>以上这种工作逻辑来源于android的分析资料, 通过阅读oh的代码后,发现这张图也同样适用.</li></ol><h2 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a>架构方面</h2><p><strong>android</strong></p><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/arch-android.png" alt="android-binder 架构"></p><p><strong>openharmony</strong></p><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/arch-oh.png" alt="oh-binder 架构"></p><ol><li>以oh3.1为例,整理了oh-IPC的类关系图,再经过整理、删减，可以发现类的关系架构图能够和android的相对应.</li></ol><h2 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面"></a>代码方面</h2><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/stack.jpg" alt="层级关系"></p><p><img src="/../img/IPC-how-similar-between-openharmony-and-android/code.jpg" alt="代码对比"></p><ol><li>android-IPC中的IPCThreadState与oh-IPC的BinderInvoker存在对应关系</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>以上对比了openharmony与android的架构,层级,工作逻辑还有代码. 他们基本上是差不多的. 可以说在以上展示的代码片段中, 基本一样，只是换掉了不同的名称</li><li>要说为什么要这样. 这个取决于他们都选用了同一个IPC-binder的通信框架. 技术框架一旦确定，整体方面一般不会发生变化。最多修改的是一些枝叶</li><li>在项目和产品开发中，技术选型至关重要。一旦确定后，后面的开发工作都是会围绕和基于这个选型展开</li><li>对于openharmony的评价，虽然上面有很多android 的影子，但是oh自身具备了一些android不具备的功能和特点. 例如HDF驱动框架</li><li>binder原本是一个开源项目, 不能将binder与某种操作系统绑定起来。只是这两种操作系统都采用了binder-IPC方式</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>书名：深入解析Android 5.0系统 作者：刘超 </li><li>书名：Android的设计与实现：卷Ⅰ 作者：杨云君</li><li><a href="https://gitee.com/openharmony/communication_ipc?_from=gitee_search">openharmony ipc</a></li><li><a href="http://gityuan.com/2015/10/31/binder-prepare/">Binder系列—开篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>IPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>团队周例会开展心得 comprehension of team weekly report</title>
    <link href="/2022/07/03/comprehension-of-team-weekly-report/"/>
    <url>/2022/07/03/comprehension-of-team-weekly-report/</url>
    
    <content type="html"><![CDATA[<h1 id="团队周例会开展心得-comprehension-of-team-weekly-report"><a href="#团队周例会开展心得-comprehension-of-team-weekly-report" class="headerlink" title="团队周例会开展心得 comprehension of team weekly report"></a>团队周例会开展心得 comprehension of team weekly report</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>亲身经历,目前所在公司,几千人下的一个十几人的团队中<br>每次周例会将要长达1个小时多<br>每个人对自己做的事情做一些描述,基本这样就结束了<br>大多数人多是在做流水账<br>团队leader给出一些点评和建议这样就结束了<br>而且每周都是这样<br>周例会开得不痛不痒<br>团队的效率和协作潜力根本没有激发出来<br>这样的团队怎么能够帮助公司保质保量的完成项目?</p><h2 id="这种周例会方式是有问题的"><a href="#这种周例会方式是有问题的" class="headerlink" title="这种周例会方式是有问题的"></a>这种周例会方式是有问题的</h2><p>目前的周例会方式,存在一些问题：</p><ol><li>没有将团队目标和团队计划传达到团队中的每一个人. 有的团队管理方式,可能只有团队leader自己知道目标和计划,但是没有传达到其他成员上去。导致每周开始行动之前,每位团队成员没有各自的每周目标,而且没有计划。我们团队leader也不会有要求。先说如果团队目标没有传达到每一个团队成员上并且和大家达成共识,如何凝聚团队的心呢?团队的力量一定是分散的.</li><li>在以上这种情况下,团队leader委派任务也没有时间要求,只是说这块由谁来做,给出了单单从leader角度一个任务分配责任人表就完事了. 没有和团队成员确认,是否适合做这件事情.有些团队成员脾气好一点可能直接就答应了, 不敢有其他意见. 但是内心还是有想要去做他感兴趣的事情. 在工作中和一位同事交流后才知道, 他更想做偏图像方面的开发.但是他目前在做的是系统的其他模块, 但是却没有敢和团队leader提.</li><li>团队成员大多在周报上写下的内容, 都是本周做了什么的一个描述, 流水账式的. 没有体现本周是否达成了目标, 或者获得了什么进展.或者遇到了哪些困难, 哪些风险(没有目标和计划的话,风险就无从谈起)。</li><li>没有人提建议。没有对团队中所做的事情,对达到目标偏差所造成的原因进行分析,从而做改进.</li></ol><p>周例会只是冰山一角。从周例会的一些问题来看,团队的效率不高,没有发挥团队协作的潜力.<br>从而带来的就是团队成员经常性的加班,而且那些效率高的人还要陪着效率低的人一起加班.<br>因为效率不高,公司还觉得一些员工在混加班费的…</p><h2 id="对于这些团队协作上的苦涩-整理了一些自己的看法-心得和建议"><a href="#对于这些团队协作上的苦涩-整理了一些自己的看法-心得和建议" class="headerlink" title="对于这些团队协作上的苦涩,整理了一些自己的看法,心得和建议"></a>对于这些团队协作上的苦涩,整理了一些自己的看法,心得和建议</h2><ol><li>在团队开始行动之前，需要和团队成员们对团队目标达成共识（认识到目标的意义）。需要组织一个团队会议去陈述这个目标。在会议开始之前，团队leader应该有一个自己的初步规划。任务的划分，每个子任务的责任人，时间计划等等。</li><li>团队leader委派任务和团队成员需要相互确认。确认是否有什么大的问题，如果没有特别严重的问题，团队成员接收任务之后，对任务做工作量评估，将评估结果反馈给团队leader。团队leader来看这件事情是否在团队计划内.</li><li>团队成员对任务规划自己的每周目标。下次在周例会上便可反馈是否达到了本周目标，如果没有困难，就可以反馈出来，然后就可以知道，在执行过程中，需要什么支持，依赖什么资源，需要谁的帮助。这样团队才能相互协作起来，发挥团队的协作效率，1+1&gt;2。</li><li>通过协作工具，发挥团队协作潜力。团队成员中每个人的擅长点、模块学习的累积和团队成员的每周目标应该体现在团队协作表格上，大家都能够看到的。这样团队成员就可以知道其他人在做哪些事情，擅长什么，团队下运行的过程中，成员们自己可以找相应的人寻求帮助，不用等着团队leader来协调资源。否则，没有协作的团队，一件事情每个人都要重新学习一边，一个问题对于新入手的人来说可能需要一天，对于擅长的人来说，只用10分钟就可以搞定。</li><li>一个成熟的团队不是一天两天，也不是一周两周建设起来的，需要不断的修正和打磨。团队需要在周例会上对本周的工作进行回顾和总结。对于达成目标的进行鼓励。对于，未达成目标的，分析原因，做出调整。团队或团队成员为什么没有达到目标，原因是什么，我们应该做什么调整。团队成员首先可以从自己着手的事情来提出可以调整的行动方针。<br>举个例子，我本周没有达到目标的原因是因为，处理一个系统上的问题，这个问题一直跟踪到了内核上，内核这块虽然不是我擅长的，但是我想自己搞定，结果花费了太多时间，没想到搞定这个问题之后，还会有其他内核问题。如果我能够求助其他队友，他应该就能很快能够搞定。所以，可以总结，我的下次行动建议是，如果遇到我一个不熟悉的领域，并且已经花费了少部分时间也没有搞定，这个时候应该求助于其他人。<br>这样的团队总结不是一个批斗会，而是帮助团队优化，促使每位团队成员一起成长的方法。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>team</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS Lifetime</title>
    <link href="/2022/06/26/OS-Lifetime/"/>
    <url>/2022/06/26/OS-Lifetime/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-Lifetime-x2F-OS-生命周期"><a href="#OS-Lifetime-x2F-OS-生命周期" class="headerlink" title="OS Lifetime &#x2F; OS 生命周期"></a>OS Lifetime &#x2F; OS 生命周期</h1><p><img src="/../img/OS-Lifetime/OS-lifetime-Page-1.jpg" alt="OS Lifetime"></p><p><strong>操作系统生命周期 主要包含几个阶段</strong></p><p>简单描述</p><ul><li><p>重生&#x2F;Reborn :  描述一个操作系统是如何诞生的.通过用户的反馈,功能增加,性能优化,BUG修复等,不断迭代出更加完善的操作系统.</p></li><li><p>部署&#x2F;Deployment : 描述操作系统软件是如何被部署安装在不同的硬件机器上.</p></li><li><p>维护&#x2F;Maintenance : 描述OS操作系统在使用的过程中,后端工程师是如何维护和持续提升操作系统的.</p></li><li><p>优化&#x2F;Optimize : 描述OS操作系统如何通过维护方法得到优化的.</p></li></ul><p>他们是一个周期循环,是一个整体</p><h2 id="重生-x2F-Reborn"><a href="#重生-x2F-Reborn" class="headerlink" title="重生&#x2F;Reborn"></a>重生&#x2F;Reborn</h2><ol><li>一个OS镜像的组成.通常是bootloader,kernel,rootfs,oem(apps,license,repo等)组成</li><li>通过镜像制作工具(例如mkiso)可生成.img或者.iso等镜像文件</li><li>bootloader对于X86来说的是bios+grub;对于arm等嵌入式架构来说通常是fastboot等</li><li>kernel 直接获取上游开源的即可.kernel 也有针对不同平台的版本,有专门针对arm架构的,比x86架构的kernel要小的许多</li><li>rootfs的制作可以使用debootstrap,buildroot,yocto等工具直接可以构建出一个rootfs.img. debootstap 通常是使用上游debian构建好最小rootfs,方便oem定制</li><li>oem 或者不同的Linux发行版通常对桌面环境(desktop environment),仓库源,认证和证书方式做了定制. 但是底层还是借用上游的.</li><li>由于工程师手动去构建OS比较麻烦,是过程自动化,借用CI&#x2F;CD工具–jenkins实现.</li></ol><h2 id="部署-x2F-Deployment"><a href="#部署-x2F-Deployment" class="headerlink" title="部署&#x2F;Deployment"></a>部署&#x2F;Deployment</h2><ol><li>构建好系统镜像之后,就可以部署到不同的机器上了,主流x86和ARM.</li><li>对于X86来说, 通常刻在CD光碟上或者使用Udisk制作镜像盘,制作镜像盘后就可以给机器安装系统了. 在批量生产上,为了提高效率,通常使用PXE链接网络文件系统(NFS)的方式,进行批量部署安装机器</li><li>对于ARM来说,通常烧录的方式将镜像烧录到ROM中,并且前提已经做好了分区.(在X86中,通常是在安装的时候,才做的分区)</li></ol><h2 id="维护-x2F-Maintenance"><a href="#维护-x2F-Maintenance" class="headerlink" title="维护&#x2F;Maintenance"></a>维护&#x2F;Maintenance</h2><ol><li>操作系统架构设计时,已经考虑到了系统的后续维护,为了应对各种紧急情况.例如数据丢失与保护,或者系统变砖无法开机等等</li><li>对于数据丢失,系统有备份功能,将数据拷贝到备用的分区建立还原点,但下次不小心把数据搞丢时,可以通过恢复功能还原到原来的时间点.</li><li>对于系统变砖或者开不了机,系统背后存在另外一个备份系统,这个备份系统可以覆盖正在使用的系统使系统恢复正常. 这里的机制称为SLOT AB.可以用于系统升级,恢复还原等.</li><li>系统将来需要升级,也可以静默升级,因为存在另外一个备用系统,可以升级这个备用系统,而不影响目前系统的使用,下次重启之后,就可以直接使用升级后的系统.</li><li>升级也具备多种模式.例如全量升级(full update) , 差分升级(diff update) .差分升级更加适合在arm嵌入式操作系统的场合,因为磁盘资源有限. OTA升级方式包含以上两种方式.</li><li>对于后端工程师来说,系统出现了bug需要借助一系列维护工具分析问题的原因所在,从现象层面,定位到模块原因,再定位到代码原因,最后修正代码,重新提交到gitlab或者gerrit.</li></ol><h2 id="优化-x2F-Optimize"><a href="#优化-x2F-Optimize" class="headerlink" title="优化&#x2F;Optimize"></a>优化&#x2F;Optimize</h2><ol><li>通过用户的反馈,功能增加,性能优化,BUG修复等,不断迭代出版本的操作系统.</li><li>操作系统也是代码,修正代码后,提交到gitlab和gerrit进行审核.</li><li>审核通过后Code Merge到代码分支中(片段代码融入了整体)</li><li>最后还是由jenkins自动化工具构建生成新一轮的操作系统.</li></ol><p>周而复始…</p>]]></content>
    
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ANN vs Hash Table</title>
    <link href="/2020/07/08/ANNvsHashTable/"/>
    <url>/2020/07/08/ANNvsHashTable/</url>
    
    <content type="html"><![CDATA[<h1 id="ANN-artificial-neural-network-VS-Hash-Table"><a href="#ANN-artificial-neural-network-VS-Hash-Table" class="headerlink" title="ANN( artificial neural network ) VS Hash Table"></a>ANN( artificial neural network ) VS Hash Table</h1><p>The story began that when I reviewed Hash table in Data Structure lesson and I saw the figure of Hash table principle ,suddenly , a idea comes to my mind that there’s somehow relationship between ANN(artificial neural network ) and  Hash Table .</p><h2 id="What’s-the-relationship"><a href="#What’s-the-relationship" class="headerlink" title="What’s the  relationship ?"></a>What’s the  relationship ?</h2><p><img src="/../img/ANNvsHashTable/ann.png" alt="figure of ANN"></p><p><img src="/../img/ANNvsHashTable/hash.png" alt="figure of Hash table"></p><p>We could notice that both two figures have three part : the left ,the middle ,the right ; Actually , each part of the middle is function part . The only difference between these is that the function of ANN is trained by tons of data and the function of Hash table ,called hash function ,is designed by manual actions usually .</p><p>The former funciton is unknown ,black box .But the later function is known ,white box .</p><h3 id="About-the-history"><a href="#About-the-history" class="headerlink" title="About the history"></a>About the history</h3><h4 id="Hash-function"><a href="#Hash-function" class="headerlink" title="Hash function"></a>Hash function</h4><blockquote><p>The term “hash” offers a natural analogy with its non-technical meaning (to “chop” or “make a mess” out of something), given how hash functions scramble their input data to derive their output.[20] In his research for the precise origin of the term, Donald Knuth notes that, while Hans Peter Luhn of IBM appears to have been the first to use the concept of a hash function in a memo dated January 1953, the term itself would only appear in published literature in the late 1960s, on Herbert Hellerman’s Digital Computer System Principles, even though it was already widespread jargon by then.[21]</p></blockquote><h4 id="ANN"><a href="#ANN" class="headerlink" title="ANN"></a>ANN</h4><blockquote><p>Warren McCulloch and Walter Pitts[4] (1943) opened the subject by creating a computational model for neural networks.[5] In the late 1940s, D. O. Hebb[6] created a learning hypothesis based on the mechanism of neural plasticity that became known as Hebbian learning. Farley and Wesley A. Clark[7] (1954) first used computational machines, then called “calculators”, to simulate a Hebbian network. Rosenblatt[8] (1958) created the perceptron.[9] The first functional networks with many layers were published by Ivakhnenko and Lapa in 1965, as the Group Method of Data Handling.[10][11][12] The basics of continuous backpropagation[10][13][14][15] were derived in the context of control theory by Kelley[16] in 1960 and by Bryson in 1961,[17] using principles of dynamic programming.</p></blockquote><p>According to these history , the first ANN came out at 1943 and the first concept of hash function came out at 1953 . The time between these are so close , it can’t be wasn’t somehow relationship in there !!</p><h2 id="What’s-role-of-Hash-table-played-in-Data-Structure"><a href="#What’s-role-of-Hash-table-played-in-Data-Structure" class="headerlink" title="What’s role of Hash table played in Data Structure ?"></a>What’s role of Hash table played in Data Structure ?</h2><blockquote><p>In computing, a hash table (hash map) is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index, also called a hash code, into an array of buckets or slots, from which the desired value can be found. During lookup, the key is hashed and the resulting hash indicates where the corresponding value is stored.</p></blockquote><h3 id="Why-Hash-table-called-“Hash-table-“"><a href="#Why-Hash-table-called-“Hash-table-“" class="headerlink" title="Why Hash table called “Hash table “?"></a>Why Hash table called “Hash table “?</h3><p>I supposed Hash is people’s name who invented Hash function and Hash table . But actually , it wasn’t . </p><p><a href="https://softwareengineering.stackexchange.com/questions/108124/why-it-is-called-hash-table-or-hash-function-hash-doesnt-make-any-sense-t">Why it is called “hash table”, or “hash function”? </a></p><h2 id="What’s-role-of-ANN-played-in-Machine-Learning"><a href="#What’s-role-of-ANN-played-in-Machine-Learning" class="headerlink" title="What’s role of ANN played in Machine Learning ?"></a>What’s role of ANN played in Machine Learning ?</h2><blockquote><p>Artificial neural networks (ANN) or connectionist systems are computing systems vaguely inspired by the biological neural networks that constitute animal brains.</p></blockquote><blockquote><p>The data structures and functionality of neural nets are designed to simulate associative memory. Neural nets learn by processing examples, each of which contains a known “input” and “result,” forming probability-weighted asociations between the two, which are stored within the data structure of the net itself. (The “input” here is more accurately called an input set, since it generally consists of multiple independent variables, rather than a single value.) Thus, the “learning” of a neural net from a given example is the difference in the state of the net before and after processing the example. After being given a sufficient number of examples, the net becomes capable of predicting results from inputs, using the associations built from the example set. If a feedback loop is provided to the neural net about the accuracy of its predictions, it continues to refine its associations, resulting in an ever-increasing level of accuracy. In short, there is a direct relationship between the number and diversity of examples processed by a neural net and the accuracy of its predictions. This is why a neural net gets “better” with use. What is interesting about neural nets is that because they are indiscriminate in the way they form associations, they can form unexpected associations, and reveal relationships and dependencies that were not previously known.</p></blockquote><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We discussed the similarity and differences of ANN and Hash table in aspects of principle and history , which hopefully we could discover the new idea that are able to optimize algorithms of both or apply to the some specific issues  . One of the applications ,in my opinion , is that the Hash function could be replace by method of DeepLearning whose function trained by data . The advantages of this method is save algorithms development time of handled design .</p><p>On the other hand , because of the same structure form –input, functions, output – it’s unfortunately that , in some way ,there is no prograss about AI field during computer science development .</p><p>If we want to make some application using ideas we discovered ,we have to research in it more .</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Artificial_neural_network">wiki&#x2F;Artificial_neural_network</a></p><p><a href="https://en.wikipedia.org/wiki/Hash_table">wiki&#x2F;Hash_table</a></p><p><a href="https://en.wikipedia.org/wiki/Hash_function">wiki&#x2F;Hash_function</a></p><p><a href="https://softwareengineering.stackexchange.com/questions/108124/why-it-is-called-hash-table-or-hash-function-hash-doesnt-make-any-sense-t">Why it is called “hash table”, or “hash function”? </a></p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Robomaster Evolution</title>
    <link href="/2020/05/09/RobomasterRovo/"/>
    <url>/2020/05/09/RobomasterRovo/</url>
    
    <content type="html"><![CDATA[<h1 id="Robomaster-Evolution"><a href="#Robomaster-Evolution" class="headerlink" title="Robomaster Evolution"></a>Robomaster Evolution</h1><p><img src="/../img/RobomasterRovo/00.jpg"><br><img src="/../img/RobomasterRovo/01.jpg"><br><img src="/../img/RobomasterRovo/02.jpg"><br><img src="/../img/RobomasterRovo/03.jpg"><br><img src="/../img/RobomasterRovo/04.jpg"><br><img src="/../img/RobomasterRovo/05.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
      <tag>Robot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Structure From Multi-Views</title>
    <link href="/2020/05/06/StructureFromMultiViews/"/>
    <url>/2020/05/06/StructureFromMultiViews/</url>
    
    <content type="html"><![CDATA[<h1 id="Structure-From-Multi-Views"><a href="#Structure-From-Multi-Views" class="headerlink" title="Structure From Multi-Views"></a>Structure From Multi-Views</h1><h2 id="DEMO-at-first"><a href="#DEMO-at-first" class="headerlink" title="DEMO at first"></a>DEMO at first</h2><p><img src="/../img/StructureFromMultiViews/demo.gif" alt="DEMO"></p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ol start="0"><li><p>this project is modified from Chapter4_StructureFromMotion</p></li><li><p>non gpu version is better for beginner of learning CV . i.e. compile the project would be easy .</p></li><li><p>structure from multiple views</p></li><li><p>use AKAZE FeatureDetector and DescriptorExtractor instead of ORB </p></li><li><p>non opencv3_contrib verison</p></li></ol><h2 id="AKAZE-VS-ORB"><a href="#AKAZE-VS-ORB" class="headerlink" title="AKAZE VS ORB"></a>AKAZE VS ORB</h2><blockquote><p>We have concluded that, although ORB is faster to compute, AKAZE shows a better compromise between speed and performance than ORB for images with low resolution. Keywords: ORB, AKAZE, UAV, visual odometry, feature matching.</p></blockquote><p><a href="http://www.epacis.net/ccis2016/papers/paper_121.pdf">For more details – &gt; paper </a></p><h2 id="Matcher-FLANN-BASED-MATCHER-VS-BFMATCHER"><a href="#Matcher-FLANN-BASED-MATCHER-VS-BFMATCHER" class="headerlink" title="Matcher : FLANN-BASED MATCHER VS BFMATCHER"></a>Matcher : FLANN-BASED MATCHER VS BFMATCHER</h2><blockquote><p>BFMatcher is going to try all the possibilities (which is the meaning of “Brute Force” and hence it will find the best matches.</p></blockquote><blockquote><p>FLANN, meaning “Fast Library for Approximate Nearest Neighbors”, will be much faster but will find an approximate nearest neighbors. It will find a good matching, but not necessarily the best possible one. You can play with FLANN’s parameters in order to increase the precision (i.e. the “quality” of the matchings), but it will be at the cost of slowing the algorithm.</p></blockquote><blockquote><p>In other words: FLANN is much faster than BFMatcher but it only finds an approximate nearest neighbor, which is a good matching but not necessarily the best. You can play with the parameters of FLANN in order to increase its speed or its precision.</p></blockquote><p><a href="https://stackoverflow.com/questions/10610966/difference-between-bfmatcher-and-flannbasedmatcher">For more details – &gt; Q&amp;A </a></p><h2 id="Parse-SFM-project"><a href="#Parse-SFM-project" class="headerlink" title="Parse SFM project"></a>Parse SFM project</h2><h3 id="Files-Function"><a href="#Files-Function" class="headerlink" title="Files Function"></a>Files Function</h3><p><img src="/../img/StructureFromMultiViews/filesfunction.jpg"></p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="/../img/StructureFromMultiViews/UML.jpg"></p><h3 id="process-diagram"><a href="#process-diagram" class="headerlink" title="process diagram"></a>process diagram</h3><p><img src="/../img/StructureFromMultiViews/process.jpg"></p><h2 id="Project-repository"><a href="#Project-repository" class="headerlink" title="Project repository"></a>Project repository</h2><p><a href="https://github.com/MasteringOpenCV/code/tree/master/Chapter4_StructureFromMotion">original–Chapter4_StructureFromMotion</a></p><p><a href="https://github.com/pans0ul/StructureFromMultiViews">this project</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>SFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Structure From two views</title>
    <link href="/2020/04/28/StructureFrom2views/"/>
    <url>/2020/04/28/StructureFrom2views/</url>
    
    <content type="html"><![CDATA[<h1 id="Structure-From-two-views"><a href="#Structure-From-two-views" class="headerlink" title="Structure From two views"></a>Structure From two views</h1><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ol start="0"><li><p>this project is modified from Chapter4_StructureFromMotion</p></li><li><p>non gpu version is better for beginner of learning CV . i.e. compile the project would be easy .</p></li><li><p>structure from two views</p></li><li><p>non opencv3_contrib verison</p></li></ol><h2 id="Fix-bug-in-the-project"><a href="#Fix-bug-in-the-project" class="headerlink" title="Fix bug in the project"></a>Fix bug in the project</h2><h3 id="original-in-Distance-h"><a href="#original-in-Distance-h" class="headerlink" title="original in Distance.h"></a>original in Distance.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnlyMatchFeatures</span><span class="hljs-params">(<span class="hljs-type">int</span> strategy = STRATEGY_USE_OPTICAL_FLOW + STRATEGY_USE_DENSE_OF + STRATEGY_USE_FEATURE_MATCH)</span> </span>&#123;<br>imgpts1.<span class="hljs-built_in">clear</span>(); imgpts2.<span class="hljs-built_in">clear</span>(); fullpts1.<span class="hljs-built_in">clear</span>(); fullpts2.<span class="hljs-built_in">clear</span>();<br><br>std::vector&lt;cv::Mat&gt; imgs; imgs.<span class="hljs-built_in">push_back</span>(left_im); imgs.<span class="hljs-built_in">push_back</span>(right_im);<br>std::vector&lt;std::vector&lt;cv::KeyPoint&gt; &gt; imgpts; imgpts.<span class="hljs-built_in">push_back</span>(imgpts1); imgpts.<span class="hljs-built_in">push_back</span>(imgpts2);<br><br><span class="hljs-function">RichFeatureMatcher <span class="hljs-title">rfm</span><span class="hljs-params">(imgs,imgpts)</span></span>;<br>rfm.<span class="hljs-built_in">MatchFeatures</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>imgpts1 = rfm.<span class="hljs-built_in">GetImagePoints</span>(<span class="hljs-number">0</span>);<br>imgpts2 = rfm.<span class="hljs-built_in">GetImagePoints</span>(<span class="hljs-number">1</span>);<br><br>features_matched = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RecoverDepthFromImages</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">if</span>(!features_matched) <br><span class="hljs-built_in">OnlyMatchFeatures</span>();<br><br>std::vector&lt;cv::DMatch&gt; matches;<br><span class="hljs-built_in">FindCameraMatrices</span>(K, Kinv, distortion_coeff, imgpts1, imgpts2, imgpts1_good, imgpts2_good, P, P1, matches, pointcloud<br><br></code></pre></td></tr></table></figure><h3 id="modified-in-Distance-h"><a href="#modified-in-Distance-h" class="headerlink" title="modified in Distance.h"></a>modified in Distance.h</h3><ol><li>the variable matches is set as global in class Distance </li><li>rfm.MatchFeatures(0, 1,&amp;matches);</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void <span class="hljs-constructor">OnlyMatchFeatures(<span class="hljs-params">int</span> <span class="hljs-params">strategy</span> = STRATEGY_USE_OPTICAL_FLOW + STRATEGY_USE_DENSE_OF + STRATEGY_USE_FEATURE_MATCH)</span> &#123;<span class="hljs-comment">//Q</span><br>imgpts1.clear<span class="hljs-literal">()</span>; imgpts2.clear<span class="hljs-literal">()</span>; fullpts1.clear<span class="hljs-literal">()</span>; fullpts2.clear<span class="hljs-literal">()</span>;<br><br>std::vector&lt;cv::Mat&gt; imgs; imgs.push<span class="hljs-constructor">_back(<span class="hljs-params">left_im</span>)</span>; imgs.push<span class="hljs-constructor">_back(<span class="hljs-params">right_im</span>)</span>;<br>std::vector&lt;std::vector&lt;cv::KeyPoint&gt; &gt; imgpts; imgpts.push<span class="hljs-constructor">_back(<span class="hljs-params">imgpts1</span>)</span>; imgpts.push<span class="hljs-constructor">_back(<span class="hljs-params">imgpts2</span>)</span>;<br><br>RichFeatureMatcher rfm(imgs,imgpts); <span class="hljs-comment">//detect feature &amp; compute descriptors as globle of class RichFeatureMatcher</span><br><br><br><span class="hljs-comment">//pans0ul fix</span><br>rfm.<span class="hljs-constructor">MatchFeatures(0, 1,&amp;<span class="hljs-params">matches</span>)</span>;<br><br>imgpts1 = rfm.<span class="hljs-constructor">GetImagePoints(0)</span>; <span class="hljs-comment">//imgpts1 is globle of Distance</span><br>imgpts2 = rfm.<span class="hljs-constructor">GetImagePoints(1)</span>;<br><br>features_matched = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Reasons"><a href="#Reasons" class="headerlink" title="Reasons"></a>Reasons</h3><ol><li>function MatchFeatures() will update variable matches </li><li>the correct algorithm order is function FindCameraMatrices() after get matches </li><li>if the variable matches is empty ,there is no necessary to compute camera matrix</li></ol><h2 id="Parse-SFM-project"><a href="#Parse-SFM-project" class="headerlink" title="Parse SFM project"></a>Parse SFM project</h2><h3 id="Files-Function"><a href="#Files-Function" class="headerlink" title="Files Function"></a>Files Function</h3><p><img src="/../img/StructureFrom2views/filesfunction.jpg"></p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p><img src="/../img/StructureFrom2views/UML.jpg"></p><h3 id="process-diagram"><a href="#process-diagram" class="headerlink" title="process diagram"></a>process diagram</h3><p><img src="/../img/StructureFrom2views/process.jpg"></p><h2 id="Project-repository"><a href="#Project-repository" class="headerlink" title="Project repository"></a>Project repository</h2><p><a href="https://github.com/MasteringOpenCV/code/tree/master/Chapter4_StructureFromMotion">original–Chapter4_StructureFromMotion</a></p><p><a href="https://github.com/pans0ul/StructureFrom2views_of_Chapter4_StructureFromMotion">this project</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>SFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>National Undergraduate Electronic Design Contest</title>
    <link href="/2020/04/21/nationalUndergraduateElectronicDesignContest/"/>
    <url>/2020/04/21/nationalUndergraduateElectronicDesignContest/</url>
    
    <content type="html"><![CDATA[<h1 id="National-Undergraduate-Electronic-Design-Contest"><a href="#National-Undergraduate-Electronic-Design-Contest" class="headerlink" title="National Undergraduate Electronic Design Contest"></a>National Undergraduate Electronic Design Contest</h1><p><strong>National Undergraduate Electronic Design Contest consists of two parts .One is analog electronic design ,another is theme design.</strong> </p><p><img src="/../img/NationalUndergraduateElectronicDesignContest/Nation%20ELEC%20Match-A.jpg" alt="analog practise"></p><p><img src="/../img/NationalUndergraduateElectronicDesignContest/Nation%20ELEC%20Match-xian.jpg" alt="Contest memories"></p><p><img src="/../img/NationalUndergraduateElectronicDesignContest/li-poem.jpg" alt="poem from Mr.Li"></p><p><strong>致谢</strong><br><strong>温州大学</strong><br><strong>我的导师–陈老师</strong><br><strong>我的导师和诗人–李老师</strong><br><strong>我的两位队友</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reading SFM in book Mastering OpenCV</title>
    <link href="/2020/04/03/Reading-SFM%20in%20book%20-Mastering%20OpenCV/"/>
    <url>/2020/04/03/Reading-SFM%20in%20book%20-Mastering%20OpenCV/</url>
    
    <content type="html"><![CDATA[<h1 id="Reading-SFM-in-book-Mastering-OpenCV"><a href="#Reading-SFM-in-book-Mastering-OpenCV" class="headerlink" title="Reading SFM in book: Mastering OpenCV"></a>Reading SFM in book: Mastering OpenCV</h1><blockquote><p>Mastering OpenCV with Practical Computer Vision Projects</p></blockquote><h3 id="chartper-4-Exploring-Structure-from-Motion-Using-OpenCV"><a href="#chartper-4-Exploring-Structure-from-Motion-Using-OpenCV" class="headerlink" title="chartper 4 : Exploring Structure from Motion Using OpenCV"></a>chartper 4 : Exploring Structure from Motion Using OpenCV</h3><p><strong>This book is a good tutorial to explain SFM ( structure from motion ) implementation . I give brief about in this charpter : SFM covered</strong></p><p><img src="/../img/Reading-SFM%20in%20book%20-Mastering%20OpenCV/2020-04-18-15-41-49.png"></p><h3 id="Section-1-Structure-from-Motion-concepts"><a href="#Section-1-Structure-from-Motion-concepts" class="headerlink" title="Section 1 : Structure from Motion concepts"></a>Section 1 : Structure from Motion concepts</h3><p>Every knowledge was built by concepts at first .Structure from Motion concepts in Section 1  to tell us that what is SFM ,about concepts related to SFM ,such as camera calibration ,triangulation of 3d points ,camera motion ,the brief of principle that how to reconstruction 3D object , etc..</p><h3 id="Section-2-Estimating-the-camera-motion-from-a-pair-of-images"><a href="#Section-2-Estimating-the-camera-motion-from-a-pair-of-images" class="headerlink" title="Section 2: Estimating the camera motion from a pair of images"></a>Section 2: Estimating the camera motion from a pair of images</h3><p>Estimating the camera motion from a pair of images talk about that how to get Essential Matrix and decompose it to obtain the R, t  from two key images which are taken from monocular with sequence time , where R is rotation matrix of camera motion ,and the t  is translation matrix of camera motion . Briefly ,R , t is two key matrix to consist of camera motion .</p><h3 id="Section-3-Reconstructing-the-scene"><a href="#Section-3-Reconstructing-the-scene" class="headerlink" title="Section 3 : Reconstructing the scene"></a>Section 3 : Reconstructing the scene</h3><p>Reconstructing the scene to tell us that after extract camera motion matrix , we use triangulation method and motion matrix to reconstruct 3d points into the scene ,but only to use two camera views . Then this book give the mothed how to extract high quality 3d points by using contrasting two 2d points . one of the point is original in the photo and another is reimaged point from 3d points . </p><h3 id="Section-4-Reconstruction-from-many-views"><a href="#Section-4-Reconstruction-from-many-views" class="headerlink" title="Section 4 : Reconstruction from many views"></a>Section 4 : Reconstruction from many views</h3><p>According the method from Section3 , the principle of Reconstruction from many views would be same . So it just does more procedures to be done .</p><h3 id="Section-5-Refinement-of-the-reconstruction"><a href="#Section-5-Refinement-of-the-reconstruction" class="headerlink" title="Section 5 : Refinement of the reconstruction"></a>Section 5 : Refinement of the reconstruction</h3><p>Refinement of the reconstruction .This process is helpful for get precise and high quality 3d points . The known as the process of Bundle Adjustment(BA) ,helping for refining and optimizing the reconstructed scene . One implementation of a bundle adjustment algorithm is Simple Sparse Bundle Adjustment (SSBA) . You will see the illustration of construction between algorithm applied and doesn’t .</p><h3 id="Section-6-Visualizing-3D-point-clouds"><a href="#Section-6-Visualizing-3D-point-clouds" class="headerlink" title="Section 6: Visualizing 3D point clouds"></a>Section 6: Visualizing 3D point clouds</h3><p>Visualizing 3D point clouds ,this section give a introduction about visualization tool, PCL (point cloud library) , The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D&#x2F;3D image and point cloud processing. Also could be use in this case—SFM.</p>]]></content>
    
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>SFM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D-printer</title>
    <link href="/2019/08/18/3d-printer/"/>
    <url>/2019/08/18/3d-printer/</url>
    
    <content type="html"><![CDATA[<h1 id="DIY-for-3D-printer-during-two-weeks"><a href="#DIY-for-3D-printer-during-two-weeks" class="headerlink" title="DIY for 3D-printer during two weeks"></a>DIY for 3D-printer during two weeks</h1><p><img src="/../img/3d-printer/3D-PRINTER-comp.jpg" alt="some components"><br><img src="/../img/3d-printer/3D-PRINTER-assem.jpg" alt="building"><br><img src="/../img/3d-printer/3D-PRINTER-run.jpg" alt="try to print"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
